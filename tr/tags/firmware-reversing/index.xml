<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>0xbekoo – Firmware-Reversing</title>
    <link>http://localhost:1313/tr/tags/firmware-reversing/</link>
    <description>Recent content in Firmware-Reversing on 0xbekoo</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>tr</language>
    <lastBuildDate>Wed, 04 Dec 2024 00:00:00 +0000</lastBuildDate>
    
	  <atom:link href="http://localhost:1313/tr/tags/firmware-reversing/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>ARM Firmware Reverse Engineering</title>
      <link>http://localhost:1313/tr/blog/bare-metal-reversing/</link>
      <pubDate>Wed, 04 Dec 2024 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/tr/blog/bare-metal-reversing/</guid>
      <description>
        
        
        &lt;p&gt;Merhabalar. Bu yazıda Firmware Reverse Engineering&amp;rsquo;e devam ediyoruz. Bu blogta ise Bare Metal Reversing&amp;rsquo;e girişeceğiz.&lt;/p&gt;
&lt;p&gt;Hatırlarsanız önceki konumuzda TP-LINK Archer AX 21 V4.6&amp;rsquo;ın 2024 yılında çıkmış Firmware&amp;rsquo;ini analiz etmiştik. Bu konuda ise işleri birazcık ileriye götüreceğiz.&lt;/p&gt;
&lt;p&gt;Elimde bir Nucleo F030R8 kart (ARM Cortex M0 işlemcili) var ve bunu Firmware Reverse Engineering için değerlendirmek istedim. Bu blogta yapacağımız şey de bu kart&amp;rsquo;ı basitçe programlayacağız ve ardından firmware&amp;rsquo;ini reverse edip karta tekrar yükleyeceğiz. Tipik olarak bir Iot kartını hackliyor gibi düşünelim ancak daha basit bir senaryo ile.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../images/posts/bare-metal-reversing-0x0/nucleo-card.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Elimdeki kart bu. Eğer elinizde nucleo&amp;rsquo;nun farklı bir kartı var ise de bu blogtaki adımları takip edebilirsiniz.&lt;/p&gt;
&lt;p&gt;Açıkçası mikrodenetleyici kodlama konusunda kendimi geliştirmedim. Ancak bu konsept sürecinde beraber hem mikrodenetleyici kodlamaya hem de firmware reverse engineering alanlarında kendimizi geliştireceğiz.&lt;/p&gt;
&lt;p&gt;Gerekli programlar ise CubeIde, CubeProgrammer ve Ghidra olacaktır. CubeIde ile kartımız için programlamayı yapacağız, Ghidra ile aldığımız firmware yani .bin dosyasını reverse edeceğiz ve son adımda CubeProgrammer ile reverse ettiğimiz firmware’i kartımıza yükleyeceğiz.&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;Kodlama&lt;/strong&gt;&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;kodlama&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#kodlama&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Yapacağımız kodlama tamamen basit. &lt;strong&gt;Nucleo F030R8&lt;/strong&gt; kartında bir adet User Button (Fotoğrafta mavi button&amp;rsquo;a göz atabilirsiniz) ve Green led (LD2) bulunmakta. Button&amp;rsquo;a basıldığında Green Led&amp;rsquo;i yakan bir kodlama yapacağız. Daha sonra Ghidra kullanarak IDE&amp;rsquo;den aldığımız firmware reverse ederek bu programın çalışma prensibini tersine çevireceğiz. Yani reverse ettikten sonra button&amp;rsquo;a basmadığımız durumlarda Green led&amp;rsquo;i yakacak.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/posts/bare-metal-reversing-0x0/img1.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;CubeIDE&amp;rsquo;de projeyi oluşturduktan sonra &lt;strong&gt;.ioc&lt;/strong&gt; dosyasına yönlenebiliriz. Kart üzerindeki button ve led ile çalışacağımız için fotoğraftan da görüldüğü üzere ayarlamalar zaten IDE tarafından yapılmış durumda. Bu yüzden burada yapacağımız ekstra bir şey yok. Benim kartımdan User Button &lt;strong&gt;PC13&lt;/strong&gt;&amp;lsquo;da ve Led2 ise &lt;strong&gt;PA5&lt;/strong&gt;&amp;lsquo;de bulunmakta.&lt;/p&gt;
&lt;p&gt;Kodlamaya geçmeden önce oluşturduğumuz projede ufak bir ayar yapmamız gerekecek. Firmware&amp;rsquo;i analiz edeceğimiz için programın karta yüklenmesiyle .bin dosyasını almamız gerekecek:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/posts/bare-metal-reversing-0x0/img3.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Oluşturduğumuz projeye sağ tıklayalım ve &lt;strong&gt;Properties&lt;/strong&gt; seçeğine tıklayalım. Daha sonra &lt;strong&gt;C/C++ Build &amp;gt; Settings &amp;gt; MCU/MPU Post Build Outputs&lt;/strong&gt;&amp;lsquo;a gidelim ve &lt;strong&gt;Convert to binary file (-O binary)&lt;/strong&gt; seçeneğini aktifleştirelim.&lt;/p&gt;
&lt;p&gt;Şimdi ise IDE&amp;rsquo;nin en solunda bulunan &lt;strong&gt;Project Explorer&lt;/strong&gt; sekmesinde &lt;strong&gt;Core &amp;gt; Src &amp;gt; main.c&lt;/strong&gt; projesine yönelelim. Bu bizim ana projemiz.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;main.c&lt;/strong&gt; içerisinde kodlamaya geçmeden önce oluşturulmuş &lt;strong&gt;MX_GPIO_Init&lt;/strong&gt; fonksiyonuna göz atabiliriz. Bu fonksiyon, IDE tarafından hazırlanan pin&amp;rsquo;lerin konfigurasyonunu içerir:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../images/posts/bare-metal-reversing-0x0/img2.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Göründüğü üzere &lt;strong&gt;F030R8&lt;/strong&gt; kartı için User Button&amp;rsquo;a GPIOA olarak B1_Pin (GPIO_PIN_13) ve LED2 için ise GPIOA ve LD2_PIN (GPIO_PIN_5) olarak ayarlanmış. Eğer farklı bir kartta iseniz bu ayarları kontrol edebilirsiniz.&lt;/p&gt;
&lt;p&gt;Şimdi ise main fonksiyonuna dönelim ve kodlamalara başlayalım:&lt;/p&gt;
&lt;div class=&#34;hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code&#34;&gt;

&lt;div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;cm&#34;&gt;/* USER CODE BEGIN 2 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;kt&#34;&gt;uint8_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ButtonStatus&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	  &lt;span class=&#34;n&#34;&gt;ButtonStatus&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;HAL_GPIO_ReadPin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;B1_GPIO_Port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B1_Pin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ButtonStatus&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		  &lt;span class=&#34;nf&#34;&gt;HAL_GPIO_WritePin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;LD2_GPIO_Port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;LD2_Pin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SET&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	  &lt;span class=&#34;nf&#34;&gt;HAL_GPIO_WritePin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;LD2_GPIO_Port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;LD2_Pin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;RESET&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0&#34;&gt;
  &lt;button
    class=&#34;hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50&#34;
    title=&#34;Copy code&#34;
  &gt;
    &lt;div class=&#34;copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
    &lt;div class=&#34;success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
  &lt;/button&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Göründüğü üzere kod gayet basit bir durumda. Şimdi tek tek ele alalım:&lt;/p&gt;
&lt;div class=&#34;hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code&#34;&gt;

&lt;div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;ButtonStatus&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;HAL_GPIO_ReadPin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;B1_GPIO_Port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B1_Pin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0&#34;&gt;
  &lt;button
    class=&#34;hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50&#34;
    title=&#34;Copy code&#34;
  &gt;
    &lt;div class=&#34;copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
    &lt;div class=&#34;success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
  &lt;/button&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;İlk olarak main&amp;rsquo;in while içerisinde &lt;strong&gt;HAL_GPIO_ReadPin&lt;/strong&gt; fonksiyonunu kullanıyoruz.Bu fonksiyon ilgili pinin durumunu okumak için kullanılıyor ve iki parametre almaktadır. İlk parametre, pinin bulunduğu GPIO portunu belirtir. STM32 mikrodenetleyicilerinde, GPIO pinleri belirli portlara (A, B, C, vb.) bağlıdır. Örneğin, GPIOA, GPIOB, GPIOC gibi portlar bulunur. Bu parametre, pinin hangi portta yer aldığını belirtmek için kullanılır. Kodumuzda ise &lt;strong&gt;GPIOA&lt;/strong&gt; olduğunu belirtiyoruz.&lt;/p&gt;
&lt;p&gt;İkinci parametre ise okumak istediğiniz GPIO pinini belirtir. Her portun üzerinde birden fazla pin bulunabilir (örneğin, port A&amp;rsquo;da PA0, PA1, PA2 vb.). Bu parametre, hangi pinin durumunu okuyacağınızı belirtir. Kodumuzda ise B1_Pin yani &lt;strong&gt;GPIO_PIN_13&lt;/strong&gt; olduğunu belirtiyoruz.&lt;/p&gt;
&lt;p&gt;Son olarak ise bu fonksiyonun dönüş adresi &lt;strong&gt;uint8_t&lt;/strong&gt; tipinde olan ButtonStatus değişkenine aktarılır. Yani kısaca bu fonksiyon, belirtilen pin&amp;rsquo;deki durumu okur ve ButtonStatus değişkenine sonucu aktarır.&lt;/p&gt;
&lt;div class=&#34;hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code&#34;&gt;

&lt;div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ButtonStatus&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;HAL_GPIO_WritePin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;LD2_GPIO_Port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;LD2_Pin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SET&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;HAL_GPIO_WritePin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;LD2_GPIO_Port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;LD2_Pin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;RESET&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0&#34;&gt;
  &lt;button
    class=&#34;hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50&#34;
    title=&#34;Copy code&#34;
  &gt;
    &lt;div class=&#34;copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
    &lt;div class=&#34;success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
  &lt;/button&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Pin okumasından sonra bir if karşılaştırması yapıyoruz. ButtonStatus&amp;rsquo;a atanan değer eğer sıfır ise &lt;strong&gt;HAL_GPIO_WritePin&lt;/strong&gt;  ile LED2 için işlem yapıyor.&lt;/p&gt;
&lt;p&gt;ButtonStatus değerinin 0 olması demek Button&amp;rsquo;a basıldığı anlamına gelmektedir. 1 olması durumunda Button&amp;rsquo;a basılmadığı anlamına gelir. Yani biz bu if içerisinde Button&amp;rsquo;a basıldığında Led&amp;rsquo;in yanmasını sağlayacağız.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HAL_GPIO_WritePin&lt;/strong&gt; fonksiyonu, belirli bir GPIO pinini t1 - HIGH durumu) veya &amp;ldquo;reset&amp;rdquo; (0 - LOW durumu) durumuna getirmek için kullanılır.&lt;/p&gt;
&lt;p&gt;İlk parametre, önceden anlatıldığı gibi hangi GPIO portunun kullanılacağını belirtir ve kodumuzda GPIOA olarak belirttim. İkinci parametre, ayarlanacak veya sıfırlanacak GPIO pinini belirtir ve tanımlanan GPIO_PIN_5 değerini taşıyan LD2_PIN değişkeni verdim. Son olarak üçüncü parametre ise Pinin durumu belirtilir. İf içerisindeki amacımız led&amp;rsquo;i yakmak olduğu için &lt;strong&gt;SET&lt;/strong&gt; değerini verebiliriz. Bu ilgili pinin durumunu 1 olarak ayarlayacaktır.&lt;/p&gt;
&lt;p&gt;Eğer button&amp;rsquo;a basılmadığı sürece yine &lt;strong&gt;HAL_GPIO_WritePin&lt;/strong&gt; fonksiyonunu kullanıyoruz ancak son parametresi &lt;strong&gt;RESET&lt;/strong&gt; olarak belirtiliyor. Bu, button&amp;rsquo;a basılmadığı zaman ilgili pini 0 olarak ayarlar. Böylece button&amp;rsquo;a basılmadığı zaman led yanmayacaktır.&lt;/p&gt;
&lt;p&gt;Şimdi ise bu kodu kartımıza yükleyelim ve sonuca bir bakalım:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../images/posts/bare-metal-reversing-0x0/video/coding.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Göründüğü gibi sorunsuz bir şekilde programımız çalışıyor. Button&amp;rsquo;a tıkladığım anda green Led yanmakta. Şimdi ise Ghidra&amp;rsquo;ya dönelim ve aldığımız .bin dosyasını ghidra&amp;rsquo;da analiz etmeye başlayalım. Oluşturulan .bin dosyası Debug dosyasının altında olacaktır:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../images/posts/bare-metal-reversing-0x0/img4.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;Firmware Reversing&lt;/strong&gt;&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;firmware-reversing&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#firmware-reversing&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;.bin dosyasını ghidra&amp;rsquo;da &lt;strong&gt;File &amp;gt; Import File&lt;/strong&gt; tıklayarak .bin dosyamızı seçelim ancak direkt olarak çıkan ekranı kapatmayın önemli ayarlamaları yapmamız gerekecek.&lt;/p&gt;
&lt;p&gt;Öncelikle Languages kısmını ayarlayarak başlayalım ve filter alanına &lt;strong&gt;ARM&lt;/strong&gt; diye aratalım:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../images/posts/bare-metal-reversing-0x0/img5.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Ben Language olarak &lt;strong&gt;Cortex 32-bit, Little Endian&lt;/strong&gt; olarak seçtim. Eğer aynı karta sahip iseniz bu seçeneği, farklı karta sahip iseniz kartınıza uygun olarak dil seçimini yapın. Daha sonra OK diyerek bu Language sekmesinden çıkabilirsiniz.&lt;/p&gt;
&lt;p&gt;Daha sonra aynı ekrandan &lt;strong&gt;Options&lt;/strong&gt; kısmına tıklayalım ve burada yapacağımız ayar gerçekten önemli. Burada Base Address gibi ayarlamalar yapacağız.&lt;/p&gt;
&lt;p&gt;İlk olarak base address ayarını yapmamız gerekecek. **ki ama bir firmware&amp;rsquo;in Base Addresini nasıl bulabiliriz? diye bir soru gelebilir. En iyi yöntem cihazın memory haritasına bakmak olacaktır.&lt;/p&gt;
&lt;p&gt;ARM tabanlı bir kartta çalışıyoruz. Nucleo&amp;rsquo;nun datasheet&amp;rsquo;leri aracılığıyla Base Address&amp;rsquo;i bulabiliriz:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../images/posts/bare-metal-reversing-0x0/img6.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Yukarıdaki fotoğraf &lt;strong&gt;STM32F030x4/x6/x8/xC&lt;/strong&gt; kartlarının memory haritası. Benim kartım bu cihazlar arasından olduğundan dolayı bu memory haritasından yararlanmam gerekecek:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../images/posts/bare-metal-reversing-0x0/img7.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Fotoğrafa daha detaylı baktığımızda Flash memory alanın &lt;strong&gt;0x8000000&lt;/strong&gt; olduğunu görebiliriz. ARM Tabanlı işlemcilerin Base Address&amp;rsquo;in çoğu zaten bu adrestedir ancak yine de farklı karta sahip iseniz datasheet ile adresine bakmakta fayda olacaktır.&lt;/p&gt;
&lt;p&gt;Daha sonra datasheet ile elde ettiğimiz adresi Ghidra&amp;rsquo;nın Options sekmesinden &lt;strong&gt;Base Address&lt;/strong&gt; alanına yazalım:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../images/posts/bare-metal-reversing-0x0/img8.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Block Name ismine &lt;strong&gt;flash&lt;/strong&gt; olarak verdim. Sizde böyle yapabilirsiniz. Diğer ayarlara dokunmamıza gerek yok sadece &lt;strong&gt;Block Name&lt;/strong&gt; ve &lt;strong&gt;Base Address&lt;/strong&gt; değerlerini vermemiz yeterlidir. OK button&amp;rsquo;a tıklayalım ve artık ekranda .bin dosyasına çift tıklayalım.&lt;/p&gt;
&lt;p&gt;Fakat birkaç daha ayar yapmamız gerekecek. CodeBrowser ekranı açıldığında ekranın ortasında bulunan &lt;strong&gt;Memory Map&lt;/strong&gt; kısmına tıklayalım:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../images/posts/bare-metal-reversing-0x0/img9.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Daha sonra bu ekranda sağ üste bulunan &amp;lsquo;+&amp;rsquo; işaretine tıklayalım:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../images/posts/bare-metal-reversing-0x0/img10.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Yine burada birkaç bellek alanı ayarlamamız gerekecek. İlk olarak &lt;strong&gt;Flash Memory&lt;/strong&gt; alanını ayarlamamız gerekecek. Peki nedir bu?&lt;/p&gt;
&lt;p&gt;Flash Mirror, firmware&amp;rsquo;in çalıştırılabilir kodunun genellikle saklandığı alanı temsil eder. Çoğu gömülü sistemde, bu bölge işlemciye bağlı olarak 0x0 adresinden başlar ve firmware&amp;rsquo;in yüklenip çalıştırılacağı yerdir. Flash bölgesi kod bölgesini (örneğin, main fonksiyon, başlangıç kodları, vb.) içerir&lt;/p&gt;
&lt;p&gt;Yinede offset&amp;rsquo;i doğrulamak için datasheet&amp;rsquo;e bakabiliriz. Yukarıda paylaştığım fotoğrafa tekrar göz atarsak benim kart için 0x0 alanında olduğunu görebiliriz. Şimdi ise bu alanı ayarlayalım:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../images/posts/bare-metal-reversing-0x0/img11.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Block Name&lt;/strong&gt; alanına &amp;lsquo;flash_mirror&amp;rsquo; ismini verebiliriz. &lt;strong&gt;Start Addr&lt;/strong&gt; alanına ise default olarak 0&amp;rsquo;da bırakalım. &lt;strong&gt;Length&lt;/strong&gt; alanını ise okla gösterildiği gibi flash ismi ile ayarladığımız alanın boyutu ile aynı olacak şekilde ayarlayın. Daha sonra Execute kutucuğunu işaretleyelim. &lt;strong&gt;Block Types&lt;/strong&gt; alanında File Bytes kutucuğunu işaretleyelim ve &lt;strong&gt;File Offsett&lt;/strong&gt; değerini 0 olarak bırakalım ve bitirmek için OK tuşuna basalım.&lt;/p&gt;
&lt;p&gt;Son alanımızı ayarlamak için yine &amp;lsquo;+&amp;rsquo; tuşuna basalım. Bu sefer ise SRAM alanını ayarlayacağız. Genel olarak adresi &lt;strong&gt;0x20000000&lt;/strong&gt;&amp;lsquo;dir ancak yine de bunu doğrulamak için kartımızın dahasheet&amp;rsquo;ine bakabiliriz:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../images/posts/bare-metal-reversing-0x0/img12.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Göründüğü üzere 0x20000000 adresinde olduğunu görebiliyoruz. Şimdi SRAM&amp;rsquo;in de alanını ayarlayalım:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../images/posts/bare-metal-reversing-0x0/img13.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Block Name&lt;/strong&gt; alanına &amp;lsquo;RAM&amp;rsquo; ismini verebiliriz. &lt;strong&gt;Start Addr&lt;/strong&gt; alanına 20000000 değerini verelim. &lt;strong&gt;Length&lt;/strong&gt; değerine ise 80000 verelim. Daha sonra OK diyerek ekranı kapatalım.&lt;/p&gt;
&lt;p&gt;İşlemlerimiz bitti. Şimdi ise ekranın sol üstünde bulunan kaydetme tuşuna basalım ve Memory Map ekranını kapatalım:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../images/posts/bare-metal-reversing-0x0/img14.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Son bir işlemimiz kaldı. Ekranı kapattıktan sonra Ghidra&amp;rsquo;nın sol üstündeki bar&amp;rsquo;dan &lt;strong&gt;Analysis &amp;gt; Auto Analyze&amp;rsquo;&lt;project&gt;.bin&amp;rsquo;&lt;/strong&gt; kısmına gidelim ve bu ekranda &lt;strong&gt;&amp;lsquo;ARM Aggressive Instruction Finder (Prototype)&amp;rsquo;&lt;/strong&gt; seçeceğini aktifleştirelim ve &amp;lsquo;Analyze&amp;rsquo; button&amp;rsquo;a tıklayalım:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../images/posts/bare-metal-reversing-0x0/img15.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Artık her şey için hazırız. Şimdi ise Disassembly ekranından en üst tarafa bir göz atalım:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../images/posts/bare-metal-reversing-0x0/img16.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Eğer benim gibi yeni iseniz burada işaretlenenleri gördüğünüzde biraz kafanız karışabilir ama aslında basit.&lt;/p&gt;
&lt;p&gt;Fotoğrafta gördüğünüz bu alana &amp;lsquo;vektör tablosu&amp;rsquo; deniyor. CPU, sistem başlatıldığında ilk olarak buradan Stack Pointer’ı (yığın işaretçisi) yükler. Yani tablonun ilk adresi, sistemin yığın belleğinin başlangıç adresini gösterir. Daha sonra işlemci, bu tabloda tanımlı olan Reset Handler (Reset İşleyicisi) adresine sıçrayarak çalışmaya başlar.&lt;/p&gt;
&lt;p&gt;Vektör tablosu, mikrodenetleyicinin işletim sırasında karşılaşabileceği tüm kesme (interrupt) ve hata (fault) durumlarına nasıl tepki vereceğini tanımlar. Örneğin:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Reset:&lt;/strong&gt; CPU yeniden başlatıldığında çalışacak kodun adresini belirler. Bu, genellikle sistemin ilk ayarlarını yapan başlatma fonksiyonudur.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NMI (Non-Maskable Interrupt):&lt;/strong&gt; Maskelenemeyen, yani her zaman işlenmesi gereken bir kesme durumudur.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;HardFault:&lt;/strong&gt; Kritik bir hata meydana geldiğinde çağrılan işleyicidir.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;BusFault:&lt;/strong&gt; Bellek erişim hataları gibi donanım sorunlarını yönetir.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;UsageFault:&lt;/strong&gt; Yanlış talimat veya matematiksel hatalar gibi yazılımla ilgili sorunlar için işleyici sağlar.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Bizim burada ilgileneceğimiz kısım &lt;strong&gt;Reset&lt;/strong&gt; alanı olacaktır. &lt;strong&gt;Reset&lt;/strong&gt; vektörü, C Programın giriş bölümüne benzer şekilde basit kurulum kodları içermektedir. Bu vektör içerisinde main fonksiyon çağırıldığı için buradan ana fonksiyonu bulacağız.&lt;/p&gt;
&lt;p&gt;Şimdi Reset vektör ile işaretlenen adrese çift tıklayalım:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../images/posts/bare-metal-reversing-0x0/img17.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Assembly kodlarını okuyan hayatsız bir birey olmak yerine normal bir insan gibi decompiler ile bakabiliriz:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../images/posts/bare-metal-reversing-0x0/img18.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Burada umursamadığımız birkaç döngü vs. kullanıldığını ve fonksiyon çağırıldığını görmekteyiz. Çağırılan üç fonksiyonundan ikisine göz attım ancak bir şey anlamadım ve son çağırılan fonksiyona göz attığımda main fonksiyon olduğunu doğruladım:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../images/posts/bare-metal-reversing-0x0/img19.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Daha anlaşılır gözükmesi için Fonksiyon adlarını vs. güncelledim. Fonksiyona baktığımızda zaten kodlama yaptığımız esnada anlatmıştım. Bir farklılık bulunmamakta. Şimdi Assembly kodlarına dönüp Patch işlemi yapacağız.&lt;/p&gt;
&lt;p&gt;Yapacağımız şey de basit. if koşulundaki &amp;lsquo;0&amp;rsquo; değerini &amp;lsquo;1&amp;rsquo; ile değiştireceğiz. Böylece button&amp;rsquo;a basmadığımız zamanlarda led yanmış olacak.&lt;/p&gt;
&lt;p&gt;main fonksiyonun Dissassembly ekranında if koşuluna karşılık gelen instruction&amp;rsquo;u bulalım ve sağ tıklayıp &lt;strong&gt;Patch Instruction&lt;/strong&gt; seçeceğine tıklayalım:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../images/posts/bare-metal-reversing-0x0/img20.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Daha sonra 0x0 değerini &lt;strong&gt;0x1&lt;/strong&gt; olarak değiştirelim ve enter tuşuna basalım. Bu işlemden sonra Decompiler&amp;rsquo;dan kontrol ettiğimizde sonuç şu şekilde olmalı:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../images/posts/bare-metal-reversing-0x0/img21.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Her şey bu kadar. Şimdi Ghidra ekranında sol üstünde **File &amp;gt; &lt;strong&gt;Save &amp;lsquo;.bin&amp;rsquo; As&amp;hellip;&lt;/strong&gt; sekmesine tıklayalım:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../images/posts/bare-metal-reversing-0x0/img22.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Sonu &amp;lsquo;.bin&amp;rsquo; ile bitecek şekilde bir isim vererek projeyi kaydedin.&lt;/p&gt;
&lt;p&gt;Son olarak CodeBrowser ekranını kapatın ve kaydettiğiniz projeye sağ tıklayıp export diyerek projeyi bilgisayara kaydedin:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../images/posts/bare-metal-reversing-0x0/img23.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Şimdi bu reverse ettiğimiz .bin dosyasını CubeProgrammer aracılığıyla kartımıza yükleyeceğiz.&lt;/p&gt;
&lt;p&gt;CubeProgrammer&amp;rsquo;i başlatalım ve programın sağ üstündeki &lt;strong&gt;Connect&lt;/strong&gt; buttonu ile kartımızı bağlayalım:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../images/posts/bare-metal-reversing-0x0/img24.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Göründüğü gibi kartımıza bağlandığında memory address&amp;rsquo;leri vs görmekteyiz.&lt;/p&gt;
&lt;p&gt;Programda &amp;lsquo;Open File&amp;rsquo; seçeceğine tıklayarak reverse ettiğimiz .bin dosyasını seçelim ve ardından &amp;lsquo;Download&amp;rsquo; seçeceğine tıklayarak reverse ettiğimiz firmware&amp;rsquo;i kartımıza yükleyelim:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../images/posts/bare-metal-reversing-0x0/img25.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Göründüğü gibi ekranda &amp;lsquo;File Download Complete&amp;rsquo; mesajı alıyoruz. Tebrikler artık elimizde reverse edilmiş bir firmware ile çalışan  kartımız var!&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;Sonuç&lt;/strong&gt;&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;sonuç&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#sonu%c3%a7&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Şimdi kartın son haliyle bir kez daha göz atalım:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../images/posts/bare-metal-reversing-0x0/video/reversing.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Videodan göründüğü üzere Button&amp;rsquo;a basmadığımız durumlarda Led yanıyor. Eğer button&amp;rsquo;a basarsak led sönüyor.&lt;/p&gt;
&lt;p&gt;Temel olarak yaptığımız şey oldukça basitti. Basitçe kartımızı button&amp;rsquo;a basıldığında led yakacak şekilde kodladık ve Ghidra ile kartın firmware&amp;rsquo;ini reverse ederek kodladığımızın tersini yapacak şekilde ayarladık ve karta tekrar yükledik.&lt;/p&gt;
&lt;p&gt;Umarım içerik sizin için faydalı olmuştur. Eğer konuyu daha detaylı araştırmak isterseniz &lt;strong&gt;referans olarak bıraktığım kaynaklara göz atabilirsiniz.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;İyi çalışmalar dilerim efenimmm.&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;References&lt;/strong&gt;&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;references&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#references&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=q4CxE5P6RUE&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;Stacksmashing - Bare-metal ARM Firmware Reverse Engineering with Ghidra&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cutawaysecurity.com/learning-ghidra-basics-analyzing-firmware/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;Cutaway Security - Learning Ghidra Basics Analyzing Firmware&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://cybergibbons.com/hardware-hacking/reading-and-writing-firmware-on-an-stm32-using-swd/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;Cybergibbons - Reading and Writing Firmware on an STM32 using SWD&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Router Firmware Reverse Engineering</title>
      <link>http://localhost:1313/tr/blog/router-firmware-reversing/</link>
      <pubDate>Tue, 03 Dec 2024 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/tr/blog/router-firmware-reversing/</guid>
      <description>
        
        
        &lt;p&gt;&lt;img src=&#34;../../../images/posts/reversing-router/headerphoto.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Merhabalar. Firmware Reverse Engineering için ilk bloguma hoşgeldiniz. Bu yazıda TP-Link&amp;rsquo;in &lt;a href=&#34;https://www.tp-link.com/us/home-networking/wifi-router/archer-ax21/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Archer AX 21 V4.6&lt;/a&gt; modemin firmware&amp;rsquo;i reverse edeceğiz. Firmware indirmek için &lt;a href=&#34;https://www.tp-link.com/us/support/download/archer-ax21/#Firmware&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;TP-Link&amp;rsquo;in orijinal sayfasına&lt;/a&gt; göz atabilirsiniz.&lt;/p&gt;
&lt;div class=&#34;hx-overflow-x-auto hx-mt-6 hx-flex hx-flex-col hx-rounded-lg hx-border hx-py-4 hx-px-4 contrast-more:hx-border-current contrast-more:dark:hx-border-current hx-border-amber-200 hx-bg-amber-100 hx-text-amber-900 dark:hx-border-amber-200/30 dark:hx-bg-amber-900/30 dark:hx-text-amber-200&#34;&gt;
  &lt;p class=&#34;hx-flex hx-items-center hx-font-medium&#34;&gt;&lt;svg height=16px class=&#34;hx-inline-block hx-align-middle hx-mr-2&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34; fill=&#34;none&#34; viewBox=&#34;0 0 24 24&#34; stroke-width=&#34;2&#34; stroke=&#34;currentColor&#34; aria-hidden=&#34;true&#34;&gt;&lt;path stroke-linecap=&#34;round&#34; stroke-linejoin=&#34;round&#34; d=&#34;M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z&#34;/&gt;&lt;/svg&gt;Warning&lt;/p&gt;

  &lt;div class=&#34;hx-w-full hx-min-w-0 hx-leading-7&#34;&gt;
    &lt;div class=&#34;hx-mt-6 hx-leading-7 first:hx-mt-0&#34;&gt;&lt;p&gt;Bu blogta, paylaşılan bilgiler, güvenlik araştırmaları ve teknik eğitim amacıyla sunulmaktadır. İlgili firmaya veya ürününe yönelik herhangi bir zarar verme ya da kötü niyetli bir davranışta bulunma gibi bir amaç barındırılmamaktadır.&lt;/p&gt;&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Öncelikle indirdiğimiz Firmware&amp;rsquo;in bilgilerine göz atalım:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../images/posts/reversing-router/firmware-info.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Görüldüğü üzere 14 Kasım 2024 yılında yayınlanmış. Yani neredeyse 1 ay önce yayınlanmış bir firmware. Birkaç hatanın düzeltildiği, optimizelerin yapıldığı ve yeni şeyler eklendiğini görebiliriz.&lt;/p&gt;
&lt;p&gt;Fiziksel olarak bu router&amp;rsquo;a sahip olmadığım için bu blogta sadece firmware analiz ederek yelteneceğim.&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;Linux Versiyonu Bulma&lt;/strong&gt;&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;linux-versiyonu-bulma&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#linux-versiyonu-bulma&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Özellikle firmware reverse engineering&amp;rsquo;de sıklıkla kullanılan &lt;strong&gt;binwalk&lt;/strong&gt; denilen aracı kullanacağız. Bu araç bize firmware için çeşitli bilgiler sunabilir.&lt;/p&gt;
&lt;p&gt;Öncelikle binwalk&amp;rsquo;a analiz edeceğimiz firmware verelim:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../images/posts/reversing-router/img2.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Evett okumaya üşendiğimiz birkaç karmaşık gibi görünen çıktılar elde ettik. Peki nedir bunlar efenimm?&lt;/p&gt;
&lt;p&gt;Bu gördüğünüz çıktılar ilgili firmware&amp;rsquo;in offsetlerini içermektedir. Ancak sadece offset değerleri verilmiyor yanlarında bu alanlar için açıklama da veriyor bu binwalk aracı. Gözümüz hemen bu çıktıdaki Decimal ve Hexdecimal değerlerine kaysın:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../images/posts/reversing-router/img3.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;İşte offset değerleri bunlar. Hem decimal hem de hexdecimal olarak binwalk aracı bize bunları gösteriyor. Şimdi ilk odağımızı Bootloader (U-Boot)&amp;lsquo;a yönlendirelim ve mimarisine bir göz atalım.&lt;/p&gt;
&lt;p&gt;Bu etapta &lt;strong&gt;dd&lt;/strong&gt; aracını kullanabiliriz. Bunun için aşağıdaki komutu çalıştıralım:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../images/posts/reversing-router/img4.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Verdiğimiz değerlere dikkat edelim. &lt;strong&gt;if&lt;/strong&gt; ile hedef firmware&amp;rsquo;i veriyoruz. &lt;strong&gt;of&lt;/strong&gt; ile çoğaltılan veriyi nasıl kaydedeceğimizi belirtiyoruz. &lt;strong&gt;skip&lt;/strong&gt; ile ise belirli bir byte miktarını atlayarak kopyalama işlemine başlıyor. &lt;strong&gt;8212&lt;/strong&gt; değeri verdiğime dikkat edin. Bu ise, dd aracın 8212 byte kadar sonrasındaki verileri kopyalacağı anlamına gelir. Bu değer binwalk&amp;rsquo;tan bulduğumuz uImage&amp;rsquo;ın offset değeri.&lt;/p&gt;
&lt;p&gt;Bu kopyalama sonucunda &lt;strong&gt;uImage&lt;/strong&gt; adlı bir dosya elde edeceğiz:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../images/posts/reversing-router/img5.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Kopyaladığımız dosyayı incelediğimizde &lt;strong&gt;u-boot Legacy uImage&lt;/strong&gt; olduğunu doğrulayabiliriz. Ayrıca arch&amp;rsquo;ın MIPS olduğunu da görebiliriz.&lt;/p&gt;
&lt;p&gt;Linux versiyonu aramak için ise tekrar binwalk çıktımıza bir göz atalım:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../images/posts/reversing-router/img2.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Tekrar offsetlere göz atarsak LZMA ile sıkıştırılmış bölüme gidebiliriz. &lt;strong&gt;.lzma&lt;/strong&gt; uzantılı olarak dosyayı alalım ve dosyayı çıkartalım:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../images/posts/reversing-router/img6.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Bu adımlardan sonra elimizde &lt;strong&gt;files&lt;/strong&gt; olarak bir dosya elimizde olmalı. Amacımız sadece &lt;strong&gt;strings&lt;/strong&gt; ile Linux versiyonuna göz atmak olacak:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../images/posts/reversing-router/img7.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Kullanılan Linux versiyonu &lt;strong&gt;3.10.108&lt;/strong&gt; ve GCC için ise &lt;strong&gt;4.6.3&lt;/strong&gt; kullanılmakta. Bu ikisi de eski versiyondur.&lt;/p&gt;
&lt;p&gt;Linux&amp;rsquo;un &lt;a href=&#34;https://lwn.net/Articles/738167/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;3.10.108 versiyonu&lt;/a&gt; &lt;strong&gt;5 Kasım 2017&lt;/strong&gt; yılında çıkmış:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../images/posts/reversing-router/img8.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;GCC&amp;rsquo;nin &lt;a href=&#34;https://gcc.gnu.org/gcc-4.6/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;4.6.3 versiyonu&lt;/a&gt; ise &lt;strong&gt;1 Mart 2012&lt;/strong&gt; yılında çıkmış:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../images/posts/reversing-router/img9.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Açıkçası ben &lt;strong&gt;Firmware Reverse Engineering&lt;/strong&gt; alanında yeni olsam da, 2024 yılında sunulmuş bir firmware&amp;rsquo;in eski Linux ve GCC versiyonu kullanmasını mantıklı bulmadım. Bu security açısından risk oluşturabilecek bir şey.&lt;/p&gt;
&lt;p&gt;Bunu gördüğüm zaman kendime şunu sordum: &lt;strong&gt;&amp;ldquo;Bunu farklı firmalar da yapıyor mu ve normal mi?&amp;rdquo;&lt;/strong&gt;. Her ne kadar da bunun normal olmadığını düşünsem de farklı bir firmanın Router Firmware&amp;rsquo;ini analiz ederek Linux versiyonunu karşılaştırmak istedim. Daha sonra kısa araştırmadan sonra ASUS&amp;rsquo;un &lt;a href=&#34;https://www.asus.com/tr/networking-iot-servers/wifi-routers/asus-wifi-routers/rt-ax58u/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RT-AX58U&lt;/a&gt; Router Firmware&amp;rsquo;i analiz etmeye karar verdim.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.asus.com/networking-iot-servers/wifi-6/all-series/rt-ax58u/helpdesk_bios?model2Name=RT-AX58U&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Bu Firmware&lt;/a&gt; için bilgiler ise şu şekilde:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../images/posts/reversing-router/img10.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Aynı şekilde bu Firmware ise neredeyse 1 ay önce çıkmış. Odağımızın dağılmaması için hızlıca bulduğum sonucu paylaşacağım. Fakat size tavsiyem daha çok pratik yapmak isterseniz bu blogu okuduktan sonra benim gibi ASUS Router&amp;rsquo;ın bu Firmware&amp;rsquo;ini analiz edebilirsiniz:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../images/posts/reversing-router/img11.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Sonuca baktığımızda bu Firmware için Linux&amp;rsquo;un &lt;strong&gt;4.19.183&lt;/strong&gt; ve GCC&amp;rsquo;nin &lt;strong&gt;9.2.0&lt;/strong&gt; versiyonu kullanılmakta.&lt;/p&gt;
&lt;p&gt;Linux&amp;rsquo;un &lt;a href=&#34;https://lwn.net/Articles/850356/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;4.19.183 versiyonu&lt;/a&gt; &lt;strong&gt;24 Mart 2021&lt;/strong&gt;&amp;lsquo;de çıkmış:
&lt;img src=&#34;../../../images/posts/reversing-router/img12.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;GCC&amp;rsquo;nin &lt;a href=&#34;https://gcc.gnu.org/gcc-9/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;9.2.0 versiyonu&lt;/a&gt; ise &lt;strong&gt;12 Ağustos 2019&lt;/strong&gt; yılında çıkmış&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../images/posts/reversing-router/img13.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;ASUS RT-AX58U&amp;rsquo;un bu Firmware&amp;rsquo;inde ise analiz ettiğimiz TP-LINK Firmware&amp;rsquo;ına kıyasla daha yakın bir tarihteki sürümler kullanıldığını görebiliriz ancak yine de bu sürümlerde eski.&lt;/p&gt;
&lt;p&gt;Bunun nedenini ilerideki bloglarda tartışabiliriz. Şimdi analizimize devam edelim.&lt;/p&gt;
&lt;p&gt;Analizimiz sonucunda bu Firmware için bulduğumuz Linux sürümü &lt;strong&gt;3.10.108&lt;/strong&gt;&amp;lsquo;dır. Şimdi ise bu Firmware&amp;rsquo;in Linux dosyalarına bir göz atalım.&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;Linux Dosyalarını Bulma&lt;/strong&gt;&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;linux-dosyalarını-bulma&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#linux-dosyalar%c4%b1n%c4%b1-bulma&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;binwalk ile elde ettiğimiz offset çıktılarına bir tekrar göz atalım:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../images/posts/reversing-router/img2.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Burada Linux dosyalarını bulmak için &lt;strong&gt;Squashfs&lt;/strong&gt; alanına yönelebiliriz. Çoğunlukla Linux dosyaları burada bulunurlar.&lt;/p&gt;
&lt;p&gt;Yine aynı şekilde &lt;strong&gt;.sqfs&lt;/strong&gt; uzantısı ile kopyalayalım:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../images/posts/reversing-router/img14.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Tekrarlamaktan zarar gelmez, &lt;strong&gt;3106242&lt;/strong&gt; offset değerini verdiğime dikkat edin. Burası &lt;strong&gt;Squashfs&lt;/strong&gt; ile sıkıştırılmış alanın offset değeri.&lt;/p&gt;
&lt;p&gt;Dosyayı incelediğimizde zaten &lt;strong&gt;Squashfs&lt;/strong&gt; ile sıkıştırıldığını doğrulayabiliriz. Şimdi ise bunu çıkartmamız gerekecek ancak eğer kurulu değilse &lt;strong&gt;Squashfs-tools&lt;/strong&gt; paketi indirilmesi gerekiyor. Debian sistemlerde aşağıdaki komutla indirebilirsiniz:&lt;/p&gt;
&lt;div class=&#34;hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code&#34;&gt;

&lt;div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo apt install squashfs-tools -y&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0&#34;&gt;
  &lt;button
    class=&#34;hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50&#34;
    title=&#34;Copy code&#34;
  &gt;
    &lt;div class=&#34;copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
    &lt;div class=&#34;success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
  &lt;/button&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;İndirdikten sonra &lt;strong&gt;unsquashfs&lt;/strong&gt; ile çıkartalım:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../images/posts/reversing-router/img15.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Çıkarma işleminden sonra &lt;strong&gt;squashfs-root&lt;/strong&gt; adlı bir dosya elde ediyoruz. İçerisine göz atalım:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../images/posts/reversing-router/img16.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Göründüğü üzere Linux dosyalarına eriştik. Bu kısımda yapabileceğimiz birçok şey bulunuyor. Bir bug, hashler veya şifreler gibi artık analiziniz neye dayanıyorsa ona göre araştırma yaparak ilerleyebilirsiniz. Mesela &lt;strong&gt;/etc/shadow&lt;/strong&gt; içerisindeki şifrelere göz atabiliriz:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../images/posts/reversing-router/img17.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Benim gibi yeni iseniz bu Linux dosyalarını araştırabilir ve diğer offset bölümlerini kopyalayıp göz atabilirsiniz.&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;Simüle Etme&lt;/strong&gt;&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;simüle-etme&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#sim%c3%bcle-etme&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Son olarak ise Firmware&amp;rsquo;i emule (simüle) edelim. Bunun için &lt;strong&gt;chroot&lt;/strong&gt; ve &lt;strong&gt;qemu&lt;/strong&gt; kullanabiliriz. Fakat ondan önce Firmware&amp;rsquo;in mimarisini bilmemiz gerekiyor.&lt;/p&gt;
&lt;p&gt;Linux versiyonunu ararken uImage&amp;rsquo;a göz attığımızda mimarinin &lt;strong&gt;MIPS&lt;/strong&gt; olduğunu zaten görmüştük. Ancak yine de çıktıyı bir kez daha kontrol edelim:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../images/posts/reversing-router/img5.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Göründüğü üzere MIPS olduğunu görebiliriz. Ayrıca da Little Endian.&lt;/p&gt;
&lt;p&gt;Qemu kullanacağımız için &lt;strong&gt;/usr/bin/qemu-mipsel-static&lt;/strong&gt; programını squashfs-root dosyasına kopyalayalım ve ardından chroot çalıştıralım:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../images/posts/reversing-router/img18.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Başarılı bir şekilde simüle etmiş olduk. Busybox&amp;rsquo;ın sürümüne göz attığımızda da &lt;strong&gt;1.19.4&lt;/strong&gt; kullanıldığını görmekteyiz. Bu da 2012 yılında çıkmış bir eski sürümdür.&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;Sonuç&lt;/strong&gt;&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;sonuç&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#sonu%c3%a7&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Firmware Reverse Engineering için ilk blogumda basitçe bir firmware&amp;rsquo;in nasıl analiz edebileceğimizi gördük. Eğer araştırmalara devam etmek isterseniz konu içerisinde bahsettiğim ASUS&amp;rsquo;un Firmware&amp;rsquo;ini analiz edebilirsiniz. Ayrıca da referanslara da göz atabilirsiniz.&lt;/p&gt;
&lt;p&gt;Umarım bu konu işinize yaramıştır efenimmm iyi çalışmalarr.&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;References&lt;/strong&gt;&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;references&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#references&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://embeddedbits.org/reverse-engineering-my-routers-firmware-with-binwalk-embeddedbits/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Embeddedbits - Reverse engineering my router&amp;rsquo;s firmware with binwalk&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=zs86OYea8Wk&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;John Hammond -  Getting Started in Firmware Analysis &amp;amp; IoT Reverse Engineering&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=oqk3cU7ekag&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Engineer Man - Simple Firmware Reverse Engineering&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
  </channel>
</rss>
